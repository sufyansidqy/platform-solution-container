# update to latest LM
prologue {
[oracle
	/***************************
	This enclosed block is specific to SQLPlus.
	It ensures that the script output is logged,
	and that the script will abort immediately if
	an error occurs.
	If you are using another tool please remove this block
	And its corresponding block at script end, and ensure
	that you are logging the output and that the script will
	abort when it encounters an error
	BEGIN SQL*PLUS-specific code
	****************************/
	Whenever SQLERROR EXIT SQL.SQLCODE;
	SPOOL @env:lm_script_logfilename@;
	/****************************
	END SQL*PLUS-specific code
	****************************/

	set define off
	
]
[mssql
	SET ANSI_NULL_DFLT_ON ON
	SET QUOTED_IDENTIFIER ON
	SET NOCOUNT ON
	:On Error exit

]
}

import 99 Package_LM_Upgrade_Latest.cmi



	/********************************************************************************/
	/********************************************************************************/
	/*										*/
	/*				VIEWS						*/
	/*										*/
	/********************************************************************************/
	/********************************************************************************/


	/* -------------------------------------------------------------------- */
	/*  fetch all the latest entries per each list (inc. deleted lists)*/
	/*  This view is for internal purposes                                               */
	/* -------------------------------------------------------------------- */
[mssql
	if exists (select * from sysobjects where name = 'V_LISTS_ENTRIES')
		drop view @env:lm_schema_name@.V_LISTS_ENTRIES
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LISTS_ENTRIES AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LISTS_ENTRIES AS
]
	SELECT  B.LIST_ID, B.VERSION, B.LIST_ENTRY_KEY , B.ENTRY_UPDATE_DATE, B.ENTRY_CREATED_DATE, B.UPDATE_CATEGORY, B.CRITICAL_UPDATE_DATE,
	                B.IS_DELETED, B.ENTRY_TYPE, B.ENTRY_FIRST_NAME, B.ENTRY_MIDDLE_NAME,
	                B.ENTRY_LAST_NAME, B.ENTRY_FULL_NAME, B.ENTRY_MAIDEN_NAME,
	                B.IS_BROKEN, B.CITIZENSHIP, B.DECEASED, B.DECEASED_DATE, B.GENDER, B.TITLE,
	                B.POSITION, B.ALIAS_SET, B.ADDRESS_SET, B.ID_SET,
	                B.NATIONALITY_COUNTRY_SET, B.AGE, B.AGE_AS_OF_DATE, B.DATE_OF_BIRTH_SET, B.LIST_VERSION_IDENTIFIER,
	                B.PLACE_OF_BIRTH_SET, B.KEYWORD_SET, B.CATEGORY_SET, B.ADD_INFO_SET, 
	                B.CUSTOM_FIELD_1, B.CUSTOM_FIELD_2, B.CUSTOM_FIELD_3, B.CUSTOM_FIELD_4, B.CUSTOM_FIELD_5,
	                B.CUSTOM_FIELD_6, B.CUSTOM_FIELD_7, B.CUSTOM_FIELD_8, B.CUSTOM_FIELD_9, B.CUSTOM_FIELD_10,
	                B.CUSTOM_FIELD_11, B.CUSTOM_FIELD_12, B.CUSTOM_FIELD_13, B.CUSTOM_FIELD_14, B.CUSTOM_FIELD_15,
	                B.CUSTOM_FIELD_16, B.CUSTOM_FIELD_17, B.CUSTOM_FIELD_18
	FROM   (
	                SELECT  LIST_ID, LIST_ENTRY_KEY, MAX (LIST_ENTRY_SORTER) AS MAX_ENTRY_SORTER
	                FROM (
	                                SELECT  /*+ INDEX(D IX_WLF_LIST_ENTRIES) */ D.LIST_VERSION_IDENTIFIER, D.LIST_ID, D.LIST_ENTRY_KEY, D.LIST_ENTRY_SORTER
	                                FROM   (
	                                                SELECT  LIST_VERSION_IDENTIFIER, LIST_ID, VERSION, LIST_TYPE
	                                                FROM   WLF_LIST_VERSIONS AA
	                                                WHERE AA.VERSION >= (
	                                                                                SELECT  MAX (VERSION)
	                                                                                FROM   WLF_LIST_VERSIONS BB
	                                                                                WHERE BB.LIST_ID = AA.LIST_ID
	                                                                                                AND BB.LIST_TYPE = 'FULL'
	                                                                                                AND BB.IS_ACTIVATED = 1
	                                                                                GROUP BY BB.LIST_ID
	                                                                )
	                                                                AND AA.IS_ACTIVATED = 1
	                                                ) C
	                                INNER JOIN
	                                                WLF_LIST_ENTRIES D ON 
	                                                                C.LIST_VERSION_IDENTIFIER = D.LIST_VERSION_IDENTIFIER
																    AND (D.REVIEW_STATUS IS NULL OR D.REVIEW_STATUS <> 'REJECTED')
	                                ) E
	                GROUP BY LIST_ID, LIST_ENTRY_KEY
	                ) A
	                INNER JOIN
	                                WLF_LIST_ENTRIES B ON 
	                                                A.LIST_ID = B.LIST_ID
	                                                AND A.LIST_ENTRY_KEY = B.LIST_ENTRY_KEY
	                                                AND A.MAX_ENTRY_SORTER = B.LIST_ENTRY_SORTER
												    AND (B.REVIEW_STATUS IS NULL OR B.REVIEW_STATUS <> 'REJECTED')
	                                                AND B.LIST_VERSION_IDENTIFIER IN (
	                                                                SELECT LIST_VERSION_IDENTIFIER
	                                                                FROM WLF_LIST_VERSIONS AA
	                                                                WHERE AA.VERSION >= (
	                                                                                                SELECT MAX (VERSION)
	                                                                                                FROM WLF_LIST_VERSIONS BB
	                                                                                                WHERE BB.LIST_ID = AA.LIST_ID
	                                                                                                AND BB.LIST_TYPE = 'FULL'
	                                                                                                AND BB.IS_ACTIVATED = 1
	                                                                                                GROUP BY BB.LIST_ID
	                                                                                )
	                                                                                AND AA.IS_ACTIVATED = 1
	                                                                )
		@go@
		
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_POLICY_RULES_AUDIT')
		drop view @env:lm_schema_name@.V_WLF_POLICY_RULES_AUDIT
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_POLICY_RULES_AUDIT AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_POLICY_RULES_AUDIT AS
]
	SELECT ID,JOB_ID,MESSAGE_KEY,MESSAGE_REF_NUMBER,LIST_ID,
		   ENTRY_ID,PROCESS_DATE,MESSAGE_DATETIME,INSTANCE_ID,
		   SEARCH_DEF_ID,RULE_ID,ACTION
    FROM
    	WLF_POLICY_RULES_AUDIT
	@go@



[mssql
	if exists (select * from sysobjects where name = 'V_LATEST_LIST_ENTRIES')
		drop view @env:lm_schema_name@.V_LATEST_LIST_ENTRIES
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LATEST_LIST_ENTRIES AS
	  SELECT B.LIST_ID,
        B.VERSION,
        B.LIST_ID_PART,
        B.LIST_ENTRY_KEY ,
        B.ENTRY_UPDATE_DATE,
        B.ENTRY_CREATED_DATE,
        B.IS_DELETED,
    	B.UPDATE_CATEGORY,
    	B.CRITICAL_UPDATE_DATE,
        B.ENTRY_TYPE,
        B.ENTRY_FIRST_NAME,
        B.ENTRY_MIDDLE_NAME,
        B.ENTRY_LAST_NAME,
        B.ENTRY_FULL_NAME,
        B.ENTRY_MAIDEN_NAME,
        B.IS_BROKEN,
        B.CITIZENSHIP,
        B.DECEASED,
        B.DECEASED_DATE,
        B.GENDER,
        B.TITLE,
        B.POSITION,
        B.ALIAS_SET,
        B.ADDRESS_SET,
        B.ID_SET,
        B.NATIONALITY_COUNTRY_SET,
    	B.AGE,
        B.AGE_AS_OF_DATE,
        B.DATE_OF_BIRTH_SET,
        B.LIST_VERSION_IDENTIFIER,
        B.PLACE_OF_BIRTH_SET,
        B.KEYWORD_SET,
        B.CATEGORY_SET,
        B.ADD_INFO_SET,
        B.CUSTOM_FIELD_1,
        B.CUSTOM_FIELD_2,
        B.CUSTOM_FIELD_3,
        B.CUSTOM_FIELD_4,
        B.CUSTOM_FIELD_5,
        B.CUSTOM_FIELD_6,
        B.CUSTOM_FIELD_7,
        B.CUSTOM_FIELD_8,
        B.CUSTOM_FIELD_9,
        B.CUSTOM_FIELD_10,
        B.CUSTOM_FIELD_11,
        B.CUSTOM_FIELD_12,
        B.CUSTOM_FIELD_13,
        B.CUSTOM_FIELD_14,
        B.CUSTOM_FIELD_15,
        B.CUSTOM_FIELD_16,
        B.CUSTOM_FIELD_17,
        B.CUSTOM_FIELD_18
      FROM WLF_LATEST_LIST_ENTRIES B
      INNER JOIN WLF_LIST_DEFINITIONS D
          ON B.LIST_ID = D.LIST_ID
          AND B.LIST_ID_PART = D.LATEST_LIST_ID_PART
    	@go@
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LATEST_LIST_ENTRIES AS

  SELECT B.LIST_ID,
    B.VERSION,
    B.LIST_ENTRY_KEY ,
    B.ENTRY_UPDATE_DATE,
    B.ENTRY_CREATED_DATE,
    B.IS_DELETED,
	B.UPDATE_CATEGORY,
	B.CRITICAL_UPDATE_DATE,
    B.ENTRY_TYPE,
    B.ENTRY_FIRST_NAME,
    B.ENTRY_MIDDLE_NAME,
    B.ENTRY_LAST_NAME,
    B.ENTRY_FULL_NAME,
    B.ENTRY_MAIDEN_NAME,
    B.IS_BROKEN,
    B.CITIZENSHIP,
    B.DECEASED,
    B.DECEASED_DATE,
    B.GENDER,
    B.TITLE,
    B.POSITION,
    B.ALIAS_SET,
    B.ADDRESS_SET,
    B.ID_SET,
    B.NATIONALITY_COUNTRY_SET,
	B.AGE,
    B.AGE_AS_OF_DATE,
    B.DATE_OF_BIRTH_SET,
    B.LIST_VERSION_IDENTIFIER,
    B.PLACE_OF_BIRTH_SET,
    B.KEYWORD_SET,
    B.CATEGORY_SET,
    B.ADD_INFO_SET,
    B.CUSTOM_FIELD_1,
    B.CUSTOM_FIELD_2,
    B.CUSTOM_FIELD_3,
    B.CUSTOM_FIELD_4,
    B.CUSTOM_FIELD_5,
    B.CUSTOM_FIELD_6,
    B.CUSTOM_FIELD_7,
    B.CUSTOM_FIELD_8,
    B.CUSTOM_FIELD_9,
    B.CUSTOM_FIELD_10,
    B.CUSTOM_FIELD_11,
    B.CUSTOM_FIELD_12,
    B.CUSTOM_FIELD_13,
    B.CUSTOM_FIELD_14,
    B.CUSTOM_FIELD_15,
    B.CUSTOM_FIELD_16,
    B.CUSTOM_FIELD_17,
    B.CUSTOM_FIELD_18
  FROM WLF_LATEST_LIST_ENTRIES B
  INNER JOIN WLF_LIST_DEFINITIONS D
      ON B.LIST_ID = D.LIST_ID
      AND B.LIST_ID_PART = D.LATEST_LIST_ID_PART
	@go@
]

	/* ------------------------------------------------------------------- */
	/*  fetch all the latest entries per each [non deleted] list     */
	/* -------------------------------------------------------------------	*/

[mssql
	if exists (select * from sysobjects where name = 'V_LATEST_VERSIONS_LIST')
		drop view @env:lm_schema_name@.V_LATEST_VERSIONS_LIST 
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LATEST_VERSIONS_LIST AS
	SELECT  LS.LIST_ID, LS.VERSION, LS.LIST_ID_PART, LS.LIST_ENTRY_KEY , LS.ENTRY_UPDATE_DATE, LS.ENTRY_CREATED_DATE, G.ENTRY_MAX_UPDATE_DATE, LS.UPDATE_CATEGORY,
								LS.CRITICAL_UPDATE_DATE, LS.IS_DELETED, LS.ENTRY_TYPE, LS.ENTRY_FIRST_NAME, LS.ENTRY_MIDDLE_NAME,
                                LS.ENTRY_LAST_NAME, LS.ENTRY_FULL_NAME, LS.ENTRY_MAIDEN_NAME,
                                LS.IS_BROKEN, LS.CITIZENSHIP, LS.DECEASED, LS.DECEASED_DATE, LS.GENDER, LS.TITLE,
                                LS.POSITION, LS.ALIAS_SET, LS.ADDRESS_SET, LS.ID_SET,
                                LS.NATIONALITY_COUNTRY_SET, LS.AGE, LS.AGE_AS_OF_DATE, LS.DATE_OF_BIRTH_SET, LS.LIST_VERSION_IDENTIFIER,
                                LS.PLACE_OF_BIRTH_SET, LS.KEYWORD_SET, LS.CATEGORY_SET, LS.ADD_INFO_SET,
                                LS.CUSTOM_FIELD_1, LS.CUSTOM_FIELD_2, LS.CUSTOM_FIELD_3, LS.CUSTOM_FIELD_4, LS.CUSTOM_FIELD_5,
                                LS.CUSTOM_FIELD_6, LS.CUSTOM_FIELD_7, LS.CUSTOM_FIELD_8, LS.CUSTOM_FIELD_9, LS.CUSTOM_FIELD_10,
                                LS.CUSTOM_FIELD_11, LS.CUSTOM_FIELD_12, LS.CUSTOM_FIELD_13, LS.CUSTOM_FIELD_14, LS.CUSTOM_FIELD_15,
                                                                                LS.CUSTOM_FIELD_16, LS.CUSTOM_FIELD_17, LS.CUSTOM_FIELD_18
                FROM
                V_LATEST_LIST_ENTRIES LS
                Inner Join WLF_LIST_DEFINITIONS LD
                                ON LS.LIST_ID = LD.LIST_ID
  				Inner Join WLF_LIST_VERSIONS G ON LS.LIST_ID = G.LIST_ID AND LS.VERSION = G.VERSION
	WHERE COALESCE(LD.IS_DELETED,0) = 0
	@go@
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LATEST_VERSIONS_LIST AS

	SELECT  LS.LIST_ID, LS.VERSION, LS.LIST_ENTRY_KEY , LS.ENTRY_UPDATE_DATE, LS.ENTRY_CREATED_DATE, G.ENTRY_MAX_UPDATE_DATE, LS.UPDATE_CATEGORY,
								LS.CRITICAL_UPDATE_DATE, LS.IS_DELETED, LS.ENTRY_TYPE, LS.ENTRY_FIRST_NAME, LS.ENTRY_MIDDLE_NAME,
                                LS.ENTRY_LAST_NAME, LS.ENTRY_FULL_NAME, LS.ENTRY_MAIDEN_NAME,
                                LS.IS_BROKEN, LS.CITIZENSHIP, LS.DECEASED, LS.DECEASED_DATE, LS.GENDER, LS.TITLE,
                                LS.POSITION, LS.ALIAS_SET, LS.ADDRESS_SET, LS.ID_SET,
                                LS.NATIONALITY_COUNTRY_SET, LS.AGE, LS.AGE_AS_OF_DATE, LS.DATE_OF_BIRTH_SET, LS.LIST_VERSION_IDENTIFIER,
                                LS.PLACE_OF_BIRTH_SET, LS.KEYWORD_SET, LS.CATEGORY_SET, LS.ADD_INFO_SET,
                                LS.CUSTOM_FIELD_1, LS.CUSTOM_FIELD_2, LS.CUSTOM_FIELD_3, LS.CUSTOM_FIELD_4, LS.CUSTOM_FIELD_5,
                                LS.CUSTOM_FIELD_6, LS.CUSTOM_FIELD_7, LS.CUSTOM_FIELD_8, LS.CUSTOM_FIELD_9, LS.CUSTOM_FIELD_10,
                                LS.CUSTOM_FIELD_11, LS.CUSTOM_FIELD_12, LS.CUSTOM_FIELD_13, LS.CUSTOM_FIELD_14, LS.CUSTOM_FIELD_15,
                                                                                LS.CUSTOM_FIELD_16, LS.CUSTOM_FIELD_17, LS.CUSTOM_FIELD_18
                FROM
                V_LATEST_LIST_ENTRIES LS 
                Inner Join WLF_LIST_DEFINITIONS LD 
                                ON LS.LIST_ID = LD.LIST_ID
  				Inner Join WLF_LIST_VERSIONS G ON LS.LIST_ID = G.LIST_ID AND LS.VERSION = G.VERSION
	WHERE COALESCE(LD.IS_DELETED,0) = 0
	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  For each list - get latest FULL version and all the DELTAs after it		*/
	/* ---------------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_LIST_LATEST_VERSIONS')
		drop view @env:lm_schema_name@.V_LIST_LATEST_VERSIONS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LIST_LATEST_VERSIONS AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LIST_LATEST_VERSIONS AS
]
	select    b.LIST_ID, b.VERSION, b.LIST_TYPE, b.LIST_VERSION_IDENTIFIER, b.ENTRY_MAX_UPDATE_DATE, b.LIST_COUNT as ENTRY_COUNT
	from
	(
	                select    LIST_ID, MAX(VERSION) as FULL_VERSION
	                from      WLF_LIST_VERSIONS
	                where   LIST_TYPE = 'FULL' and IS_ACTIVATED = 1
	                group by LIST_ID
	) a
	Inner Join
	(
	                select LIST_ID, VERSION, LIST_TYPE, LIST_VERSION_IDENTIFIER, ENTRY_MAX_UPDATE_DATE, LIST_COUNT
	                from      WLF_LIST_VERSIONS
	                where   IS_ACTIVATED = 1
	) b
	ON a.LIST_ID = b.LIST_ID and b.VERSION >= a.FULL_VERSION
	Inner Join WLF_LIST_DEFINITIONS c ON a.LIST_ID = c.LIST_ID and COALESCE(c.IS_DELETED,0) = 0
	@go@


	/* ---------------------------------------------------------------------------- */
	/*  Get distinct lists								*/
	/* ---------------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_DISTINCT_LISTS')
		drop view @env:lm_schema_name@.V_DISTINCT_LISTS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_DISTINCT_LISTS AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_DISTINCT_LISTS AS
]
	select  DISTINCT LIST_ID, TYPE
	from    WLF_LIST_DEFINITIONS
	where   COALESCE(IS_DELETED,0) <> 1
	@go@


	/* ---------------------------------------------------------------------------- */
	/*  Get 'ETL' JOBS AND DETAILS								*/
	/* ---------------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_ETL_JOBS')
		drop view @env:lm_schema_name@.V_ETL_JOBS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_ETL_JOBS AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_ETL_JOBS AS
]
	select J.JOB_ID, J.JOB_NAME,J.JOB_TYPE,J.STATUS, J.JOB_TIMESTAMP,J.JOB_USER, J.JOB_COMPLETE_TIMESTAMP,
	D.LIST_ID, D.VERSION, E.NAME as LIST_NAME,D.LIST_COUNT
	FROM @env:lm_schema_name@.WLF_JOBS_LOG J
	join @env:lm_schema_name@.WLF_JOB_ETL_DETAILS D ON J.JOB_ID = D.JOB_ID
  	LEFT join @env:lm_schema_name@.WLF_LIST_DEFINITIONS E on D.LIST_ID = E.LIST_ID
	@go@

	/* ---------------------------------------------------------------------------- */
	/*  Get 'CF' JOBS AND DETAILS								*/
	/* ---------------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_CF_JOBS')
		drop view @env:lm_schema_name@.V_CF_JOBS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_CF_JOBS AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_CF_JOBS AS
]
	select J.JOB_ID, J.JOB_NAME,J.JOB_TYPE,J.STATUS, J.JOB_TIMESTAMP,J.JOB_USER, J.JOB_COMPLETE_TIMESTAMP,
	D.BUSINESS_UNIT, D.ALERTED_PARTIES_COUNT, D.TOTAL_PARTIES_COUNT, D.SEARCH_CONFIG_ID, D.SEARCH_CONFIG_NAME, D.DELTA, D.DELTA_AFTER_DATE, 
	D.INPUT_FILENAME, D.GENERATE_ALERTS,D.GENERATE_OUTPUTFILE,D.GENERATE_TUNING_LOG ,D.NUMBER_OF_THREADS ,D.REGION,D.RERUN ,D.SUPPRESS_HITS,
	D.SEGMENT_ID,D.TOTAL_SEGMENTS,0 as FILTER_DUPLICATES, 
[mssql	
	N'CF_BATCH' as VIEW_TYPE
]	
[oracle	
	'CF_BATCH' as VIEW_TYPE
]	
	FROM @env:lm_schema_name@.WLF_JOBS_LOG J
	join @env:lm_schema_name@.WLF_JOB_CF_DETAILS D ON J.JOB_ID = D.JOB_ID
	UNION ALL
	select J.STAGING_UID AS JOB_ID, J.NAME AS JOB_NAME,J.TYPE AS JOB_TYPE,J.STATUS, J.CREATION_DATE AS JOB_TIMESTAMP,J.CREATED_BY AS JOB_USER, NULL AS JOB_COMPLETED_TIMESTAMP,
	NULL AS BUSINESS_UNIT, 0 AS ALERTED_PARTIES_COUNT, 0 AS TOTAL_PARTIES_COUNT, J.CONFIG_ID AS SEARCH_CONFIG_ID, NULL AS SEARCH_CONFIG_NAME, J.DELTA, J.DELTA_AFTER_DATE, 
	J.FILENAME AS INPUT_FILENAME, J.GENERATE_ALERTS, J.GENERATE_OUTPUTFILE, 0 AS GENERATE_TUNING_LOG, 0 AS NUMBER_OF_THREADS, NULL AS REGION, 0 AS RERUN, J.SUPPRESS_HITS as SUPPRESS_HITS,
	NULL as SEGMENT_ID, 0 as TOTAL_SEGMENTS,
	0 as FILTER_DUPLICATES, 'CF_SSB' as VIEW_TYPE
	from @env:lm_schema_name@.WLF_SELF_SERVICE_JOBS J
	WHERE J.STATUS in ('PENDING','CANCELED')
	UNION ALL
	select J.JOB_ID, J.JOB_NAME,J.JOB_TYPE,J.STATUS, J.JOB_TIMESTAMP,J.JOB_USER, J.JOB_COMPLETE_TIMESTAMP,
	M.BUSINESS_UNIT, M.ALERTED_COUNT as ALERTED_PARTIES_COUNT, M.TOTAL_COUNT as TOTAL_PARTIES_COUNT, M.SEARCH_DEF_ID as SEARCH_CONFIG_ID, M.SEARCH_DEF_NAME as SEARCH_CONFIG_NAME, NULL as DELTA, NULL as DELTA_AFTER_DATE, 
	M.INPUT_FILENAME, M.GENERATE_ALERTS, 0 as GENERATE_OUTPUTFILE, M.GENERATE_TUNING_LOG, M.NUMBER_OF_THREADS, M.REGION, 0 as RERUN, 0 as SUPPRESS_HITS,
	NULL as segment_id,0 as total_segments,
	M.FILTER_DUPLICATES, 'MS_BATCH' as VIEW_TYPE
	FROM WLF_JOBS_LOG J
	join WLF_JOB_MS_DETAILS M ON J.JOB_ID = M.JOB_ID
	@go@
	
	/* ---------------------------------------------------------------------------- */
	/* LIST VERSION ENTRIES SUMMARY								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_LIST_VERSION_ENTRIES_SUMMARY')
		drop view @env:lm_schema_name@.V_LIST_VERSION_ENTRIES_SUMMARY
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LIST_VERSION_ENTRIES_SUMMARY AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LIST_VERSION_ENTRIES_SUMMARY AS
]
  	SELECT
    A.LIST_ID              AS LIST_ID,
    A.NAME                 AS NAME,
    A.TYPE                 AS TYPE,
[oracle	
	TO_CHAR(A.DESCRIPTION)
]
[mssql
	CONVERT(@ustring@(4000),A.DESCRIPTION)
]
    AS DESCRIPTION,
    A.CREATION_DATE        AS CREATION_DATE,
    A.CREATED_BY           AS CREATED_BY,
    B.UPDATED_DATE         AS UPDATED_DATE,
    B.UPDATED_BY           AS UPDATED_BY,
    B.VERSION              AS VERSION,
    E.ENTRY_COUNT			AS ENTRY_COUNT,
    A.VISIBILITY_ID		   AS VISIBILITY_ID,
    A.BU_NAME			   AS BU_NAME,
    A.REQUIRES_REVIEW      AS REQUIRES_REVIEW,
    Q.DRAFT_STATUS         AS DRAFT_STATUS
  	FROM WLF_LIST_DEFINITIONS A
  	INNER JOIN WLF_LIST_VERSIONS B
  	ON B.LIST_VERSION_IDENTIFIER =
    (SELECT MAX(C.LIST_VERSION_IDENTIFIER)
    FROM V_LIST_LATEST_VERSIONS C
    WHERE C.LIST_ID = A.LIST_ID)
  	AND COALESCE(A.IS_DELETED,0) = 0
    LEFT Join WLF_LIST_VERSIONS Q ON 
	   Q.LIST_ID = A.LIST_ID
	   AND Q.DRAFT_STATUS = 'REVIEW'
    INNER JOIN
    (
        SELECT D.LIST_ID, D.ENTRY_COUNT FROM
        (
            SELECT LIST_ID AS LIST_ID, (COUNT(LIST_ID) - SUM(IS_DELETED)) AS ENTRY_COUNT, LIST_ID_PART
            FROM WLF_LATEST_LIST_ENTRIES
            GROUP BY LIST_ID, LIST_ID_PART
        ) D
        INNER JOIN
        WLF_LIST_DEFINITIONS DD ON D.LIST_ID = DD.LIST_ID AND D.LIST_ID_PART = DD.LATEST_LIST_ID_PART
    ) E
  	ON A.LIST_ID = E.LIST_ID
  	UNION ALL
  	SELECT A.LIST_ID         AS LIST_ID,
    A.NAME                 AS NAME,
    A.TYPE                 AS TYPE,
[oracle	
	TO_CHAR(A.DESCRIPTION)
]
[mssql
	CONVERT(@ustring@(4000),A.DESCRIPTION)
]
    AS DESCRIPTION,
    A.CREATION_DATE        AS CREATION_DATE,
    A.CREATED_BY           AS CREATED_BY,
    A.CREATION_DATE        AS UPDATED_DATE,
    A.CREATED_BY           AS UPDATED_BY,
    0                      AS VERSION,
    0                      AS ENTRY_COUNT,
    A.VISIBILITY_ID		   AS VISIBILITY_ID,
    A.BU_NAME			   AS BU_NAME,
    A.REQUIRES_REVIEW      AS REQUIRES_REVIEW,
    Q.DRAFT_STATUS         AS DRAFT_STATUS
  	FROM WLF_LIST_DEFINITIONS A
    LEFT Join WLF_LIST_VERSIONS Q ON 
	   Q.LIST_ID = A.LIST_ID
	   AND Q.DRAFT_STATUS = 'REVIEW'
  	WHERE A.LIST_ID NOT IN
    (SELECT LIST_ID FROM V_LIST_LATEST_VERSIONS WHERE ENTRY_COUNT > 0)
  	AND COALESCE(A.IS_DELETED,0) <> 1;
	@go@

	/* ------------------------------------------------------------------- */
	/*  fetch all the latest + draft entries per each [non deleted] list    */
	/* ------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_LATEST_PLUS_DRAFT_ENTRIES')
		drop view @env:lm_schema_name@.V_LATEST_PLUS_DRAFT_ENTRIES 
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LATEST_PLUS_DRAFT_ENTRIES AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LATEST_PLUS_DRAFT_ENTRIES AS
]
	SELECT  LS.LIST_ID, LS.VERSION, LS.LIST_ENTRY_KEY , LS.ENTRY_UPDATE_DATE, LS.ENTRY_CREATED_DATE, G.ENTRY_MAX_UPDATE_DATE,
                                LS.IS_DELETED, LS.UPDATE_CATEGORY, LS.CRITICAL_UPDATE_DATE, LS.ENTRY_TYPE, LS.ENTRY_FIRST_NAME, LS.ENTRY_MIDDLE_NAME,
                                LS.ENTRY_LAST_NAME, LS.ENTRY_FULL_NAME, LS.ENTRY_MAIDEN_NAME,
                                LS.IS_BROKEN, LS.CITIZENSHIP, LS.DECEASED, LS.DECEASED_DATE, LS.GENDER, LS.TITLE,
                                LS.POSITION, LS.ALIAS_SET, LS.ADDRESS_SET, LS.ID_SET,
                                LS.NATIONALITY_COUNTRY_SET, LS.AGE, LS.AGE_AS_OF_DATE, LS.DATE_OF_BIRTH_SET, LS.LIST_VERSION_IDENTIFIER,
                                LS.PLACE_OF_BIRTH_SET, LS.KEYWORD_SET, LS.CATEGORY_SET, LS.ADD_INFO_SET,
                                LS.CUSTOM_FIELD_1, LS.CUSTOM_FIELD_2, LS.CUSTOM_FIELD_3, LS.CUSTOM_FIELD_4, LS.CUSTOM_FIELD_5,
                                LS.CUSTOM_FIELD_6, LS.CUSTOM_FIELD_7, LS.CUSTOM_FIELD_8, LS.CUSTOM_FIELD_9, LS.CUSTOM_FIELD_10,
                                LS.CUSTOM_FIELD_11, LS.CUSTOM_FIELD_12, LS.CUSTOM_FIELD_13, LS.CUSTOM_FIELD_14, LS.CUSTOM_FIELD_15,
                                LS.CUSTOM_FIELD_16, LS.CUSTOM_FIELD_17, LS.CUSTOM_FIELD_18,
    							LS.LAST_EDITED_DATE, LS.LAST_EDITED_BY, LS.IS_NEW, LS.LAST_REVIEWED_DATE, LS.LAST_REVIEWED_BY, LS.REVIEW_STATUS, G.DRAFT_STATUS
                FROM
                (
                                SELECT  B.LIST_ID, B.VERSION, B.LIST_ENTRY_KEY , B.ENTRY_UPDATE_DATE, B.ENTRY_CREATED_DATE,
                                                B.IS_DELETED, B.UPDATE_CATEGORY, B.CRITICAL_UPDATE_DATE, B.ENTRY_TYPE, B.ENTRY_FIRST_NAME, B.ENTRY_MIDDLE_NAME,
                                                B.ENTRY_LAST_NAME, B.ENTRY_FULL_NAME, B.ENTRY_MAIDEN_NAME,
                                                B.IS_BROKEN, B.CITIZENSHIP, B.DECEASED, B.DECEASED_DATE, B.GENDER, B.TITLE,
                                                B.POSITION, B.ALIAS_SET, B.ADDRESS_SET, B.ID_SET,
                                                B.NATIONALITY_COUNTRY_SET, B.AGE, B.AGE_AS_OF_DATE, B.DATE_OF_BIRTH_SET, B.LIST_VERSION_IDENTIFIER,
                                                B.PLACE_OF_BIRTH_SET, B.KEYWORD_SET, B.CATEGORY_SET, B.ADD_INFO_SET, 
                                                B.CUSTOM_FIELD_1, B.CUSTOM_FIELD_2, B.CUSTOM_FIELD_3, B.CUSTOM_FIELD_4, B.CUSTOM_FIELD_5,
                                                B.CUSTOM_FIELD_6, B.CUSTOM_FIELD_7, B.CUSTOM_FIELD_8, B.CUSTOM_FIELD_9, B.CUSTOM_FIELD_10,
                                                B.CUSTOM_FIELD_11, B.CUSTOM_FIELD_12, B.CUSTOM_FIELD_13, B.CUSTOM_FIELD_14, B.CUSTOM_FIELD_15,
                                                B.CUSTOM_FIELD_16, B.CUSTOM_FIELD_17, B.CUSTOM_FIELD_18,
				    							B.LAST_EDITED_DATE, B.LAST_EDITED_BY, B.IS_NEW, B.LAST_REVIEWED_DATE, B.LAST_REVIEWED_BY, B.REVIEW_STATUS
                                FROM   (
                                                SELECT  LIST_ID, LIST_ENTRY_KEY, MAX (LIST_ENTRY_SORTER) AS MAX_ENTRY_SORTER
                                                FROM (
                                                                SELECT  /*+ INDEX(D IX_WLF_LIST_ENTRIES) */ D.LIST_VERSION_IDENTIFIER, D.LIST_ID, D.LIST_ENTRY_KEY, D.LIST_ENTRY_SORTER
                                                                FROM   (
                                                                                SELECT  LIST_VERSION_IDENTIFIER, LIST_ID, VERSION, LIST_TYPE, IS_ACTIVATED
                                                                                FROM   WLF_LIST_VERSIONS AA
                                                                                WHERE AA.VERSION >= (
                                                                                                    SELECT  MAX (VERSION)
                                                                                                    FROM   WLF_LIST_VERSIONS BB
                                                                                                    WHERE BB.LIST_ID = AA.LIST_ID
                                                                                                    AND BB.LIST_TYPE = 'FULL'
																						            AND (BB.IS_ACTIVATED = 1 
																						            OR (BB.IS_ACTIVATED = 0 AND BB.DRAFT_STATUS IS NOT NULL AND BB.DRAFT_STATUS <> 'READY'))
                                                                                                    GROUP BY BB.LIST_ID
                                                                                                )
																						        AND (AA.IS_ACTIVATED = 1 
																						        OR (AA.IS_ACTIVATED = 0 AND AA.DRAFT_STATUS IS NOT NULL AND AA.DRAFT_STATUS <> 'READY'))
                                                                                ) C
                                                                INNER JOIN
                                                                                WLF_LIST_ENTRIES D ON 
                                                                                                C.LIST_VERSION_IDENTIFIER = D.LIST_VERSION_IDENTIFIER
																								AND ((C.IS_ACTIVATED         = 1
																								        AND D.REVIEW_STATUS         IS NULL
																								        OR D.REVIEW_STATUS          <> 'REJECTED')
																								        OR C.IS_ACTIVATED            = 0)
							                    ) E
                                                GROUP BY LIST_ID, LIST_ENTRY_KEY
                                                ) A
                                                INNER JOIN
                                                                WLF_LIST_ENTRIES B ON 
                                                                                A.LIST_ID = B.LIST_ID
                                                                                AND A.LIST_ENTRY_KEY = B.LIST_ENTRY_KEY
                                                                                AND A.MAX_ENTRY_SORTER = B.LIST_ENTRY_SORTER
                                                                                AND B.LIST_VERSION_IDENTIFIER IN (
                                                                                                SELECT LIST_VERSION_IDENTIFIER
                                                                                                FROM WLF_LIST_VERSIONS AA
                                                                                                WHERE AA.VERSION >= (
                                                                                                                       SELECT MAX (VERSION)
                                                                                                                       FROM WLF_LIST_VERSIONS BB
                                                                                                                       WHERE BB.LIST_ID = AA.LIST_ID
                                                                                                                       AND BB.LIST_TYPE = 'FULL'
																											           AND (BB.IS_ACTIVATED = 1 
																											           OR (BB.IS_ACTIVATED = 0 AND BB.DRAFT_STATUS IS NOT NULL AND BB.DRAFT_STATUS <> 'READY'))
                                                                                                                       GROUP BY BB.LIST_ID
                                                                                                                )
																										        AND (AA.IS_ACTIVATED = 1 
																										        OR (AA.IS_ACTIVATED = 0 AND AA.DRAFT_STATUS IS NOT NULL AND AA.DRAFT_STATUS <> 'READY'))
                                                                                                )
                ) LS 
                Inner Join WLF_LIST_DEFINITIONS LD 
                                ON LS.LIST_ID = LD.LIST_ID
  				Inner Join WLF_LIST_VERSIONS G ON LS.LIST_ID = G.LIST_ID AND LS.VERSION = G.VERSION
	WHERE COALESCE(LD.IS_DELETED,0) = 0
	@go@

	/* ---------------------------------------------------------------------------- */
	/* LIST VERSION AUDITING								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_LIST_VERSIONS_AUDITING')
		drop view @env:lm_schema_name@.V_LIST_VERSIONS_AUDITING
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LIST_VERSIONS_AUDITING AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LIST_VERSIONS_AUDITING AS
]
	  SELECT LIST_VERSION_IDENTIFIER,
	    LIST_ID,
	    VERSION,
	    IS_ACTIVATED,
	    IS_DELETED,
	    LIST_COUNT,
	    UPDATED_DATE,
	    UPDATED_BY,
	    DRAFT_STATUS,
	    DRAFT_OPENED_DATE,
	    DRAFT_OPENED_BY,
	    REVIEW_OPENED_DATE,
	    REVIEW_OPENED_BY,
	    0 AS IS_ARCHIVED
	  FROM
	    WLF_LIST_VERSIONS
	  UNION ALL
	  SELECT LIST_VERSION_IDENTIFIER,
	    LIST_ID,
	    VERSION,
	    IS_ACTIVATED,
	    IS_DELETED,
	    LIST_COUNT,
	    UPDATED_DATE,
	    UPDATED_BY,
	    DRAFT_STATUS,
	    DRAFT_OPENED_DATE,
	    DRAFT_OPENED_BY,
	    REVIEW_OPENED_DATE,
	    REVIEW_OPENED_BY,
	    1 AS IS_ARCHIVED
	  FROM
	    WLF_ARC_LIST_VERSIONS
	@go@

	/* ---------------------------------------------------------------------------- */
	/* LIST ENTRIES AUDITING								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_LIST_ENTRIES_AUDITING')
		drop view @env:lm_schema_name@.V_LIST_ENTRIES_AUDITING
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_LIST_ENTRIES_AUDITING AS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_LIST_ENTRIES_AUDITING AS
]
	  SELECT LIST_VERSION_IDENTIFIER,
	    LIST_ID,
	    VERSION,
	    LIST_ENTRY_KEY,
	    ENTRY_UPDATE_DATE,
	    IS_DELETED,
	    ENTRY_TYPE,
	    ENTRY_FULL_NAME,
	    ENTRY_CREATED_DATE,
	    LAST_EDITED_DATE,
	    LAST_EDITED_BY,
	    IS_NEW,
	    LAST_REVIEWED_DATE,
	    LAST_REVIEWED_BY,
	    REVIEW_STATUS,
	    0 AS IS_ARCHIVED
	  FROM
	    WLF_LIST_ENTRIES
	  UNION ALL
	  SELECT LIST_VERSION_IDENTIFIER,
	    LIST_ID,
	    VERSION,
	    LIST_ENTRY_KEY,
	    ENTRY_UPDATE_DATE,
	    IS_DELETED,
	    ENTRY_TYPE,
	    ENTRY_FULL_NAME,
	    ENTRY_CREATED_DATE,
	    LAST_EDITED_DATE,
	    LAST_EDITED_BY,
	    IS_NEW,
	    LAST_REVIEWED_DATE,
	    LAST_REVIEWED_BY,
	    REVIEW_STATUS,
	    1 AS IS_ARCHIVED
	  FROM
	    WLF_ARC_LIST_ENTRIES
	@go@
	
	/* ---------------------------------------------------------------------------- */
	/* SEARCH DEFINITION METADATA								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SRCHDEF_METADATA')
		drop view @env:lm_schema_name@.V_WLF_SRCHDEF_METADATA
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SRCHDEF_METADATA AS
	SELECT ID,
	NAME,
	DESCRIPTION,
	DISPLAY_ORDER,
	TUNING_ID,
	CF_PERSON_HIT_THRESHOLD,
	CF_ORG_HIT_THRESHOLD,
	CF_COUNTRY_HIT_THRESHOLD,
	MS_PERSON_HIT_THRESHOLD,
	MS_ORG_HIT_THRESHOLD,
	MS_COUNTRY_HIT_THRESHOLD,
	MS_PERSON_TUN_HIT_THRESHOLD,
   	MS_ORG_TUN_HIT_THRESHOLD,
	MS_COUNTRY_TUN_HIT_THRESHOLD,
	MS_HOLD_THRESHOLD,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigs&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + ID
    + '">Search Configs</a><br>' 
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefBusinessUnits&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + ID
    + '">Allowed Business Units</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefExcludeLists&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + ID
    + '">Exclude Lists</a><br>'
    +'<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefCategories&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + ID
    + '">Risk Categories</a>'  AS LINKS
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SRCHDEF_METADATA AS
	SELECT ID,
	NAME,
	DESCRIPTION,
	DISPLAY_ORDER,
	TUNING_ID,
	CF_PERSON_HIT_THRESHOLD,
	CF_ORG_HIT_THRESHOLD,
	CF_COUNTRY_HIT_THRESHOLD,
	MS_PERSON_HIT_THRESHOLD,
	MS_ORG_HIT_THRESHOLD,
	MS_COUNTRY_HIT_THRESHOLD,
	MS_PERSON_TUN_HIT_THRESHOLD,
   	MS_ORG_TUN_HIT_THRESHOLD,
	MS_COUNTRY_TUN_HIT_THRESHOLD,
	MS_HOLD_THRESHOLD,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigs&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || ID
    || '">Search Configs</a><br>' 
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefBusinessUnits&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || ID
    || '">Allowed Business Units</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefExcludeLists&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || ID
    || '">Exclude Lists</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefCategories&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || ID
    || '">Risk Categories</a>' AS LINKS
]
  FROM 
  	WLF_SRCHDEF_METADATA
  @go@
	
	/* ---------------------------------------------------------------------------- */
	/* SEARCH DEFINITION CONFIGS								*/
	/* ---------------------------------------------------------------------------- */

[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SRCHDEF_CONFIGS')
		drop view @env:lm_schema_name@.V_WLF_SRCHDEF_CONFIGS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SRCHDEF_CONFIGS AS
	SELECT SRCHDEF_ID,
    SRCHCFG_ID,
    INCL_DECEASED,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigFilter&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + SRCHDEF_ID
    + '&'
    + 'configId='
    + SRCHCFG_ID
    +'">Filters</a>' AS FILTERS_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SRCHDEF_CONFIGS AS
	SELECT SRCHDEF_ID,
    SRCHCFG_ID,
    INCL_DECEASED,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigFilter&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || SRCHDEF_ID
    || '&'
    || 'configId='
    || SRCHCFG_ID
    ||'">Filters</a>' AS FILTERS_LINK
]		
  FROM
	 WLF_SRCHDEF_CONFIGS
  @go@

	/* ---------------------------------------------------------------------------- */
	/* SEARCH DEFINITION CONFIG FILTERS								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SD_CONF_FILTER')
		drop view @env:lm_schema_name@.V_WLF_SD_CONF_FILTER
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SD_CONF_FILTER AS
	SELECT SRCHDEF_ID,
    SRCHCFG_ID,
    FILTER_TYPE,
    FILTER_IMPACT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigFiltVal&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'srchDefId='
    + SRCHDEF_ID
    + '&'
    + 'configId='
    + SRCHCFG_ID
    +'&'
    + 'filterType='
    + FILTER_TYPE
    +'">Filter Values</a>' AS FILTER_VAL_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SD_CONF_FILTER AS
	SELECT SRCHDEF_ID,
    SRCHCFG_ID,
    FILTER_TYPE,
    FILTER_IMPACT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchDefConfigFiltVal&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'srchDefId='
    || SRCHDEF_ID
    || '&'
    || 'configId='
    || SRCHCFG_ID
    ||'&'
    || 'filterType='
    || FILTER_TYPE
    ||'">Filter Values</a>' AS FILTER_VAL_LINK
]
  FROM
  	 WLF_SD_CONF_FILTER
  @go@

	/* ---------------------------------------------------------------------------- */
	/* SEARCH CONFIG METADATA								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SRCHCONF_METADATA')
		drop view @env:lm_schema_name@.V_WLF_SRCHCONF_METADATA
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SRCHCONF_METADATA AS
	SELECT ID,
	NAME,
    PERSON_MATCH_ALG,
    ORG_MATCH_ALG,
    PERSON_SEGMENT_CNT,
    ORG_SEGMENT_CNT,
    COUNTRY_SEGMENT_CNT,
    PERSON_ED_SC_FILTER_TYPE,
    ORG_ED_SC_FILTER_TYPE,
    PERSON_ED_SC_MAXVALUE,
    ORG_ED_SC_MAXVALUE,
    PERSON_ED_SC_FANOUT,
    ORG_ED_SC_FANOUT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfigLists&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'configId='
    + ID
    + '">Lists</a>' AS LISTS_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SRCHCONF_METADATA AS
	SELECT ID,
	NAME,
    PERSON_MATCH_ALG,
    ORG_MATCH_ALG,
    PERSON_SEGMENT_CNT,
    ORG_SEGMENT_CNT,
    COUNTRY_SEGMENT_CNT,
    PERSON_ED_SC_FILTER_TYPE,
    ORG_ED_SC_FILTER_TYPE,
    PERSON_ED_SC_MAXVALUE,
    ORG_ED_SC_MAXVALUE,
    PERSON_ED_SC_FANOUT,
    ORG_ED_SC_FANOUT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfigLists&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'configId='
    || ID
    || '">Lists</a>' AS LISTS_LINK
]
  FROM 
  	WLF_SRCHCONF_METADATA
  @go@

	/* ---------------------------------------------------------------------------- */
	/* SEARCH CONFIG LISTS								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SRCHCONF_LISTS')
		drop view @env:lm_schema_name@.V_WLF_SRCHCONF_LISTS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SRCHCONF_LISTS AS
	SELECT SRCHCFG_ID,
    LIST_ID,
    INCL_DECEASED,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfListFilter&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'configId='
    + SRCHCFG_ID
    + '&'
    + 'listId='
    + LIST_ID
    +'">Filters</a>' AS FILTERS_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SRCHCONF_LISTS AS
	SELECT SRCHCFG_ID,
    LIST_ID,
    INCL_DECEASED,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfListFilter&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'configId='
    || SRCHCFG_ID
    || '&'
    || 'listId='
    || LIST_ID
    ||'">Filters</a>' AS FILTERS_LINK
]		   	 
  FROM
  	 WLF_SRCHCONF_LISTS
  @go@

	/* ---------------------------------------------------------------------------- */
	/* SEARCH CONFIG LIST FILTERS								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_SC_LIST_FILTER')
		drop view @env:lm_schema_name@.V_WLF_SC_LIST_FILTER
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_SC_LIST_FILTER AS
	SELECT SRCHCFG_ID,
    LIST_ID,
    FILTER_TYPE,
    FILTER_IMPACT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfListFiltVal&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'configId='
    + SRCHCFG_ID
    + '&'
    + 'listId='
    + LIST_ID
    +'&'
    + 'filterType='
    + FILTER_TYPE
    +'">Filter Values</a>' AS FILTER_VAL_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_SC_LIST_FILTER AS
	SELECT SRCHCFG_ID,
    LIST_ID,
    FILTER_TYPE,
    FILTER_IMPACT,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_searchConfListFiltVal&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'configId='
    || SRCHCFG_ID
    || '&'
    || 'listId='
    || LIST_ID
    ||'&'
    || 'filterType='
    || FILTER_TYPE
    ||'">Filter Values</a>' AS FILTER_VAL_LINK
]	    
  FROM
  	 WLF_SC_LIST_FILTER
  @go@

	/* ---------------------------------------------------------------------------- */
	/* EXCLUDE LIST								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_EXCLUDE_LIST')
		drop view @env:lm_schema_name@.V_WLF_EXCLUDE_LIST
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_EXCLUDE_LIST AS
	SELECT LIST_ID,
  LIST_NAME,
  LIST_DESCRIPTION,
  '<a href="display.settings.act.go?thresholdId=AML_WLF_excludeEntries&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'listId='
    + LIST_ID
    + '">Entity Exclude Entries</a>'  AS ENTITY_ENTRIES_LINK,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_excludeHitEntries&'
	+ 'task=runSQL&'
    + 'parseParams=true&'
    + 'listId='
    + LIST_ID
    + '">Hit Exclude Entries</a>'  AS HIT_ENTRIES_LINK
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_EXCLUDE_LIST AS
	SELECT LIST_ID,
  LIST_NAME,
  LIST_DESCRIPTION,
  '<a href="display.settings.act.go?thresholdId=AML_WLF_excludeEntries&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'listId='
    || LIST_ID
    || '">Entity Exclude Entries</a>'  AS ENTITY_ENTRIES_LINK,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_excludeHitEntries&'
	|| 'task=runSQL&'
    || 'parseParams=true&'
    || 'listId='
    || LIST_ID
    || '">Hit Exclude Entries</a>'  AS HIT_ENTRIES_LINK
]
  FROM
  	 WLF_EXCLUDE_LIST
  @go@

	/* ---------------------------------------------------------------------------- */
	/* TUNING METADATA								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_TUNING_METADATA')
		drop view @env:lm_schema_name@.V_WLF_TUNING_METADATA
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_TUNING_METADATA AS
	SELECT TUNING_ID,
    TUNING_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCFScoreFactors&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Customer Filtering Score Factors</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningMSScoreFactors&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Message Screening Score Factors</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCustomScoreFactors&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Custom Score Factors</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCFNameTransformations&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Customer Filtering Name Transformations</a><br>'    
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_CF_tuningHitScoreNormalization&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Customer Filtering Score Normalization Values</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_MS_tuningHitScoreNormalization&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Message Screening Score Normalization Values</a><br>'
    + '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningImpacts&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '">Score Factor Impacts</a>' AS LINKS,
    CF_SCORE_NORMALIZATION_ACTIVE,
    MS_SCORE_NORMALIZATION_ACTIVE,
    CF_NAME_MATCH_THRESHOLD,
    CF_ID_MATCH_THRESHOLD,
    MS_NAME_MATCH_THRESHOLD,
    MS_ID_MATCH_THRESHOLD,
	INCLUDE_LOW_QUALITY_ALIASES
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_TUNING_METADATA AS
	SELECT TUNING_ID,
    TUNING_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCFScoreFactors&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Customer Filtering Score Factors</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningMSScoreFactors&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Message Screening Score Factors</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCustomScoreFactors&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Custom Score Factors</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningCFNameTransformations&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Customer Filtering Name Transformations</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_CF_tuningHitScoreNormalization&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Customer Filtering Score Normalization Values</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_MS_tuningHitScoreNormalization&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Message Screening Score Normalization Values</a><br>'
    || '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningImpacts&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '">Score Factor Impacts</a>' AS LINKS,
    CF_SCORE_NORMALIZATION_ACTIVE,
    MS_SCORE_NORMALIZATION_ACTIVE,
    CF_NAME_MATCH_THRESHOLD,
    CF_ID_MATCH_THRESHOLD,
    MS_NAME_MATCH_THRESHOLD,
    MS_ID_MATCH_THRESHOLD,
	INCLUDE_LOW_QUALITY_ALIASES
]
  FROM 
  	WLF_TUNING_METADATA
  @go@

	/* ---------------------------------------------------------------------------- */
	/* TUNING SCORE FACTORS								*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_TUNING_SCORE_FACTORS')
		drop view @env:lm_schema_name@.V_WLF_TUNING_SCORE_FACTORS
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_TUNING_SCORE_FACTORS AS
	SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
 	SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFFixedValuesUpdate&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '&'
    + 'scoreFactorId='
    + SCORE_FACTOR_ID
    + '&'
    + 'sfUsage='
    + SF_USAGE
    + '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM != 1 AND SF_TYPE='FIXED_VALUE'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFFixedValuesFull&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '&'
    + 'scoreFactorId='
    + SCORE_FACTOR_ID
    + '&'
    + 'sfUsage='
    + SF_USAGE
    + '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM = 1 AND SF_TYPE='FIXED_VALUE'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFRangeValues&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '&'
    + 'scoreFactorId='
    + SCORE_FACTOR_ID
    + '&'
    + 'sfUsage='
    + SF_USAGE
    + '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM != 1 AND SF_TYPE='RANGE_BASED'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFRangeValues&'
    + 'task=runSQL&'
    + 'parseParams=true&'
    + 'tuningId='
    + TUNING_ID
    + '&'
    + 'scoreFactorId='
    + SCORE_FACTOR_ID
    + '&'
    + 'sfUsage='
    + SF_USAGE
    + '">Score Factor Values</a>'  AS VALUES_LINK
 	FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM = 1 AND SF_TYPE='RANGE_BASED'
]
[oracle
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_TUNING_SCORE_FACTORS AS
	SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
 	SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFFixedValuesUpdate&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '&'
    || 'scoreFactorId='
    || SCORE_FACTOR_ID
    || '&'
    || 'sfUsage='
    || SF_USAGE
    || '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM != 1 AND SF_TYPE='FIXED_VALUE'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFFixedValuesFull&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '&'
    || 'scoreFactorId='
    || SCORE_FACTOR_ID
    || '&'
    || 'sfUsage='
    || SF_USAGE
    || '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM = 1 AND SF_TYPE='FIXED_VALUE'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFRangeValues&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '&'
    || 'scoreFactorId='
    || SCORE_FACTOR_ID
    || '&'
    || 'sfUsage='
    || SF_USAGE
    || '">Score Factor Values</a>'  AS VALUES_LINK
  FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM != 1 AND SF_TYPE='RANGE_BASED'
  UNION
  SELECT TUNING_ID,
    SCORE_FACTOR_ID,
    SF_USAGE,
    SF_TYPE,
    IS_CUSTOM,
    IS_ACTIVE,
    SF_DESCRIPTION,
    SF_NAME,
    '<a href="display.settings.act.go?thresholdId=AML_WLF_tuningSFRangeValues&'
    || 'task=runSQL&'
    || 'parseParams=true&'
    || 'tuningId='
    || TUNING_ID
    || '&'
    || 'scoreFactorId='
    || SCORE_FACTOR_ID
    || '&'
    || 'sfUsage='
    || SF_USAGE
    || '">Score Factor Values</a>'  AS VALUES_LINK
 	FROM WLF_TUNING_SCORE_FACTORS
  WHERE IS_CUSTOM = 1 AND SF_TYPE='RANGE_BASED'
]		 	
  @go@ 	
 		   
	/* ---------------------------------------------------------------------------- */
	/* UDDT Views							*/
	/* ---------------------------------------------------------------------------- */
	
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_ONE_OR_ZERO')
		drop view @env:lm_schema_name@.V_WLF_UDDT_ONE_OR_ZERO
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_ONE_OR_ZERO AS
	SELECT 1 AS "VALUE", N'1' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 0 AS "VALUE", N'0' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_ONE_OR_ZERO AS
	SELECT 1 AS "VALUE", '1' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 0 AS "VALUE", '0' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]

[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_USAGE')
		drop view @env:lm_schema_name@.V_WLF_UDDT_USAGE
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_USAGE AS
	SELECT N'CF' AS "VALUE", N'Customer Filtering' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'MS' AS "VALUE", N'Message Screening' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_USAGE AS
	SELECT 'CF' AS "VALUE", 'Customer Filtering' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'MS' AS "VALUE", 'Message Screening' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
  
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_SRCH_ALG')
		drop view @env:lm_schema_name@.V_WLF_UDDT_SRCH_ALG
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_SRCH_ALG AS
	SELECT N'EXACT_AND_FUZZY_MATCH' AS "VALUE", N'Exact and Fuzzy Match' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'EXACT_MATCH_ONLY' AS "VALUE", N'Exact Match Only' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_SRCH_ALG AS
	SELECT 'EXACT_AND_FUZZY_MATCH' AS "VALUE", 'Exact and Fuzzy Match' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'EXACT_MATCH_ONLY' AS "VALUE", 'Exact Match Only' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
  
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_ED_SC_FILTER_TYPE')
		drop view @env:lm_schema_name@.V_WLF_UDDT_ED_SC_FILTER_TYPE
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_ED_SC_FILTER_TYPE AS
	SELECT N'LENGTH' AS "VALUE", N'Length' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'CHARSUM' AS "VALUE", N'Charsum' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_ED_SC_FILTER_TYPE AS
	SELECT 'LENGTH' AS "VALUE", 'Length' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'CHARSUM' AS "VALUE", 'Charsum' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
  
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_FILTER_IMPACT')
		drop view @env:lm_schema_name@.V_WLF_UDDT_FILTER_IMPACT
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_FILTER_IMPACT AS
	SELECT N'EXCLUDE' AS "VALUE", N'Exclude' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'INCLUDE' AS "VALUE", N'Include' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_FILTER_IMPACT AS
	SELECT 'EXCLUDE' AS "VALUE", 'Exclude' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'INCLUDE' AS "VALUE", 'Include' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
  
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_FILTER_TYPE')
		drop view @env:lm_schema_name@.V_WLF_UDDT_FILTER_TYPE
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_FILTER_TYPE AS
	SELECT N'keywords' AS "VALUE", N'Keywords' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'categories' AS "VALUE", N'Categories' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_FILTER_TYPE AS
	SELECT 'keywords' AS "VALUE", 'Keywords' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'categories' AS "VALUE", 'Categories' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
  
[mssql
	if exists (select * from sysobjects where name = 'V_WLF_UDDT_SF_TYPE')
		drop view @env:lm_schema_name@.V_WLF_UDDT_SF_TYPE
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_SF_TYPE AS
	SELECT N'FIXED_VALUE' AS "VALUE", N'Fixed Values' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT N'RANGE_BASED' AS "VALUE", N'Range Values' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[oracle	
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_SF_TYPE AS
	SELECT 'FIXED_VALUE' AS "VALUE", 'Fixed Values' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM APP_SEQUENCES 
	UNION 
	SELECT 'RANGE_BASED' AS "VALUE", 'Range Values' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM APP_SEQUENCES
	@go@
]
[mssql
    if exists (select * from sysobjects where name = 'V_WLF_UDDT_APP_FOR_NAME_TYPE')
        drop view @env:lm_schema_name@.V_WLF_UDDT_APP_FOR_NAME_TYPE
    @go@

    CREATE VIEW @env:lm_schema_name@.V_WLF_UDDT_APP_FOR_NAME_TYPE AS
    SELECT 'P' AS "VALUE", 'Person' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER"
    UNION
    SELECT 'O' AS "VALUE", 'Organization' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER"
    UNION
    SELECT 'B' AS "VALUE", 'Person and Organization' AS "DISPLAY_VALUE", 3 AS "SORT_ORDER"
    @go@
]
[oracle
    CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_UDDT_APP_FOR_NAME_TYPE AS
    SELECT 'P' AS "VALUE", 'Person' AS "DISPLAY_VALUE", 1 AS "SORT_ORDER" FROM DUAL
    UNION
    SELECT 'O' AS "VALUE", 'Organization' AS "DISPLAY_VALUE", 2 AS "SORT_ORDER" FROM DUAL
    UNION
    SELECT 'B' AS "VALUE", 'Person and Organization' AS "DISPLAY_VALUE", 3 AS "SORT_ORDER" FROM DUAL
    @go@
]
  
	
	/****************************/
	/*      Tableau Table addition  */
  
[mssql
	if exists (select * from sysobjects where name = 'V_ACTIVATION_STATUS')
		drop view @env:lm_schema_name@.V_ACTIVATION_STATUS
	@go@
	
	CREATE VIEW @env:lm_schema_name@.V_ACTIVATION_STATUS AS
]
[oracle 
	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_ACTIVATION_STATUS AS
]
	select
	ENTITY,
	ACTIVATION_STATUS
	from ACTIMIZE_COMMON_METADATA
	@go@

[mssql
    if exists (select * from sysobjects where name = 'V_WLF_PURGE_SETTINGS')
        drop view @env:lm_schema_name@.V_WLF_PURGE_SETTINGS
    @go@

    CREATE VIEW @env:lm_schema_name@.V_WLF_PURGE_SETTINGS AS
    SELECT
     1 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgePartyOnDemand&'
       + 'task=runSQL'
       + '">Purge Party On-Demand</a>'  AS SETTING_LINK
    UNION
    SELECT
     2 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgeMessageOnDemand&'
       + 'task=runSQL'
       + '">Purge Message On-Demand</a>'  AS SETTING_LINK
    UNION
    SELECT
     3 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgePartyByRetention&'
       + 'task=runSQL'
       + '">Purge Party By Retention Period</a>'  AS SETTING_LINK
    UNION
    SELECT
     4 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgeMessageByRetention&'
       + 'task=runSQL'
       + '">Purge Message By Retention Period</a>'  AS SETTING_LINK
    @go@
]
[oracle

    CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_PURGE_SETTINGS AS
    SELECT
     1 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgePartyOnDemand&'
       || 'task=runSQL'
       || '">Purge Party On-Demand</a>'  AS SETTING_LINK
    FROM DUAL
    UNION
    SELECT
     2 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgeMessageOnDemand&'
       || 'task=runSQL'
       || '">Purge Message On-Demand</a>'  AS SETTING_LINK
    FROM DUAL
    UNION
    SELECT
     3 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgePartyByRetention&'
       || 'task=runSQL'
       || '">Purge Party By Retention Period</a>'  AS SETTING_LINK
    FROM DUAL
    UNION
    SELECT
     4 AS SORT_ORDER,
     '<a href="display.settings.act.go?thresholdId=AML_WLF_purgeMessageByRetention&'
       || 'task=runSQL'
       || '">Purge Message By Retention Period</a>'  AS SETTING_LINK
    FROM DUAL;
    @go@
]
	

    	/********************************************************************************/
	/********************************************************************************/
	/*										*/
	/*				Stored Procedures				*/
	/*										*/
	/********************************************************************************/
	/********************************************************************************/


	/* ---------------------------------------------------------------------------- */
	/*  Refresh statistics for non analyzed big tables or small tables		*/
	/* ---------------------------------------------------------------------------- */
[oracle
	create or replace PROCEDURE @env:lm_schema_name@.WLF_INFRA_REFRESH_STAT
	AS
		--This procedure analyzes all tables and partitions that have never been analyzed before, or have less than 100000 rows.
		P_TABLE_NAME VARCHAR2(30); 
		P_PART_NAME VARCHAR2 (30); 
		EXEC_STR VARCHAR2 (1000); 
		P_PART_STATUS VARCHAR2(3); 
		P_ROW_NUM NUMBER; 
		CURSOR TBL_NAME IS 
			SELECT TABLE_NAME,PARTITIONED,NVL(NUM_ROWS,0) 
			FROM user_tables 
			WHERE TABLE_NAME NOT LIKE '%SYS_IOT_OVER%'; 
		CURSOR PART_NAM_CUR IS 
			SELECT PARTITION_NAME 
			FROM user_tab_partitions 
			WHERE TABLE_NAME = UPPER (P_TABLE_NAME) 
			AND (LAST_ANALYZED IS NULL OR NUM_ROWS < 100000); 
	BEGIN
		OPEN TBL_NAME; 
		LOOP 
			FETCH TBL_NAME INTO P_TABLE_NAME,P_PART_STATUS,P_ROW_NUM; 
			EXIT WHEN TBL_NAME%NOTFOUND; 
			IF P_PART_STATUS ='NO' AND P_ROW_NUM<10000 THEN 
				BEGIN
					EXEC_STR := 'ANALYZE TABLE ' || P_TABLE_NAME || ' ESTIMATE STATISTICS'; 
					EXECUTE IMMEDIATE (EXEC_STR); 
				END;
			END IF; 
			IF P_PART_STATUS='YES' THEN
				BEGIN
					OPEN PART_NAM_CUR; 
					LOOP 
						FETCH PART_NAM_CUR INTO P_PART_NAME; 
						EXIT WHEN PART_NAM_CUR%NOTFOUND; 
						EXEC_STR := 'ANALYZE TABLE ' || P_TABLE_NAME|| ' PARTITION(' || P_PART_NAME|| ') ESTIMATE STATISTICS'; 
						EXECUTE IMMEDIATE (EXEC_STR); 
					END LOOP; 
					CLOSE PART_NAM_CUR; 
				END;
			END IF; 
		END LOOP; 
		CLOSE TBL_NAME; 
		EXCEPTION
			WHEN OTHERS THEN 
				RAISE; 
	END; 
	@go@
]
[mssql
	if exists (select * from sysobjects where name = 'WLF_INFRA_REFRESH_STAT')
		drop procedure @env:lm_schema_name@.WLF_INFRA_REFRESH_STAT
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_INFRA_REFRESH_STAT WITH EXECUTE AS OWNER
	AS
	BEGIN
	SET NOCOUNT ON;
		EXEC sp_updatestats
	END
	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  Create new partition for each table						*/
	/* ---------------------------------------------------------------------------- */
[oracle	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_CREATE_PARTITION ( P_LIST_VER_IDENTIFIER NUMBER )
		AS
		
		CURSOR	PARTITIONED_TABLES_SET IS
		SELECT	DISTINCT TABLE_NAME
		FROM	USER_TAB_PARTITIONS WHERE TABLE_NAME LIKE 'WLF%' AND TABLE_NAME NOT IN ( 'WLF_LATEST_LIST_ENTRIES', 'WLF_MESSAGE_SEARCH_LOG', 'WLF_SRCH_LOG')  AND TABLE_NAME NOT LIKE 'WLF_RL_%'
		ORDER BY TABLE_NAME;
	
		PARTITIONED_TABLE	PARTITIONED_TABLES_SET%ROWTYPE;
		
		P_TABLE_NAME		VARCHAR2(30);
		P_PART_NAME		VARCHAR2(30);
		P_COUNTER		NUMBER;
		EXEC_STR		VARCHAR2(1000);
		
		BEGIN
		    
			/* Generated the partition name */
			P_PART_NAME := 'P' || to_char(P_LIST_VER_IDENTIFIER);
			
			
			OPEN PARTITIONED_TABLES_SET;
			
			LOOP
			
				FETCH PARTITIONED_TABLES_SET INTO PARTITIONED_TABLE;
				EXIT WHEN PARTITIONED_TABLES_SET%NOTFOUND;
				
				P_TABLE_NAME := PARTITIONED_TABLE.TABLE_NAME;
				--DBMS_OUTPUT.put_line ('Table Name: ' || to_char(P_TABLE_NAME));
						
				SELECT	count(*)
				INTO	P_COUNTER 
				FROM	USER_TAB_PARTITIONS 
				WHERE	TABLE_NAME = P_TABLE_NAME and PARTITION_NAME = P_PART_NAME;
				
				--DBMS_OUTPUT.put_line ('Counter: ' || to_char(P_COUNTER));
											
				IF P_COUNTER = 0 THEN
					BEGIN
						EXEC_STR := 'alter table ' || P_TABLE_NAME || ' add partition ' || 
							P_PART_NAME || ' values (' || to_char(P_LIST_VER_IDENTIFIER) || ')' ;
	
						--DBMS_OUTPUT.put_line (EXEC_STR);
						EXECUTE IMMEDIATE (EXEC_STR);
					END;			
				END IF;
			
			END LOOP;
			
			CLOSE PARTITIONED_TABLES_SET;		
		
		
			EXCEPTION
				WHEN OTHERS THEN
					RAISE;		
	END;
	@go@
	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_CREATE_PARTITION_LIST ( P_LIST_ID_PART NUMBER )
		AS
		
		CURSOR	PARTITIONED_TABLES_SET IS
		SELECT	DISTINCT TABLE_NAME
		FROM	USER_TAB_PARTITIONS WHERE TABLE_NAME = 'WLF_LATEST_LIST_ENTRIES'
		ORDER BY TABLE_NAME;
	
		PARTITIONED_TABLE	PARTITIONED_TABLES_SET%ROWTYPE;
		
		P_TABLE_NAME		VARCHAR2(30);
		P_PART_NAME		VARCHAR2(30);
		P_COUNTER		NUMBER;
		EXEC_STR		VARCHAR2(1000);
		
		BEGIN
		    
			/* Generated the partition name */
			P_PART_NAME := 'P' || to_char(P_LIST_ID_PART);
			
			
			OPEN PARTITIONED_TABLES_SET;
			
			LOOP
			
				FETCH PARTITIONED_TABLES_SET INTO PARTITIONED_TABLE;
				EXIT WHEN PARTITIONED_TABLES_SET%NOTFOUND;
				
				P_TABLE_NAME := PARTITIONED_TABLE.TABLE_NAME;
				--DBMS_OUTPUT.put_line ('Table Name: ' || to_char(P_TABLE_NAME));
						
				SELECT	count(*)
				INTO	P_COUNTER 
				FROM	USER_TAB_PARTITIONS 
				WHERE	TABLE_NAME = P_TABLE_NAME and PARTITION_NAME = P_PART_NAME;
				
				--DBMS_OUTPUT.put_line ('Counter: ' || to_char(P_COUNTER));
											
				IF P_COUNTER = 0 THEN
					BEGIN
						EXEC_STR := 'alter table ' || P_TABLE_NAME || ' add partition ' || 
							P_PART_NAME || ' values (' || to_char(P_LIST_ID_PART) || ')' ;
	
						--DBMS_OUTPUT.put_line (EXEC_STR);
						EXECUTE IMMEDIATE (EXEC_STR);
					END;			
				END IF;
			
			END LOOP;
			
			CLOSE PARTITIONED_TABLES_SET;		
		
		
			EXCEPTION
				WHEN OTHERS THEN
					RAISE;		
	END;
	@go@
]
[mssql

	if exists (select * from sysobjects where name = 'WLF_LM_CREATE_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_LM_CREATE_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_LM_CREATE_PARTITION
	@P_LIST_VER_IDENTIFIER int
	AS 
	BEGIN
	
	      BEGIN TRY
	
	         DECLARE
	            @PARTITIONED_TABLE varchar(max), 
	            @P_TABLE_NAME varchar(30), 
	            @P_PART_NAME varchar(30), 
	            @P_COUNTER int,
	            @EXEC_STR varchar(1000)
	            

                  BEGIN
                  IF @P_LIST_VER_IDENTIFIER > 2
				     ALTER PARTITION SCHEME list_partscheme NEXT USED [PRIMARY];
                  IF @P_LIST_VER_IDENTIFIER > 1
                     BEGIN
                     SET @EXEC_STR = 
                        'alter partition function list_partfunc()
					SPLIT RANGE (' + cast(@P_LIST_VER_IDENTIFIER as varchar) + ');'
                     EXECUTE (@EXEC_STR)
                     END
                  END
	      END TRY
	
	      BEGIN CATCH
	         
	         SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;

			THROW
	
	      END CATCH
	
	   END	
	   @go@

	if exists (select * from sysobjects where name = 'WLF_LM_CREATE_PARTITION_LIST')
		drop procedure @env:lm_schema_name@.WLF_LM_CREATE_PARTITION_LIST
	@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_LM_CREATE_PARTITION_LIST
		@P_LIST_ID_PART int
		AS 
		BEGIN
		
		      BEGIN TRY
		
		         DECLARE
		            @EXEC_STR varchar(1000)
		            
                  BEGIN
                  IF @P_LIST_ID_PART > 2
			     ALTER PARTITION SCHEME latest_list_partscheme NEXT USED [PRIMARY];
                  IF @P_LIST_ID_PART > 1
                     BEGIN
                     SET @EXEC_STR = 
                        'alter partition function latest_list_partfunc()
				SPLIT RANGE (' + cast(@P_LIST_ID_PART as varchar) + ');'
                     EXECUTE (@EXEC_STR)
                     END
                  END
		      END TRY
		
		      BEGIN CATCH
		         
		         SELECT 
				 ERROR_NUMBER() AS ErrorNumber
				,ERROR_SEVERITY() AS ErrorSeverity
				,ERROR_STATE() AS ErrorState
				,ERROR_PROCEDURE() AS ErrorProcedure
				,ERROR_LINE() AS ErrorLine
				,ERROR_MESSAGE() AS ErrorMessage;
				THROW
		
		      END CATCH
		
		   END	
		
		@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  Archive list versions							*/
	/* ---------------------------------------------------------------------------- */
[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_INFRA_SWITCH_PARTITION ( P_TABLE_PART IN VARCHAR2,P_TABLE_NONPART IN VARCHAR2, PARTITION_NAME IN VARCHAR2)
		IS
		EXE_STR VARCHAR2(1000);
		ERR_CODE NUMBER;
		BEGIN
 			EXE_STR:='ALTER TABLE '||P_TABLE_PART||' EXCHANGE PARTITION ' || PARTITION_NAME || ' WITH TABLE '|| P_TABLE_NONPART|| ' INCLUDING INDEXES WITHOUT VALIDATION';
 			<<START_PROG>>
 			NULL;
 			BEGIN
  				EXECUTE IMMEDIATE EXE_STR;
  				ERR_CODE:=0;
  				EXCEPTION
   				WHEN OTHERS THEN
   				IF SQLCODE IN(-00054,-06512) THEN
     			BEGIN
      				ERR_CODE:=-00054;
     			END;
     			END IF;
   				IF SQLCODE IN(-02149) THEN
     			BEGIN
     			    /* ignore missing partition, uncomment next line if error should be raised in this case. */
					/*raise_application_error (-20001,SQLERRM||'- partition '||PARTITION_NAME||' for table '||P_TABLE_PART,true); */
		            ERR_CODE:=0;
     			END;
  				ELSE
    	 			RAISE;
    			END IF;
 			END;
 			IF ERR_CODE=-54 THEN
 				GOTO START_PROG;
 			END IF;
 			EXCEPTION
  			WHEN OTHERS THEN
  			RAISE;
		END;
		@go@
]

[mssql

	if exists (select * from sysobjects where name = 'WLF_LM_INFRA_SWITCH_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_LM_INFRA_SWITCH_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_LM_INFRA_SWITCH_PARTITION  
   		@P_TABLE_PART varchar(max),
   		@P_TABLE_NONPART varchar(max),
   		@PARTITION_NAME varchar(max)
	AS 
   
   BEGIN
      DECLARE
         @EXE_STR varchar(1000), 
         @ERR_CODE int
      BEGIN TRY
         SET @EXE_STR = 
            'ALTER TABLE ' +  ISNULL(@P_TABLE_PART, '') + 
            ' SWITCH PARTITION ' + ISNULL(@PARTITION_NAME, '') + 
            ' TO ' + ISNULL(@P_TABLE_NONPART, '')
            
			EXECUTE (@EXE_STR)
   
      END TRY
     
      BEGIN CATCH
		SELECT 
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;
		THROW
     
     END CATCH
     END
	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  Drop partition from each table						*/
	/* ---------------------------------------------------------------------------- */

[oracle		
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_DROP_PARTITION ( P_LIST_VER_IDENTIFIER NUMBER )
	AS
		TYPE CURSOR_TABLE IS
            		TABLE OF VARCHAR2(50);
            C1_CURSOR_TABLE CURSOR_TABLE;
            P_PART_NAME     VARCHAR2(30);
            V_SQL           VARCHAR2(1000);
            EXEC_STR        VARCHAR2(1000);
            FILTER1  VARCHAR2(30) := 'WLF%';
            FILTER2  VARCHAR2(30) := 'WLF_LATEST_LIST_ENTRIES';

            BEGIN
                P_PART_NAME := 'P' || TO_CHAR(P_LIST_VER_IDENTIFIER);
                --dbms_output.put_line('v_sql: ' || to_char(v_sql));
                V_SQL := 'SELECT TABLE_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME LIKE '  || '''' || FILTER1 || ''''
                             || ' AND TABLE_NAME != '
                             || '''' || FILTER2 || ''''
                             || '  AND PARTITION_NAME = '''
                             || P_PART_NAME
                             || '''';
                --dbms_output.put_line('v_sql: ' || to_char(v_sql));
                EXECUTE IMMEDIATE V_SQL
                BULK COLLECT
                INTO C1_CURSOR_TABLE;
                FOR i IN 1..C1_CURSOR_TABLE.COUNT LOOP
                    IF i IS NOT NULL THEN
                        EXEC_STR := 'ALTER TABLE "'
                                    || C1_CURSOR_TABLE(i)
                                    || '"'
                                    || ' DROP PARTITION '
                                    || P_PART_NAME;
                        EXECUTE IMMEDIATE ( EXEC_STR );
                    END IF;
                END LOOP;

            EXCEPTION
                WHEN OTHERS THEN
                    RAISE;
            END;
        	@go@
	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_DROP_PARTITION_LIST ( P_LIST_ID_PART NUMBER )
		AS
		
		CURSOR	PARTITIONED_TABLES_SET IS
		SELECT	DISTINCT TABLE_NAME
		FROM	USER_TAB_PARTITIONS WHERE TABLE_NAME = 'WLF_LATEST_LIST_ENTRIES'
		ORDER BY TABLE_NAME;
	
		PARTITIONED_TABLE	PARTITIONED_TABLES_SET%ROWTYPE;
		
		P_TABLE_NAME		VARCHAR2(30);
		P_PART_NAME		VARCHAR2(30);
		P_COUNTER		NUMBER;
		EXEC_STR		VARCHAR2(1000);
		
		BEGIN
		    
			/* Generated the partition name */
			P_PART_NAME := 'P' || to_char(P_LIST_ID_PART);
			
			
			OPEN PARTITIONED_TABLES_SET;
			
			LOOP
			
				FETCH PARTITIONED_TABLES_SET INTO PARTITIONED_TABLE;
				EXIT WHEN PARTITIONED_TABLES_SET%NOTFOUND;
				
				P_TABLE_NAME := PARTITIONED_TABLE.TABLE_NAME;
				--DBMS_OUTPUT.put_line ('Table Name: ' || to_char(P_TABLE_NAME));
						
				SELECT	count(*)
				INTO	P_COUNTER 
				FROM	USER_TAB_PARTITIONS
				WHERE	TABLE_NAME = P_TABLE_NAME and PARTITION_NAME = P_PART_NAME;
				
				--DBMS_OUTPUT.put_line ('Counter: ' || to_char(P_COUNTER));
											
				IF P_COUNTER = 1 THEN
					BEGIN
						EXEC_STR := 'alter table ' || P_TABLE_NAME || ' drop partition ' || P_PART_NAME;
	
						--DBMS_OUTPUT.put_line (EXEC_STR);
						EXECUTE IMMEDIATE (EXEC_STR);
					END;			
				END IF;
			
			END LOOP;
			
			CLOSE PARTITIONED_TABLES_SET;		
		
		
			EXCEPTION
				WHEN OTHERS THEN
					RAISE;		
	END;
	@go@
]	
[mssql
	
	if exists (select * from sysobjects where name = 'WLF_LM_DROP_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_LM_DROP_PARTITION
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_LM_DROP_PARTITION
		@P_LIST_VER_IDENTIFIER int
	AS	
	BEGIN
		  SET NOCOUNT ON;
	      BEGIN TRY
	
	         DECLARE
	            @TABLE_NAME varchar(max), 
	            @P_TABLE_NAME varchar(30), 
	            @P_COUNTER int, 
	            @EXEC_STR varchar(1000),
	            @LIVE_TABLE_NAME varchar(1000),
				@TMP_TABLE_NAME varchar(1000),
				@ARCHIVE_TABLE_NAME varchar(1000),
				@PARTITION int,
				@P_RANGE_COUNT int
				
	         /* Generated the partition name*/
	         
	         SELECT @PARTITION = $partition.list_partfunc(@P_LIST_VER_IDENTIFIER)
	
	         DECLARE
	             PARTITIONED_TABLES_SET CURSOR LOCAL FOR 
	               
	               SELECT WLF_ARCHIVE_TABLES_INFO.LIVE_TABLE_NAME, WLF_ARCHIVE_TABLES_INFO.TMP_TABLE_NAME, WLF_ARCHIVE_TABLES_INFO.ARCHIVE_TABLE_NAME
	               FROM WLF_ARCHIVE_TABLES_INFO
	               WHERE WLF_ARCHIVE_TABLES_INFO.LIVE_TABLE_NAME <> 'WLF_LIST_VERSIONS'
	               AND WLF_ARCHIVE_TABLES_INFO.LIVE_TABLE_NAME in 
	               (select distinct OBJECT_NAME(p.object_id)
						from sys.partitions p
						inner join sys.indexes i 
						on p.object_id = i.object_id
						and p.index_id = i.index_id
						inner JOIN sys.data_spaces ds 
						on i.data_space_id = ds.data_space_id
						inner JOIN sys.partition_schemes ps 
						on ds.data_space_id = ps.data_space_id
						WHERE p.partition_number = @PARTITION)
	
	            
	         OPEN PARTITIONED_TABLES_SET
	
	         FETCH NEXT FROM PARTITIONED_TABLES_SET
	                   INTO @LIVE_TABLE_NAME,@TMP_TABLE_NAME,@ARCHIVE_TABLE_NAME
	
	               WHILE @@FETCH_STATUS = 0
					BEGIN
	                
						EXECUTE WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @LIVE_TABLE_NAME, @P_TABLE_NONPART = @TMP_TABLE_NAME, @PARTITION_NAME = @PARTITION
		
						SET @EXEC_STR = 'TRUNCATE TABLE ' + @TMP_TABLE_NAME + ';'
	
						EXECUTE (@EXEC_STR)
	
						FETCH NEXT FROM PARTITIONED_TABLES_SET
						INTO @LIVE_TABLE_NAME,@TMP_TABLE_NAME,@ARCHIVE_TABLE_NAME
	                 END
	
	         CLOSE PARTITIONED_TABLES_SET
	
	         DEALLOCATE PARTITIONED_TABLES_SET
			
				select @P_RANGE_COUNT = count(*) from sys.partition_functions pf
							, sys.partition_range_values prv 
				where pf.function_id = prv.function_id 
				and prv.value = @P_LIST_VER_IDENTIFIER
				and pf.name = 'list_partfunc'; 
	  
				IF @P_RANGE_COUNT > 0 
					BEGIN   
					SET @P_RANGE_COUNT = 0       
							   /* Drop the version partition from the live table*/
					SET @EXEC_STR = 'ALTER PARTITION FUNCTION list_partfunc() MERGE RANGE (' + cast(@P_LIST_VER_IDENTIFIER as varchar) + ');'
				--  BEGIN TRY
						EXECUTE (@EXEC_STR)
				--  END TRY
				--  BEGIN CATCH
				--  IF @@TRANCOUNT > 0
				--  ROLLBACK TRANSACTION;
				-- END CATCH
		
				   END
			
	      END TRY
	
	      BEGIN CATCH
			SELECT 
	        ERROR_NUMBER() AS ErrorNumber
	        ,ERROR_SEVERITY() AS ErrorSeverity
	        ,ERROR_STATE() AS ErrorState
	        ,ERROR_PROCEDURE() AS ErrorProcedure
	        ,ERROR_LINE() AS ErrorLine
	        ,ERROR_MESSAGE() AS ErrorMessage;
			THROW
	     END CATCH
	END
	
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_LM_DROP_PARTITION_LIST')
		drop procedure @env:lm_schema_name@.WLF_LM_DROP_PARTITION_LIST
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_LM_DROP_PARTITION_LIST
		@P_LIST_ID_PART int
	AS	
	BEGIN
		  SET NOCOUNT ON;
	      BEGIN TRY
	
	         DECLARE
	            @EXEC_STR varchar(1000),
				@PARTITION int
				
	              
	         SELECT @PARTITION = $partition.latest_list_partfunc(@P_LIST_ID_PART)
	
	 		EXECUTE WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = 'WLF_LATEST_LIST_ENTRIES', @P_TABLE_NONPART = 'WLF_TMP_LATEST_LIST_ENTRIES', @PARTITION_NAME = @PARTITION
		
		
			SET @EXEC_STR = 'TRUNCATE TABLE ' + 'WLF_TMP_LATEST_LIST_ENTRIES' + ';'

			EXECUTE (@EXEC_STR)

			SET @EXEC_STR = 'ALTER PARTITION FUNCTION latest_list_partfunc() MERGE RANGE (' + cast(@P_LIST_ID_PART as varchar) + ');'
			EXECUTE (@EXEC_STR)
			
	      END TRY
	
	      BEGIN CATCH
			SELECT 
	        ERROR_NUMBER() AS ErrorNumber
	        ,ERROR_SEVERITY() AS ErrorSeverity
	        ,ERROR_STATE() AS ErrorState
	        ,ERROR_PROCEDURE() AS ErrorProcedure
	        ,ERROR_LINE() AS ErrorLine
	        ,ERROR_MESSAGE() AS ErrorMessage;
	
			THROW
	     END CATCH
	END
	
	
	@go@
]


[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_ARCHIVE
		AS
		
		/* Cursor - Versions to Archive */	
		CURSOR SET_ARCHIVE_VERSIONS IS
			select A.* 
			from WLF_LIST_VERSIONS A, WLF_LIST_DEFINITIONS B
			where A.LIST_ID = B.LIST_ID
				and A.VERSION < ( select max(VERSION) from WLF_LIST_VERSIONS C where A.LIST_ID = C.LIST_ID and C.LIST_TYPE = 'FULL' and C.IS_ACTIVATED = 1 )
				and A.IS_DELETED = 0
				and B.IS_DELETED = 0
			order by A.LIST_ID, A.VERSION;
		TUPLE_ARCHIVE_VERSIONS	SET_ARCHIVE_VERSIONS%ROWTYPE;
		
		/* Cursor - Tables Names */	
		CURSOR SET_ARCHIVE_TABLES IS
			select	* 
			from WLF_ARCHIVE_TABLES_INFO
			where LIVE_TABLE_NAME <> 'WLF_LIST_VERSIONS';	
		TUPLE_ARCHIVE_TABLES	SET_ARCHIVE_TABLES%ROWTYPE;
		
		P_VERSION_IDENTIFIER	VARCHAR2(50);
		P_VERSION_PART_NAME	VARCHAR2(50);
		P_COUNTER		NUMBER;
		P_STATUS		NUMBER;
		P_MONITOR_STATUS	NUMBER;
		EXEC_STR		VARCHAR2(1000);
		
		BEGIN
		
		OPEN SET_ARCHIVE_VERSIONS;
		
		LOOP
	
			/* Fetch next version to archive */
			FETCH SET_ARCHIVE_VERSIONS INTO TUPLE_ARCHIVE_VERSIONS;
			EXIT WHEN SET_ARCHIVE_VERSIONS%NOTFOUND;
			
			/* Define the partition name we should move */
			P_VERSION_PART_NAME := 'P' || to_char(TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER);		
			
			/*-------------------------------------------------------------------------------------------------*/
			/*--- Step 1											---*/
			/*--- Switch partition of specific version [per whole tables] from LIVE to TEMP tables		---*/
			/*-------------------------------------------------------------------------------------------------*/
			
			OPEN SET_ARCHIVE_TABLES;
			
			LOOP		
				/* Fetch a table to switch from */
				FETCH SET_ARCHIVE_TABLES INTO TUPLE_ARCHIVE_TABLES;
				EXIT WHEN SET_ARCHIVE_TABLES%NOTFOUND;
				
				/* Define the list version and table in the monitor table - only when it does not exist */
				insert into WLF_ARCHIVE_PROCESS_MONITOR 
				select	TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER, TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME, 0 
				from	dual
				where	NOT EXISTS (select * from WLF_ARCHIVE_PROCESS_MONITOR where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME);
				
				
				/* Check if this step already processed (support resumption) */
				select	STATUS
				into	P_MONITOR_STATUS
				from	WLF_ARCHIVE_PROCESS_MONITOR
				where	LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER
					and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
	
				/* Verify this step is the next step to run  */
				IF P_MONITOR_STATUS = 0 THEN
				BEGIN			
					/* Define status as 1 [meaning we finished step 1] - do it now since next action is not undoable */
					update WLF_ARCHIVE_PROCESS_MONITOR set STATUS = 1 where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
									
					/* Switch partition */
					WLF_LM_INFRA_SWITCH_PARTITION( 
						TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME, 
						TUPLE_ARCHIVE_TABLES.TMP_TABLE_NAME, 
						P_VERSION_PART_NAME 
					);
					
					COMMIT;			
				END;
				END IF;
				
			END LOOP;
			
			CLOSE SET_ARCHIVE_TABLES;			
	
			/*-------------------------------------------------------------------------------------------------*/
			/*--- Step 2 											---*/
			/*--- Drop partition from LIVE tables 								---*/
			/*-------------------------------------------------------------------------------------------------*/
	
			OPEN SET_ARCHIVE_TABLES;
					
			LOOP
				/* Fetch a table to switch from */
				FETCH SET_ARCHIVE_TABLES INTO TUPLE_ARCHIVE_TABLES;
				EXIT WHEN SET_ARCHIVE_TABLES%NOTFOUND;
	
				/* Check if this step already processed (support resumption) */
				select	STATUS
				into	P_MONITOR_STATUS
				from	WLF_ARCHIVE_PROCESS_MONITOR
				where	LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER
					and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
				
				/* Verify this step is the next step to run  */
				IF P_MONITOR_STATUS = 1 THEN
				BEGIN			
					/* Change status to 2 [meaning we finished step 2] - do it now since next action is not undoable */
					update WLF_ARCHIVE_PROCESS_MONITOR set STATUS = 2 where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
					
					BEGIN
						/* Drop the version partition from the live table */
						EXEC_STR := 'alter table ' || TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME || ' drop partition ' || P_VERSION_PART_NAME;
						--DBMS_OUTPUT.put_line (EXEC_STR);
						EXECUTE IMMEDIATE (EXEC_STR);
						
					EXCEPTION when others then
					   /*ignore missing partition, uncomment the next line if error should be raised in this case.*/
					   /*raise_application_error (-20001,SQLERRM||'-'||P_VERSION_PART_NAME||' for table '||TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME,true);  */ 
           			   EXEC_STR:='';
					END;
					
					COMMIT;			
				END;
				END IF;
	
			END LOOP;
					
			CLOSE SET_ARCHIVE_TABLES;
	
			/*-------------------------------------------------------------------------------------------------*/
			/*--- Step 3 											---*/
			/*--- Insert data from TEMP to ARCHIVE tables 							---*/
			/*-------------------------------------------------------------------------------------------------*/
	
			OPEN SET_ARCHIVE_TABLES;
							
			LOOP
				/* Fetch a table to switch from */
				FETCH SET_ARCHIVE_TABLES INTO TUPLE_ARCHIVE_TABLES;
				EXIT WHEN SET_ARCHIVE_TABLES%NOTFOUND;
	
				/* Check if this step already processed (support resumption) */
				select	STATUS
				into	P_MONITOR_STATUS
				from	WLF_ARCHIVE_PROCESS_MONITOR
				where	LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER
					and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
	
				/* Verify this step is the next step to run  */
				IF P_MONITOR_STATUS = 2 THEN
				BEGIN			
					/* Change status to 3 [meaning we finished step 3] - do it now since next action is not undoable */
					update WLF_ARCHIVE_PROCESS_MONITOR set STATUS = 3 where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
					
					/* Drop the version partition from the live table */
					EXEC_STR := 'insert into ' || TUPLE_ARCHIVE_TABLES.ARCHIVE_TABLE_NAME ||
							' select * from ' || TUPLE_ARCHIVE_TABLES.TMP_TABLE_NAME;
					--DBMS_OUTPUT.put_line (EXEC_STR);
					EXECUTE IMMEDIATE (EXEC_STR);
	
					COMMIT;			
				END;
				END IF;
	
			END LOOP;
				
			CLOSE SET_ARCHIVE_TABLES;

			/*-------------------------------------------------------------------------------------------------*/
			/*--- Step 4 											---*/
			/*--- Truncate TEMP tables							 		---*/
			/*-------------------------------------------------------------------------------------------------*/		
		
			OPEN SET_ARCHIVE_TABLES;
									
			LOOP
				/* Fetch a table to switch from */
				FETCH SET_ARCHIVE_TABLES INTO TUPLE_ARCHIVE_TABLES;
				EXIT WHEN SET_ARCHIVE_TABLES%NOTFOUND;
	
				/* Check if this step already processed (support resumption) */
				select	STATUS
				into	P_MONITOR_STATUS
				from	WLF_ARCHIVE_PROCESS_MONITOR
				where	LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER
					and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
	
				/* Verify this step is the next step to run  */
				IF P_MONITOR_STATUS = 3 THEN
				BEGIN			
					/* Change status to 4 [meaning we finished step 3] - do it now since next action is not undoable */
					update WLF_ARCHIVE_PROCESS_MONITOR set STATUS = 4 where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER and LIVE_TABLE_NAME = TUPLE_ARCHIVE_TABLES.LIVE_TABLE_NAME;
	
					/* Drop the version partition from the live table */
					EXEC_STR := 'truncate table ' || TUPLE_ARCHIVE_TABLES.TMP_TABLE_NAME;
					--DBMS_OUTPUT.put_line (EXEC_STR);
					EXECUTE IMMEDIATE (EXEC_STR);
	
					COMMIT;			
				END;
				END IF;
	
			END LOOP;
									
			CLOSE SET_ARCHIVE_TABLES;
			
			/*-------------------------------------------------------------------------------------------------*/
			/*--- Step 5 											---*/
			/*--- Archive the VERSIONS and VERSION_NOTES tables (non partitioned)			 		---*/
			/*-------------------------------------------------------------------------------------------------*/
			
			insert into WLF_ARC_LIST_VERSION_NOTES
			select * from WLF_LIST_VERSION_NOTES where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER;
			
			delete from WLF_LIST_VERSION_NOTES where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER;

			insert into WLF_ARC_LIST_VERSIONS
     		select LIST_VERSION_IDENTIFIER,LIST_ID,VERSION,ENTRY_MIN_UPDATE_DATE,ENTRY_MAX_UPDATE_DATE,LIST_TYPE,IS_ACTIVATED,IS_DELETED,STATUS,LIST_COUNT,UPDATED_DATE,UPDATED_BY,DRAFT_STATUS,DRAFT_OPENED_DATE,DRAFT_OPENED_BY,REVIEW_OPENED_DATE,REVIEW_OPENED_BY from WLF_LIST_VERSIONS where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER;
			
			delete from WLF_LIST_VERSIONS where LIST_VERSION_IDENTIFIER = TUPLE_ARCHIVE_VERSIONS.LIST_VERSION_IDENTIFIER;
			
			COMMIT;
	
		END LOOP;
	
		CLOSE SET_ARCHIVE_VERSIONS;		

		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
					/* replace the above line with the following line if application error should be raised on missing partition */
					/* raise_application_error (-20001, SQLERRM,true);  */
				END;
	END;
	@go@

]
[mssql

	if exists (select * from sysobjects where name = 'WLF_LM_ARCHIVE')
		drop procedure @env:lm_schema_name@.WLF_LM_ARCHIVE
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_LM_ARCHIVE  
	AS 
   
	  BEGIN
		SET NOCOUNT ON;
		 BEGIN TRY
			DECLARE
			   @LIST_VERSION_IDENTIFIER int, 
			   @LIST_ID varchar(50), 
			   @VERSION int, 
			   @ENTRY_MIN_UPDATE_DATE datetime, 
			   @ENTRY_MAX_UPDATE_DATE datetime, 
			   @LIST_TYPE varchar(50), 
			   @IS_ACTIVATED int, 
			   @IS_DELETED int, 
			   @STATUS int, 
			   @LIST_COUNT int, 
			   @UPDATED_DATE datetime, 
			   @UPDATED_BY varchar(255),
			   @DRAFT_STATUS varchar(25),
			   @DRAFT_OPENED_DATE datetime,
			   @DRAFT_OPENED_BY varchar(255),
			   @REVIEW_OPENED_DATE datetime,
			   @REVIEW_OPENED_BY varchar(255),
			   @LIVE_TABLE_NAME varchar(30), 
			   @TMP_TABLE_NAME varchar(30), 
			   @ARCHIVE_TABLE_NAME varchar(30), 
			   @P_VERSION_IDENTIFIER varchar(50), 
			   @P_VERSION_PART_NAME varchar(50), 
			   @P_COUNTER int, 
			   @P_STATUS int, 
			   @P_MONITOR_STATUS float(53), 
			   @EXEC_STR varchar(1000),
			   @PARTITION int,
			   @P_RANGE_COUNT int
			   
		   DECLARE
				 SET_ARCHIVE_TABLES CURSOR LOCAL FOR 
				 SELECT WLF_ARCHIVE_TABLES_INFO.LIVE_TABLE_NAME, WLF_ARCHIVE_TABLES_INFO.TMP_TABLE_NAME, WLF_ARCHIVE_TABLES_INFO.ARCHIVE_TABLE_NAME
				  FROM WLF_ARCHIVE_TABLES_INFO
				  WHERE WLF_ARCHIVE_TABLES_INFO.LIVE_TABLE_NAME <> 'WLF_LIST_VERSIONS'
			DECLARE
				SET_ARCHIVE_VERSIONS CURSOR LOCAL FOR 
				  SELECT 
					 A.LIST_VERSION_IDENTIFIER, 
					 A.LIST_ID, 
					 A.VERSION, 
					 A.ENTRY_MIN_UPDATE_DATE, 
					 A.ENTRY_MAX_UPDATE_DATE, 
					 A.LIST_TYPE, 
					 A.IS_ACTIVATED, 
					 A.IS_DELETED, 
					 A.STATUS, 
					 A.LIST_COUNT, 
					 A.UPDATED_DATE, 
					 A.UPDATED_BY,
					 A.DRAFT_STATUS,
					 A.DRAFT_OPENED_DATE,
					 A.DRAFT_OPENED_BY,
					 A.REVIEW_OPENED_DATE,
					 A.REVIEW_OPENED_BY
				  FROM WLF_LIST_VERSIONS  AS A, WLF_LIST_DEFINITIONS  AS B
				  WHERE 
					 A.LIST_ID = B.LIST_ID AND 
					 A.VERSION < 
					 (
						SELECT max(C.VERSION) AS expr
						FROM WLF_LIST_VERSIONS  AS C
						WHERE 
						   A.LIST_ID = C.LIST_ID AND 
						   C.LIST_TYPE = 'FULL' AND 
						   C.IS_ACTIVATED = 1
					 ) AND 
					 A.IS_DELETED = 0 AND 
					 B.IS_DELETED = 0 
				  ORDER BY A.LIST_ID, A.VERSION

			SET @P_RANGE_COUNT = 0  

			OPEN SET_ARCHIVE_VERSIONS
			FETCH NEXT FROM SET_ARCHIVE_VERSIONS
			INTO @LIST_VERSION_IDENTIFIER,@LIST_ID,@VERSION,@ENTRY_MIN_UPDATE_DATE,@ENTRY_MAX_UPDATE_DATE, 
			@LIST_TYPE, @IS_ACTIVATED,@IS_DELETED,@STATUS,@LIST_COUNT,@UPDATED_DATE,@UPDATED_BY,
			@DRAFT_STATUS,@DRAFT_OPENED_DATE,@DRAFT_OPENED_BY,@REVIEW_OPENED_DATE,@REVIEW_OPENED_BY
	 WHILE @@FETCH_STATUS = 0
	 BEGIN
				 /* Cursor - Tables Names*/
				  OPEN SET_ARCHIVE_TABLES
						  /* Fetch a table to switch from*/
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
				  INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
				  WHILE @@FETCH_STATUS = 0
				  BEGIN
						/* Define the list version and table in the monitor table - only when it does not exist*/
						INSERT WLF_ARCHIVE_PROCESS_MONITOR(LIST_VERSION_IDENTIFIER, LIVE_TABLE_NAME, STATUS)
						SELECT @LIST_VERSION_IDENTIFIER, @LIVE_TABLE_NAME, 0
						WHERE NOT EXISTS 
						(
						 SELECT WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER, WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME, WLF_ARCHIVE_PROCESS_MONITOR.STATUS
						 FROM WLF_ARCHIVE_PROCESS_MONITOR
						 WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
							  )
						/* Check if this step already processed (support resumption)*/
						SELECT @P_MONITOR_STATUS = WLF_ARCHIVE_PROCESS_MONITOR.STATUS
						FROM WLF_ARCHIVE_PROCESS_MONITOR
						WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
						/* Verify this step is the next step to run*/
						IF @P_MONITOR_STATUS = 0
						   BEGIN
							  /* Define status as 1 [meaning we finished step 1] - do it now since next action is not undoable*/
							  UPDATE WLF_ARCHIVE_PROCESS_MONITOR
								 SET 
									STATUS = 1
							  WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
							  /* Switch partition*/
							  SELECT @PARTITION = $partition.list_partfunc(@LIST_VERSION_IDENTIFIER)
							  EXECUTE WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @LIVE_TABLE_NAME, @P_TABLE_NONPART = @TMP_TABLE_NAME, @PARTITION_NAME = @PARTITION
							  IF @@TRANCOUNT > 0
								 COMMIT WORK 
						   END
					
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
		INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
		END       
			  CLOSE SET_ARCHIVE_TABLES
				  /* Cursor - Tables Names*/
				  
				  /*
				  *   -------------------------------------------------------------------------------------------------
				  *   --- Step 2          ---
				  *   --- Drop partition from LIVE tables       ---
				  *   -------------------------------------------------------------------------------------------------
				  */
			   OPEN SET_ARCHIVE_TABLES
			
					/* Fetch a table to switch from*/
			   FETCH NEXT FROM SET_ARCHIVE_TABLES
			   INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
				  
				 WHILE @@FETCH_STATUS = 0
				 BEGIN
									/* Check if this step already processed (support resumption)*/
									SELECT @P_MONITOR_STATUS = WLF_ARCHIVE_PROCESS_MONITOR.STATUS
									FROM WLF_ARCHIVE_PROCESS_MONITOR
									WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
									/* Verify this step is the next step to run*/
									IF @P_MONITOR_STATUS = 1
									   BEGIN
										  /* Change status to 2 [meaning we finished step 2] - do it now since next action is not undoable*/
										  UPDATE WLF_ARCHIVE_PROCESS_MONITOR
											 SET 
												STATUS = 2
										  WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
									   END
							   FETCH NEXT FROM SET_ARCHIVE_TABLES
				  INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
							END
							CLOSE SET_ARCHIVE_TABLES
	   
				  select @P_RANGE_COUNT = count(*) from sys.partition_functions pf
							  , sys.partition_range_values prv 
				  where pf.function_id = prv.function_id 
				  and prv.value = @LIST_VERSION_IDENTIFIER
				  and pf.name = 'list_partfunc'; 
	  
				  IF @P_RANGE_COUNT > 0 
					BEGIN   
					SET @P_RANGE_COUNT = 0       
							   /* Drop the version partition from the live table*/
					SET @EXEC_STR = 'ALTER PARTITION FUNCTION list_partfunc() MERGE RANGE (' + cast(@LIST_VERSION_IDENTIFIER as varchar) + ');'
				--  BEGIN TRY
						EXECUTE (@EXEC_STR)
				--  END TRY
				--  BEGIN CATCH
				--  IF @@TRANCOUNT > 0
				--  ROLLBACK TRANSACTION;
				-- END CATCH
		
				   END
		   
				 /*
				  *   -------------------------------------------------------------------------------------------------
				  *   --- Step 3          ---
				  *   --- Insert data from TEMP to ARCHIVE tables      ---
				  *   -------------------------------------------------------------------------------------------------
				  */
				  OPEN SET_ARCHIVE_TABLES
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
				  INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
						
				  WHILE @@FETCH_STATUS = 0
		BEGIN
						/* Check if this step already processed (support resumption)*/
						SELECT @P_MONITOR_STATUS = WLF_ARCHIVE_PROCESS_MONITOR.STATUS
						FROM WLF_ARCHIVE_PROCESS_MONITOR
						WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
						/* Verify this step is the next step to run*/
						IF @P_MONITOR_STATUS = 2
						   BEGIN
							  /* Change status to 3 [meaning we finished step 3] - do it now since next action is not undoable*/
							  UPDATE WLF_ARCHIVE_PROCESS_MONITOR
								 SET 
									STATUS = 3
							  WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
							  /* Drop the version partition from the live table*/
							  SET @EXEC_STR = 'insert into ' + ISNULL(@ARCHIVE_TABLE_NAME, '') + ' select * from ' + ISNULL(@TMP_TABLE_NAME, '')
							  EXECUTE (@EXEC_STR)
							  IF @@TRANCOUNT > 0
								 COMMIT WORK 
						   END
				 
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
		INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
					
				  END
				  CLOSE SET_ARCHIVE_TABLES
				  /*
				  *   -------------------------------------------------------------------------------------------------
				  *   --- Step 4          ---
				  *   --- Truncate TEMP tables        ---
				  *   -------------------------------------------------------------------------------------------------
				  */
				  OPEN SET_ARCHIVE_TABLES
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
				  INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME

				  WHILE @@FETCH_STATUS = 0
		BEGIN
						/* Check if this step already processed (support resumption)*/
						SELECT @P_MONITOR_STATUS = WLF_ARCHIVE_PROCESS_MONITOR.STATUS
						FROM WLF_ARCHIVE_PROCESS_MONITOR
						WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
						/* Verify this step is the next step to run*/
						IF @P_MONITOR_STATUS = 3
						   BEGIN
							  /* Change status to 4 [meaning we finished step 3] - do it now since next action is not undoable*/
							  UPDATE WLF_ARCHIVE_PROCESS_MONITOR
								 SET 
									STATUS = 4
							  WHERE WLF_ARCHIVE_PROCESS_MONITOR.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER AND WLF_ARCHIVE_PROCESS_MONITOR.LIVE_TABLE_NAME = @LIVE_TABLE_NAME
							  /* Drop the version partition from the live table*/
							  SET @EXEC_STR = 'truncate table ' + ISNULL(@TMP_TABLE_NAME, '')
							  EXECUTE (@EXEC_STR)
				
							  IF @@TRANCOUNT > 0
								 COMMIT WORK 
						   END
					 
				  FETCH NEXT FROM SET_ARCHIVE_TABLES
		INTO @LIVE_TABLE_NAME, @TMP_TABLE_NAME, @ARCHIVE_TABLE_NAME
				  END
				  CLOSE SET_ARCHIVE_TABLES
				
				  /*
				  *   -------------------------------------------------------------------------------------------------
				  *   --- Step 5          ---
				  *   --- Archive the VERSION and VERSION_NOTES tables (non partitioned)    ---
				  *   -------------------------------------------------------------------------------------------------
				  */
	   INSERT INTO WLF_ARC_LIST_VERSION_NOTES 
		(LIST_VERSION_IDENTIFIER, LIST_VERSION_NOTES_ID, NOTE_UPDATED_DATE, NOTE_UPDATED_BY, NOTE_TEXT)
		SELECT LIST_VERSION_IDENTIFIER, LIST_VERSION_NOTES_ID, NOTE_UPDATED_DATE, NOTE_UPDATED_BY,NOTE_TEXT 
		FROM WLF_LIST_VERSION_NOTES
		WHERE LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER
		  
	   DELETE WLF_LIST_VERSION_NOTES
	   WHERE LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER 
				  INSERT INTO WLF_ARC_LIST_VERSIONS(
					 LIST_VERSION_IDENTIFIER, 
					 LIST_ID, 
					 VERSION, 
					 ENTRY_MIN_UPDATE_DATE, 
					 ENTRY_MAX_UPDATE_DATE, 
					 LIST_TYPE, 
					 IS_ACTIVATED, 
					 IS_DELETED, 
					 STATUS, 
					 LIST_COUNT, 
					 UPDATED_DATE, 
					 UPDATED_BY,
					 DRAFT_STATUS,
					 DRAFT_OPENED_DATE,
					 DRAFT_OPENED_BY,
					 REVIEW_OPENED_DATE,
					 REVIEW_OPENED_BY)
					 VALUES
		 (
		 @LIST_VERSION_IDENTIFIER,@LIST_ID,@VERSION,@ENTRY_MIN_UPDATE_DATE,@ENTRY_MAX_UPDATE_DATE, 
						   @LIST_TYPE, @IS_ACTIVATED,@IS_DELETED,@STATUS,@LIST_COUNT,@UPDATED_DATE,@UPDATED_BY,
						   @DRAFT_STATUS,@DRAFT_OPENED_DATE,@DRAFT_OPENED_BY,@REVIEW_OPENED_DATE,@REVIEW_OPENED_BY
		 ) 
				 DELETE WLF_LIST_VERSIONS
				  WHERE WLF_LIST_VERSIONS.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER
				  
				 IF @@TRANCOUNT > 0
					 COMMIT WORK 
					  
	 FETCH NEXT FROM SET_ARCHIVE_VERSIONS
			INTO @LIST_VERSION_IDENTIFIER,@LIST_ID,@VERSION,@ENTRY_MIN_UPDATE_DATE,@ENTRY_MAX_UPDATE_DATE, 
			@LIST_TYPE, @IS_ACTIVATED,@IS_DELETED,@STATUS,@LIST_COUNT,@UPDATED_DATE,@UPDATED_BY,
			@DRAFT_STATUS,@DRAFT_OPENED_DATE,@DRAFT_OPENED_BY,@REVIEW_OPENED_DATE,@REVIEW_OPENED_BY
			
			END
		   CLOSE SET_ARCHIVE_VERSIONS
			DEALLOCATE SET_ARCHIVE_VERSIONS
		   DEALLOCATE SET_ARCHIVE_TABLES
		   RETURN 0;
		 END TRY
		 BEGIN CATCH
	  SELECT 
	  ERROR_NUMBER() AS ErrorNumber
	 ,ERROR_SEVERITY() AS ErrorSeverity
	 ,ERROR_STATE() AS ErrorState
	 ,ERROR_PROCEDURE() AS ErrorProcedure
	 ,ERROR_LINE() AS ErrorLine
	 ,ERROR_MESSAGE() AS ErrorMessage;
	 THROW
	 END CATCH
	  END

   @go@
   
]

	/* ---------------------------------------------------------------------------- */
	/*  Maintenance	- Delete 'deleted' lists/versions				*/
	/* ---------------------------------------------------------------------------- */

[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_MAINTENANCE
		AS
		
		/* Cursor - Versions to Delete */	
		CURSOR SET_DELETED_VERSIONS IS
			select A.LIST_VERSION_IDENTIFIER 
			from WLF_LIST_VERSIONS A
				Inner Join WLF_LIST_DEFINITIONS B ON A.LIST_ID = B.LIST_ID
			where A.IS_DELETED = 1 OR B.IS_DELETED = 1
			order by A.LIST_VERSION_IDENTIFIER;
		TUPLE_DELETED_VERSIONS SET_DELETED_VERSIONS%ROWTYPE;
		
		
		/* Cursor - Lists to Delete */	
		CURSOR SET_DELETED_LISTS IS
			select	LIST_ID
			from	WLF_LIST_DEFINITIONS
			where	IS_DELETED = 1;	
		TUPLE_DELETED_LISTS	SET_DELETED_LISTS%ROWTYPE;
		
		
		BEGIN
		
			OPEN SET_DELETED_VERSIONS;
			LOOP
	
				/* Fetch next version to delete */
				FETCH SET_DELETED_VERSIONS INTO TUPLE_DELETED_VERSIONS;
				EXIT WHEN SET_DELETED_VERSIONS%NOTFOUND;
	
				WLF_LM_DROP_PARTITION( TUPLE_DELETED_VERSIONS.LIST_VERSION_IDENTIFIER );
	
				Delete from WLF_LIST_VERSIONS where LIST_VERSION_IDENTIFIER = TUPLE_DELETED_VERSIONS.LIST_VERSION_IDENTIFIER;
	
				COMMIT;
	
			END LOOP;
			CLOSE SET_DELETED_VERSIONS;
	
	
			OPEN SET_DELETED_LISTS;
			LOOP
	
				/* Fetch next version to delete */
				FETCH SET_DELETED_LISTS INTO TUPLE_DELETED_LISTS;
				EXIT WHEN SET_DELETED_LISTS%NOTFOUND;
	
				Delete from WLF_LIST_DEFINITIONS where LIST_ID = TUPLE_DELETED_LISTS.LIST_ID;
	
				COMMIT;
	
			END LOOP;
			CLOSE SET_DELETED_LISTS;		
				
	
	
		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
				END;
	END;
	@go@
]

[mssql

	if exists (select * from sysobjects where name = 'WLF_LM_MAINTENANCE')
		drop procedure @env:lm_schema_name@.WLF_LM_MAINTENANCE
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_LM_MAINTENANCE  
	AS 
   
	BEGIN
      BEGIN TRY
         DECLARE
            @LIST_VERSION_IDENTIFIER int,
            @LIST_ID varchar(max)
         DECLARE
             SET_DELETED_VERSIONS CURSOR LOCAL FOR 
               SELECT A.LIST_VERSION_IDENTIFIER
               FROM 
				WLF_LIST_VERSIONS  AS A 
                     INNER JOIN WLF_LIST_DEFINITIONS  AS B 
                     ON A.LIST_ID = B.LIST_ID
               WHERE A.IS_DELETED = 1 OR B.IS_DELETED = 1
               ORDER BY A.LIST_VERSION_IDENTIFIER
         OPEN SET_DELETED_VERSIONS
         FETCH NEXT FROM SET_DELETED_VERSIONS
         INTO @LIST_VERSION_IDENTIFIER
         WHILE @@FETCH_STATUS = 0
         BEGIN
                
               EXECUTE WLF_LM_DROP_PARTITION @P_LIST_VER_IDENTIFIER = @LIST_VERSION_IDENTIFIER
               
               DELETE WLF_LIST_VERSIONS
               WHERE WLF_LIST_VERSIONS.LIST_VERSION_IDENTIFIER = @LIST_VERSION_IDENTIFIER
               
               IF @@TRANCOUNT > 0
                  COMMIT WORK
 
		 FETCH NEXT FROM SET_DELETED_VERSIONS
         INTO @LIST_VERSION_IDENTIFIER
         
         END
	
         CLOSE SET_DELETED_VERSIONS
         DEALLOCATE SET_DELETED_VERSIONS
         /* Cursor - Lists to Delete*/
         DECLARE
             SET_DELETED_LISTS CURSOR LOCAL FOR 
               SELECT WLF_LIST_DEFINITIONS.LIST_ID
               FROM WLF_LIST_DEFINITIONS
               WHERE WLF_LIST_DEFINITIONS.IS_DELETED = 1
         OPEN SET_DELETED_LISTS
         FETCH NEXT FROM SET_DELETED_LISTS
         INTO @LIST_ID
         WHILE @@FETCH_STATUS = 0
		 BEGIN
               DELETE WLF_LIST_DEFINITIONS
               WHERE WLF_LIST_DEFINITIONS.LIST_ID = @LIST_ID

               IF @@TRANCOUNT > 0
                  COMMIT WORK
		 FETCH NEXT FROM SET_DELETED_LISTS
		 INTO @LIST_ID
         
         END
         CLOSE SET_DELETED_LISTS
         DEALLOCATE SET_DELETED_LISTS
      END TRY
    BEGIN CATCH
	
		SELECT 
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;

		THROW	
      END CATCH
	END
	
	@go@
   
]

	/* ---------------------------------------------------------------------------- */
	/*  Maintenance	- Delete old jobs data				*/
	/* ---------------------------------------------------------------------------- */

[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_JOBS_MAINTENANCE
	(NUMBER_OF_DAYS IN number)
		AS
		
		DELETE_BEFORE_DATE @datetime@ := SYSDATE - NUMBER_OF_DAYS;
		
		BEGIN
			DELETE from WLF_JOBS_LOG_DETAILS JLD 
			WHERE JLD.JOB_ID IN (SELECT JL.JOB_ID FROM WLF_JOBS_LOG JL WHERE JL.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
			
			DELETE from wlf_job_cf_details JCFD 
			WHERE JcfD.JOB_ID IN (SELECT JL.JOB_ID FROM WLF_JOBS_LOG JL WHERE JL.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
			
			DELETE from wlf_job_ms_details JMSD 
			WHERE JmsD.JOB_ID IN (SELECT JL.JOB_ID FROM WLF_JOBS_LOG JL WHERE JL.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
			
			DELETE from wlf_job_etl_details JED 
			WHERE JED.JOB_ID IN (SELECT JL.JOB_ID FROM WLF_JOBS_LOG JL WHERE JL.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
			
			DELETE from WLF_JOBS_LOG JL WHERE JL.JOB_TIMESTAMP < DELETE_BEFORE_DATE;
			
			DELETE from WLF_SELF_SERVICE_STAGING SSS
			where SSS.unique_id in (select SSJ.staging_uid from wlf_self_service_jobs SSJ WHERE SSJ.CREATION_DATE < DELETE_BEFORE_DATE);
			
			DELETE FROM WLF_SELF_SERVICE_JOBS SSJ WHERE SSJ.CREATION_DATE < DELETE_BEFORE_DATE;

			COMMIT;
	
		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
				END;
	END;
	@go@

]

[mssql

	if exists (select * from sysobjects where name = 'WLF_JOBS_MAINTENANCE')
		drop procedure @env:lm_schema_name@.WLF_JOBS_MAINTENANCE
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_JOBS_MAINTENANCE  
	@NUMBER_OF_DAYS int
	AS 
   
   BEGIN
	  SET NOCOUNT ON;
      DECLARE
         @DELETE_BEFORE_DATE datetime
      BEGIN TRY
         SET @DELETE_BEFORE_DATE = getdate() - @NUMBER_OF_DAYS
         
         DELETE WLF_JOBS_LOG_DETAILS
         FROM WLF_JOBS_LOG_DETAILS  AS JLD
         WHERE JLD.JOB_ID IN 
            (
               SELECT JL.JOB_ID
               FROM WLF_JOBS_LOG  AS JL
               WHERE JL.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
            )
            
         DELETE WLF_JOB_CF_DETAILS
         FROM WLF_JOB_CF_DETAILS  AS JCFD
         WHERE JCFD.JOB_ID IN 
            (
               SELECT JL.JOB_ID
               FROM WLF_JOBS_LOG  AS JL
               WHERE JL.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
            )
			
		 DELETE WLF_JOB_MS_DETAILS
         FROM WLF_JOB_MS_DETAILS  AS JMSD
         WHERE JMSD.JOB_ID IN 
            (
               SELECT JL.JOB_ID
               FROM WLF_JOBS_LOG  AS JL
               WHERE JL.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
            )
         
         DELETE WLF_JOB_ETL_DETAILS
         FROM WLF_JOB_ETL_DETAILS  AS JED
         WHERE JED.JOB_ID IN 
            (
               SELECT JL.JOB_ID
               FROM WLF_JOBS_LOG  AS JL
               WHERE JL.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
            )
         
         DELETE WLF_JOBS_LOG
         FROM WLF_JOBS_LOG  AS JL
         WHERE JL.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
         
         DELETE WLF_SELF_SERVICE_STAGING
         FROM WLF_SELF_SERVICE_STAGING  AS SSS
         WHERE SSS.UNIQUE_ID IN 
            (
               SELECT SSJ.STAGING_UID
               FROM WLF_SELF_SERVICE_JOBS  AS SSJ
               WHERE SSJ.CREATION_DATE < @DELETE_BEFORE_DATE
            )
         DELETE WLF_SELF_SERVICE_JOBS
         FROM WLF_SELF_SERVICE_JOBS  AS SSJ
         WHERE SSJ.CREATION_DATE < @DELETE_BEFORE_DATE
         
         IF @@TRANCOUNT > 0
            COMMIT
      END TRY
      BEGIN CATCH
 			 SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;

			THROW
      END CATCH
   END

	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  Maintenance	- Delete old list archives			*/
	/* ---------------------------------------------------------------------------- */

[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_DELETE_LIST_ARCHIVE_MAINT
	(NUMBER_OF_DAYS IN number)
		AS
		
		DELETE_BEFORE_DATE @datetime@ := SYSDATE - NUMBER_OF_DAYS;
		
		BEGIN
			DELETE from WLF_ARC_CATEGORIES_DATA T1 
			WHERE T1.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
			
			DELETE from WLF_ARC_KEYWORDS_DATA T2 
			WHERE T2.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_ADDINFO T3 
			WHERE T3.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_ADDRESSES T4 
			WHERE T4.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_ALIASES T5 
			WHERE T5.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_BIRTHDATES T6 
			WHERE T6.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_BIRTHPLACES T7 
			WHERE T7.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_CATEGORIES T8 
			WHERE T8.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_IDS T10 
			WHERE T10.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_KEYWORDS T11 
			WHERE T11.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_NATIONALITY_CTRY T12 
			WHERE T12.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_ENTRIES T9 
			WHERE T9.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_VERSION_NOTES T13 
			WHERE T13.LIST_VERSION_IDENTIFIER IN (SELECT LV.LIST_VERSION_IDENTIFIER FROM WLF_ARC_LIST_VERSIONS LV WHERE LV.UPDATED_DATE < DELETE_BEFORE_DATE);
	
			DELETE from WLF_ARC_LIST_VERSIONS T14 WHERE T14.UPDATED_DATE < DELETE_BEFORE_DATE;
	
			COMMIT;
	
		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
				END;
	END;
	@go@

]

[mssql

	if exists (select * from sysobjects where name = 'WLF_DELETE_LIST_ARCHIVE_MAINT')
		drop procedure @env:lm_schema_name@.WLF_DELETE_LIST_ARCHIVE_MAINT
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_DELETE_LIST_ARCHIVE_MAINT  
	@NUMBER_OF_DAYS int
	AS 
   
   BEGIN
	  SET NOCOUNT ON;
      DECLARE
         @DELETE_BEFORE_DATE datetime
      BEGIN TRY
         SET @DELETE_BEFORE_DATE = getdate() - @NUMBER_OF_DAYS
         
         DELETE WLF_ARC_CATEGORIES_DATA
         FROM WLF_ARC_CATEGORIES_DATA  AS T1
         WHERE T1.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
            
         DELETE WLF_ARC_KEYWORDS_DATA
         FROM WLF_ARC_KEYWORDS_DATA  AS T2
         WHERE T2.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_ADDINFO
         FROM WLF_ARC_LIST_ADDINFO  AS T3
         WHERE T3.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_ADDRESSES
         FROM WLF_ARC_LIST_ADDRESSES  AS T4
         WHERE T4.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_ALIASES
         FROM WLF_ARC_LIST_ALIASES  AS T5
         WHERE T5.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_BIRTHDATES
         FROM WLF_ARC_LIST_BIRTHDATES  AS T6
         WHERE T6.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_BIRTHPLACES
         FROM WLF_ARC_LIST_BIRTHPLACES  AS T7
         WHERE T7.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_CATEGORIES
         FROM WLF_ARC_LIST_CATEGORIES  AS T8
         WHERE T8.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_IDS
         FROM WLF_ARC_LIST_IDS  AS T10
         WHERE T10.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_KEYWORDS
         FROM WLF_ARC_LIST_KEYWORDS  AS T11
         WHERE T11.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_NATIONALITY_CTRY
         FROM WLF_ARC_LIST_NATIONALITY_CTRY  AS T12
         WHERE T12.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_ENTRIES
         FROM WLF_ARC_LIST_ENTRIES  AS T9
         WHERE T9.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_VERSION_NOTES
         FROM WLF_ARC_LIST_VERSION_NOTES  AS T13
         WHERE T13.LIST_VERSION_IDENTIFIER IN 
            (
               SELECT LV.LIST_VERSION_IDENTIFIER
               FROM WLF_ARC_LIST_VERSIONS  AS LV
               WHERE LV.UPDATED_DATE < @DELETE_BEFORE_DATE
            )
 	
         DELETE WLF_ARC_LIST_VERSIONS
         FROM WLF_ARC_LIST_VERSIONS  AS T14
         WHERE T14.UPDATED_DATE < @DELETE_BEFORE_DATE
         
         
         IF @@TRANCOUNT > 0
            COMMIT
      END TRY
      BEGIN CATCH
 			 SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			THROW
   END CATCH
   END

	@go@
]
	/* ---------------------------------------------------------------------------- */
	/*  Migrate list entries										*/
	/* ---------------------------------------------------------------------------- */
[oracle	
		create or replace
	PROCEDURE  @env:lm_schema_name@.WLF_MIGR_LATEST_LIST_ENTRIES  
		AS
	
		CURSOR	WLF_LIST_DEF_ROWS IS
		SELECT	LIST_ID FROM WLF_LIST_DEFINITIONS
	          WHERE latest_list_id_part IS NULL;
	
		LIST_ID_ROW	WLF_LIST_DEF_ROWS%ROWTYPE;
	
		P_LIST_ID		VARCHAR2(50);
		P_LIST_ID_PART		NUMBER;
	    P_ENTRY_COUNT NUMBER;
	
		BEGIN
	
			OPEN WLF_LIST_DEF_ROWS;
	
			LOOP
	
				FETCH WLF_LIST_DEF_ROWS INTO LIST_ID_ROW;
				EXIT WHEN WLF_LIST_DEF_ROWS%NOTFOUND;
	
				P_LIST_ID := LIST_ID_ROW.LIST_ID;
	      
	      --SELECT COUNT(*) INTO P_ENTRY_COUNT FROM V_LISTS_ENTRIES where LIST_ID = P_LIST_ID;
	      
	      SELECT COUNT(*) INTO P_ENTRY_COUNT FROM  WLF_LIST_VERSIONS AA 
                                             ,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  
                                                FROM  WLF_LIST_VERSIONS BB 
                                                WHERE  BB.LIST_TYPE    = 'FULL'
                                                   AND BB.LIST_ID = P_LIST_ID    
                                                   AND BB.IS_ACTIVATED = 1 
                                                GROUP BY LIST_ID  ) X
                                             ,WLF_LIST_ENTRIES D 
                                           WHERE  AA.LIST_ID = P_LIST_ID
                                              AND AA.LIST_ID = X.LIST_ID
                                              AND AA.VERSION >=  X.MAX_VERSION
                                              AND AA.IS_ACTIVATED = 1 
                                              AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
                                              AND D.LIST_ID = AA.LIST_ID
                                              AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED') 
                                              AND ROWNUM < 2;
	      
	      IF P_ENTRY_COUNT > 0 then
	      begin
	
	        /*--------- Transformed APP_SEQUENCES logic to DB Sequence -----------
	        SELECT	LATEST_VALUE
	        INTO	P_LIST_ID_PART
	        FROM	APP_SEQUENCES
	        WHERE	SEQUENCE_ID = 'list_id_part';
	  
	        P_LIST_ID_PART := P_LIST_ID_PART + 1;
	  
	        UPDATE APP_SEQUENCES
	        SET LATEST_VALUE = P_LIST_ID_PART
	        WHERE	SEQUENCE_ID = 'list_id_part';
	        
	        commit;
	        */

	        SELECT SEQ_LIST_ID_PART.NEXTVAL INTO P_LIST_ID_PART FROM DUAL;
	        
	        WLF_LM_CREATE_PARTITION_LIST(
	          P_LIST_ID_PART => P_LIST_ID_PART
	        );
	        
	        /*INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
	                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
	                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
	                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
	                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
	                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18)
	        SELECT P_LIST_ID_PART as LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
	                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
	                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
	                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
	                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
	                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18
	        FROM V_LISTS_ENTRIES
	        WHERE LIST_ID = P_LIST_ID;*/
	
		INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,
                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18)
       (SELECT P_LIST_ID_PART, B.LIST_ID, B.LIST_ENTRY_KEY , B.VERSION, B.LIST_VERSION_IDENTIFIER, B.ENTRY_UPDATE_DATE, B.ENTRY_CREATED_DATE, B.IS_DELETED, 
                B.ENTRY_TYPE, B.ENTRY_FIRST_NAME, B.ENTRY_MIDDLE_NAME, B.ENTRY_LAST_NAME, B.ENTRY_FULL_NAME, B.ENTRY_MAIDEN_NAME, B.IS_BROKEN, 
                B.CITIZENSHIP, B.DECEASED, B.DECEASED_DATE, B.GENDER, B.TITLE, B.POSITION, B.ALIAS_SET, B.ADDRESS_SET, B.ID_SET, B.NATIONALITY_COUNTRY_SET, B.DATE_OF_BIRTH_SET, 
                B.PLACE_OF_BIRTH_SET, B.KEYWORD_SET, B.CATEGORY_SET, B.ADD_INFO_SET, B.CUSTOM_FIELD_1, B.CUSTOM_FIELD_2, B.CUSTOM_FIELD_3, B.CUSTOM_FIELD_4, B.CUSTOM_FIELD_5, 
                B.CUSTOM_FIELD_6, B.CUSTOM_FIELD_7, B.CUSTOM_FIELD_8, B.CUSTOM_FIELD_9, B.CUSTOM_FIELD_10, B.CUSTOM_FIELD_11, B.CUSTOM_FIELD_12, B.CUSTOM_FIELD_13, B.CUSTOM_FIELD_14, 
                B.CUSTOM_FIELD_15, B.CUSTOM_FIELD_16, B.CUSTOM_FIELD_17, B.CUSTOM_FIELD_18 
		FROM  ( SELECT D.LIST_VERSION_IDENTIFIER,
                    D.LIST_ID, 
                    D.LIST_ENTRY_KEY, 
                    MAX (D.LIST_ENTRY_SORTER) OVER(PARTITION BY D.LIST_ID, D.LIST_ENTRY_KEY) AS MAX_ENTRY_SORTER        
                FROM  WLF_LIST_VERSIONS AA 
                      ,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  FROM  WLF_LIST_VERSIONS BB 
                                                                  WHERE BB.LIST_TYPE    = 'FULL' 
																    AND BB.LIST_ID = P_LIST_ID
                                                                    AND BB.IS_ACTIVATED = 1 
                         GROUP BY LIST_ID  ) X
                      ,WLF_LIST_ENTRIES D 
                WHERE  AA.LIST_ID = P_LIST_ID
                       AND AA.LIST_ID = X.LIST_ID
                       AND AA.VERSION >=  X.MAX_VERSION
                       AND AA.IS_ACTIVATED = 1 
                       AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
                       AND D.LIST_ID = AA.LIST_ID
	                   AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED') 
              ) A
             INNER JOIN 
                WLF_LIST_ENTRIES B  
                ON 
                A.LIST_ID              = B.LIST_ID 
                AND A.LIST_ENTRY_KEY   = B.LIST_ENTRY_KEY 
                AND A.MAX_ENTRY_SORTER = B.LIST_ENTRY_SORTER 
                AND A.LIST_VERSION_IDENTIFIER = B.LIST_VERSION_IDENTIFIER);
	
	        UPDATE WLF_LIST_DEFINITIONS
	        SET LATEST_LIST_ID_PART = P_LIST_ID_PART
	        WHERE	LIST_ID = P_LIST_ID;
	        
	        commit;
	
	      END;
	      END IF;
	
			END LOOP;
	
			CLOSE WLF_LIST_DEF_ROWS;
	
	
			EXCEPTION
				WHEN OTHERS THEN
					RAISE;
	END;
	@go@
]
[mssql
	if exists (select * from sysobjects where name = 'WLF_MIGR_LATEST_LIST_ENTRIES')
		drop procedure @env:lm_schema_name@.WLF_MIGR_LATEST_LIST_ENTRIES
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_MIGR_LATEST_LIST_ENTRIES
	AS 
	BEGIN
	
	      BEGIN TRY
	
	         DECLARE
			@P_LIST_ID		VARCHAR(50),
			@P_LIST_ID_PART		int,
		    @P_ENTRY_COUNT int 
	            
	        DECLARE
	             WLF_LIST_DEF_ROWS CURSOR LOCAL FOR 
	             SELECT	LIST_ID FROM WLF_LIST_DEFINITIONS
		          WHERE LATEST_LIST_ID_PART IS NULL
	         OPEN WLF_LIST_DEF_ROWS
	         FETCH NEXT FROM WLF_LIST_DEF_ROWS
	         INTO @P_LIST_ID
	         WHILE @@FETCH_STATUS = 0
	         BEGIN
	                
	 	      SELECT @P_ENTRY_COUNT = COUNT(*) FROM V_LISTS_ENTRIES where LIST_ID = @P_LIST_ID;
		      
		      IF @P_ENTRY_COUNT > 0 
		      begin

                /* --------- Transformed APP_SEQUENCES logic to DB Sequence -----------
		        SELECT	@P_LIST_ID_PART = LATEST_VALUE
		        FROM	APP_SEQUENCES
		        WHERE	SEQUENCE_ID = 'list_id_part';
		  
		        SELECT @P_LIST_ID_PART = @P_LIST_ID_PART + 1;
		  
		        UPDATE APP_SEQUENCES
		        SET LATEST_VALUE = @P_LIST_ID_PART
		        WHERE	SEQUENCE_ID = 'list_id_part';
		        */

		        SET @P_LIST_ID_PART = NEXT VALUE FOR SEQ_LIST_ID_PART;
		        
	            EXECUTE WLF_LM_CREATE_PARTITION_LIST @P_LIST_ID_PART = @P_LIST_ID_PART;
		        
		        INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
		                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
		                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
		                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
		                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
		                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18)
		        SELECT @P_LIST_ID_PART as LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
		                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
		                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
		                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
		                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
		                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18
		        FROM V_LISTS_ENTRIES
		        WHERE LIST_ID = @P_LIST_ID; 
		
		        UPDATE WLF_LIST_DEFINITIONS
		        SET LATEST_LIST_ID_PART = @P_LIST_ID_PART
		        WHERE	LIST_ID = @P_LIST_ID;
		        
		        END
	 
		 FETCH NEXT FROM WLF_LIST_DEF_ROWS
	         INTO @P_LIST_ID
	         
	         END
	
	         CLOSE WLF_LIST_DEF_ROWS
	         DEALLOCATE WLF_LIST_DEF_ROWS
	      END TRY
	
	      BEGIN CATCH
	         
	         SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			THROW
	
	      END CATCH
	
	   END	
	
	@go@
]
	/* ---------------------------------------------------------------------------- */
	/*  Upgrade list entries										*/
	/* ---------------------------------------------------------------------------- */
[oracle	
	  CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_UPDATE_LATEST_LIST_ENTRIES (P_LIST_ID VARCHAR2)
		AS
	
		P_LIST_ID_PART		NUMBER;
		P_OLD_LIST_ID_PART NUMBER;
		P_ENTRY_COUNT NUMBER;
	
		BEGIN
	
	      SELECT LATEST_LIST_ID_PART 
	      INTO P_OLD_LIST_ID_PART
	      FROM WLF_LIST_DEFINITIONS
	      WHERE LIST_ID = P_LIST_ID;
	      
	    --SELECT COUNT(*) INTO P_ENTRY_COUNT FROM V_LISTS_ENTRIES where LIST_ID = P_LIST_ID;

		SELECT COUNT(*) INTO P_ENTRY_COUNT FROM  WLF_LIST_VERSIONS AA 
                                             ,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  
                                                FROM  WLF_LIST_VERSIONS BB 
                                                WHERE  BB.LIST_TYPE    = 'FULL'
                                                   AND BB.LIST_ID = P_LIST_ID    
                                                   AND BB.IS_ACTIVATED = 1 
                                                GROUP BY LIST_ID  ) X
                                             ,WLF_LIST_ENTRIES D 
                                           WHERE  AA.LIST_ID = P_LIST_ID
                                              AND AA.LIST_ID = X.LIST_ID
                                              AND AA.VERSION >=  X.MAX_VERSION
                                              AND AA.IS_ACTIVATED = 1 
                                              AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
                                              AND D.LIST_ID = AA.LIST_ID
                                              AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED') 
                                              AND ROWNUM < 2;  
	      
	      IF P_ENTRY_COUNT > 0 then
	      begin
	
	        /* --------- Transformed APP_SEQUENCES logic to DB Sequence -----------
	        SELECT	LATEST_VALUE
	        INTO	P_LIST_ID_PART
	        FROM	APP_SEQUENCES
	        WHERE	SEQUENCE_ID = 'list_id_part';
	  
	        P_LIST_ID_PART := P_LIST_ID_PART + 1;
	  
	        UPDATE APP_SEQUENCES
	        SET LATEST_VALUE = P_LIST_ID_PART
	        WHERE	SEQUENCE_ID = 'list_id_part';
	        
	        commit;
	        */

	        SELECT SEQ_LIST_ID_PART.NEXTVAL INTO P_LIST_ID_PART FROM DUAL;

	        WLF_LM_CREATE_PARTITION_LIST(
	          P_LIST_ID_PART => P_LIST_ID_PART
	        );
			
			
			
		----------------------------------------------------------------
		---- UPDATE CRITICAL_UPDATE_DATE FROM PREVIOUS VERSION WHEN NULL
		----------------------------------------------------------------
	
			UPDATE WLF_LIST_ENTRIES A  SET A.CRITICAL_UPDATE_DATE =
  				(SELECT B.CRITICAL_UPDATE_DATE FROM WLF_LATEST_LIST_ENTRIES B WHERE B.LIST_ID = P_LIST_ID AND A.LIST_ID = B.LIST_ID
      			AND B.CRITICAL_UPDATE_DATE IS NOT NULL AND A.LIST_ENTRY_KEY = B.LIST_ENTRY_KEY AND B.IS_DELETED=0)
      			WHERE A.CRITICAL_UPDATE_DATE IS NULL AND
        		A.VERSION = (SELECT MAX (C.VERSION) from WLF_LIST_VERSIONS C where C.LIST_ID = P_LIST_ID AND C.LIST_ID = A.LIST_ID);
			
		
			UPDATE WLF_LIST_ENTRIES  SET CRITICAL_UPDATE_DATE = ENTRY_UPDATE_DATE
			WHERE CRITICAL_UPDATE_DATE IS NULL;
			
		-------	
	
	        
		/*       INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,
													ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
													CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
													PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
													CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
													CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18)
				SELECT P_LIST_ID_PART as LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,
													ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
													CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
													PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
													CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
													CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18
				FROM V_LISTS_ENTRIES
				WHERE LIST_ID = P_LIST_ID;
		*/

       INSERT /*+ append */ INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,
                                             ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
                                             CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
                                             PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
                                             CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
                                             CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18,AGE,AGE_AS_OF_DATE, UPDATE_CATEGORY, CRITICAL_UPDATE_DATE,IS_INACTIVE)
       (SELECT P_LIST_ID_PART, B.LIST_ID, B.LIST_ENTRY_KEY , B.VERSION, B.LIST_VERSION_IDENTIFIER, B.ENTRY_UPDATE_DATE, B.ENTRY_CREATED_DATE, B.IS_DELETED, 
                B.ENTRY_TYPE, B.ENTRY_FIRST_NAME, B.ENTRY_MIDDLE_NAME, B.ENTRY_LAST_NAME, B.ENTRY_FULL_NAME, B.ENTRY_MAIDEN_NAME, B.IS_BROKEN, 
                B.CITIZENSHIP, B.DECEASED, B.DECEASED_DATE, B.GENDER, B.TITLE, B.POSITION, B.ALIAS_SET, B.ADDRESS_SET, B.ID_SET, B.NATIONALITY_COUNTRY_SET, B.DATE_OF_BIRTH_SET, 
                B.PLACE_OF_BIRTH_SET, B.KEYWORD_SET, B.CATEGORY_SET, B.ADD_INFO_SET, B.CUSTOM_FIELD_1, B.CUSTOM_FIELD_2, B.CUSTOM_FIELD_3, B.CUSTOM_FIELD_4, B.CUSTOM_FIELD_5, 
                B.CUSTOM_FIELD_6, B.CUSTOM_FIELD_7, B.CUSTOM_FIELD_8, B.CUSTOM_FIELD_9, B.CUSTOM_FIELD_10, B.CUSTOM_FIELD_11, B.CUSTOM_FIELD_12, B.CUSTOM_FIELD_13, B.CUSTOM_FIELD_14, 
                B.CUSTOM_FIELD_15, B.CUSTOM_FIELD_16, B.CUSTOM_FIELD_17, B.CUSTOM_FIELD_18, B.AGE, B.AGE_AS_OF_DATE, B.UPDATE_CATEGORY, B.CRITICAL_UPDATE_DATE, B.IS_INACTIVE
		FROM  ( SELECT D.LIST_VERSION_IDENTIFIER,
                    D.LIST_ID, 
                    D.LIST_ENTRY_KEY, 
                    MAX (D.LIST_ENTRY_SORTER) OVER(PARTITION BY D.LIST_ID, D.LIST_ENTRY_KEY) AS MAX_ENTRY_SORTER        
                FROM  WLF_LIST_VERSIONS AA 
                      ,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  FROM  WLF_LIST_VERSIONS BB 
                                                                  WHERE BB.LIST_TYPE    = 'FULL' 
																    AND BB.LIST_ID = P_LIST_ID
                                                                    AND BB.IS_ACTIVATED = 1 
                         GROUP BY LIST_ID  ) X
                      ,WLF_LIST_ENTRIES D 
                WHERE  AA.LIST_ID = P_LIST_ID
                       AND AA.LIST_ID = X.LIST_ID
                       AND AA.VERSION >=  X.MAX_VERSION
                       AND AA.IS_ACTIVATED = 1 
                       AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
                       AND D.LIST_ID = AA.LIST_ID
	                   AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED') 
              ) A
             INNER JOIN 
                WLF_LIST_ENTRIES B  
                ON 
                A.LIST_ID              = B.LIST_ID 
                AND A.LIST_ENTRY_KEY   = B.LIST_ENTRY_KEY 
                AND A.MAX_ENTRY_SORTER = B.LIST_ENTRY_SORTER 
                AND A.LIST_VERSION_IDENTIFIER = B.LIST_VERSION_IDENTIFIER);
		----------------
	
	        UPDATE WLF_LIST_DEFINITIONS
	        SET LATEST_LIST_ID_PART = P_LIST_ID_PART
	        WHERE	LIST_ID = P_LIST_ID;
	        
	        commit;
	
	      END;
	      END IF;
	      
	      IF P_OLD_LIST_ID_PART IS NOT NULL THEN
	      BEGIN
	      WLF_LM_DROP_PARTITION_LIST(
	        P_LIST_ID_PART => P_OLD_LIST_ID_PART
	      );
	      END;
	      END IF;
	
	      IF P_ENTRY_COUNT = 0 THEN
	      BEGIN
	      UPDATE WLF_LIST_DEFINITIONS
	        SET LATEST_LIST_ID_PART = NULL
	        WHERE	LIST_ID = P_LIST_ID;
	      END;
	      END IF;
	      
	      commit;
	
    /* ----------------------------  Delete all old partitions for this list ----------------------- */
        FOR CUR IN (SELECT DISTINCT LIST_ID_PART FROM WLF_LATEST_LIST_ENTRIES
        WHERE LIST_ID = P_LIST_ID AND LIST_ID_PART <> P_LIST_ID_PART)
        LOOP
            IF CUR.LIST_ID_PART IS NOT NULL THEN
            WLF_LM_DROP_PARTITION_LIST(CUR.LIST_ID_PART);
            END IF;
        END LOOP;


			EXCEPTION
				WHEN OTHERS THEN
					BEGIN
                        ROLLBACK;
                    	RAISE;
                    END;
	END;
	@go@
]
[mssql
	if exists (select * from sysobjects where name = 'WLF_UPDATE_LATEST_LIST_ENTRIES')
		drop procedure @env:lm_schema_name@.WLF_UPDATE_LATEST_LIST_ENTRIES
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_UPDATE_LATEST_LIST_ENTRIES
	@P_LIST_ID VARCHAR(50) WITH EXECUTE AS OWNER
	AS 
	BEGIN
	    BEGIN TRANSACTION;
		EXEC WLF_INFRA_REFRESH_STAT;
	
		BEGIN TRY
	
			DECLARE
			@P_OLD_LIST_ID_PART int,
			@P_LIST_ID_PART		int,
			@P_ENTRY_COUNT int 
				
			SELECT @P_OLD_LIST_ID_PART = LATEST_LIST_ID_PART 
			FROM WLF_LIST_DEFINITIONS
			WHERE LIST_ID = @P_LIST_ID
	
	--        SELECT @P_ENTRY_COUNT = COUNT(*) FROM V_LISTS_ENTRIES where LIST_ID = @P_LIST_ID;
	
			SELECT @P_ENTRY_COUNT =  COUNT(*)  FROM  WLF_LIST_VERSIONS AA 
												,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  
													FROM  WLF_LIST_VERSIONS BB 
													WHERE  BB.LIST_TYPE    = 'FULL' 
													AND BB.IS_ACTIVATED = 1 
													AND BB.LIST_ID = @P_LIST_ID
													GROUP BY LIST_ID  ) X
												,WLF_LIST_ENTRIES D 
											WHERE  AA.LIST_ID = X.LIST_ID
												AND AA.VERSION >=  X.MAX_VERSION
												AND AA.IS_ACTIVATED = 1 
												AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
												AND D.LIST_ID = AA.LIST_ID
												AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED')    
	
			IF @P_ENTRY_COUNT > 0 
			begin
		
				/* --------- Transformed APP_SEQUENCES logic to DB Sequence -----------
				SELECT	@P_LIST_ID_PART = LATEST_VALUE
				FROM	APP_SEQUENCES
				WHERE	SEQUENCE_ID = 'list_id_part';
		
				SELECT @P_LIST_ID_PART = @P_LIST_ID_PART + 1;
		
				UPDATE APP_SEQUENCES
				SET LATEST_VALUE = @P_LIST_ID_PART
				WHERE	SEQUENCE_ID = 'list_id_part';
				*/
				
				SET @P_LIST_ID_PART = NEXT VALUE FOR SEQ_LIST_ID_PART;
				
				EXECUTE WLF_LM_CREATE_PARTITION_LIST @P_LIST_ID_PART = @P_LIST_ID_PART;
				
	----------------------------------------------------------------
	---- UPDATE CRITICAL_UPDATE_DATE FROM PREVIOUS VERSION WHEN NULL
	----------------------------------------------------------------
	
			UPDATE WLF_LIST_ENTRIES   SET WLF_LIST_ENTRIES.CRITICAL_UPDATE_DATE =
  				(SELECT B.CRITICAL_UPDATE_DATE FROM WLF_LATEST_LIST_ENTRIES B WHERE B.LIST_ID = @P_LIST_ID AND WLF_LIST_ENTRIES.LIST_ID = B.LIST_ID
      			AND B.CRITICAL_UPDATE_DATE IS NOT NULL AND WLF_LIST_ENTRIES.LIST_ENTRY_KEY = B.LIST_ENTRY_KEY AND B.IS_DELETED=0)
      			WHERE WLF_LIST_ENTRIES.CRITICAL_UPDATE_DATE IS NULL AND
        		WLF_LIST_ENTRIES.VERSION = (SELECT MAX (C.VERSION) from WLF_LIST_VERSIONS C where C.LIST_ID = @P_LIST_ID AND C.LIST_ID = WLF_LIST_ENTRIES.LIST_ID);
			
			
			
			UPDATE WLF_LIST_ENTRIES  SET CRITICAL_UPDATE_DATE = ENTRY_UPDATE_DATE
			WHERE CRITICAL_UPDATE_DATE IS NULL;
			
	-------		
			
	/*	        INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
													ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
													CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
													PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
													CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
													CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18)
				SELECT @P_LIST_ID_PART as LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,	
													ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
													CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
													PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
													CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
													CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18
				FROM V_LISTS_ENTRIES
				WHERE LIST_ID = @P_LIST_ID; 
	*/
	
	INSERT INTO WLF_LATEST_LIST_ENTRIES (LIST_ID_PART,LIST_ID,LIST_ENTRY_KEY,VERSION,LIST_VERSION_IDENTIFIER,ENTRY_UPDATE_DATE,ENTRY_CREATED_DATE,IS_DELETED,
												ENTRY_TYPE,ENTRY_FIRST_NAME,ENTRY_MIDDLE_NAME,ENTRY_LAST_NAME,ENTRY_FULL_NAME,ENTRY_MAIDEN_NAME,IS_BROKEN,
												CITIZENSHIP,DECEASED,DECEASED_DATE,GENDER,TITLE,POSITION,ALIAS_SET,ADDRESS_SET,ID_SET,NATIONALITY_COUNTRY_SET,DATE_OF_BIRTH_SET,
												PLACE_OF_BIRTH_SET,KEYWORD_SET,CATEGORY_SET,ADD_INFO_SET,CUSTOM_FIELD_1,CUSTOM_FIELD_2,CUSTOM_FIELD_3,CUSTOM_FIELD_4,CUSTOM_FIELD_5,
												CUSTOM_FIELD_6,CUSTOM_FIELD_7,CUSTOM_FIELD_8,CUSTOM_FIELD_9,CUSTOM_FIELD_10,CUSTOM_FIELD_11,CUSTOM_FIELD_12,CUSTOM_FIELD_13,CUSTOM_FIELD_14,
												CUSTOM_FIELD_15,CUSTOM_FIELD_16,CUSTOM_FIELD_17,CUSTOM_FIELD_18,AGE,AGE_AS_OF_DATE, UPDATE_CATEGORY, CRITICAL_UPDATE_DATE,IS_INACTIVE)
		(SELECT @P_LIST_ID_PART as LIST_ID_PART, B.LIST_ID, B.LIST_ENTRY_KEY , B.VERSION, B.LIST_VERSION_IDENTIFIER, B.ENTRY_UPDATE_DATE, B.ENTRY_CREATED_DATE, B.IS_DELETED, 
					B.ENTRY_TYPE, B.ENTRY_FIRST_NAME, B.ENTRY_MIDDLE_NAME, B.ENTRY_LAST_NAME, B.ENTRY_FULL_NAME, B.ENTRY_MAIDEN_NAME, B.IS_BROKEN, 
					B.CITIZENSHIP, B.DECEASED, B.DECEASED_DATE, B.GENDER, B.TITLE, B.POSITION, B.ALIAS_SET, B.ADDRESS_SET, B.ID_SET, B.NATIONALITY_COUNTRY_SET, B.DATE_OF_BIRTH_SET, 
					B.PLACE_OF_BIRTH_SET, B.KEYWORD_SET, B.CATEGORY_SET, B.ADD_INFO_SET, B.CUSTOM_FIELD_1, B.CUSTOM_FIELD_2, B.CUSTOM_FIELD_3, B.CUSTOM_FIELD_4, B.CUSTOM_FIELD_5, 
					B.CUSTOM_FIELD_6, B.CUSTOM_FIELD_7, B.CUSTOM_FIELD_8, B.CUSTOM_FIELD_9, B.CUSTOM_FIELD_10, B.CUSTOM_FIELD_11, B.CUSTOM_FIELD_12, B.CUSTOM_FIELD_13, B.CUSTOM_FIELD_14, 
					B.CUSTOM_FIELD_15, B.CUSTOM_FIELD_16, B.CUSTOM_FIELD_17, B.CUSTOM_FIELD_18, B.AGE, B.AGE_AS_OF_DATE, B.UPDATE_CATEGORY, B.CRITICAL_UPDATE_DATE, B.IS_INACTIVE
			FROM  ( SELECT D.LIST_VERSION_IDENTIFIER,
						D.LIST_ID, 
						D.LIST_ENTRY_KEY, 
						MAX (D.LIST_ENTRY_SORTER) OVER(PARTITION BY D.LIST_ID, D.LIST_ENTRY_KEY) AS MAX_ENTRY_SORTER        
					FROM  WLF_LIST_VERSIONS AA 
						,( SELECT MAX (VERSION) MAX_VERSION,LIST_ID  FROM  WLF_LIST_VERSIONS BB 
																	WHERE BB.LIST_TYPE    = 'FULL' 
																		AND BB.LIST_ID = @P_LIST_ID
																		AND BB.IS_ACTIVATED = 1 
							GROUP BY LIST_ID  ) X
						,WLF_LIST_ENTRIES D 
					WHERE  AA.LIST_ID = X.LIST_ID
						AND AA.VERSION >=  X.MAX_VERSION
						AND AA.IS_ACTIVATED = 1 
						AND D.LIST_VERSION_IDENTIFIER = AA.LIST_VERSION_IDENTIFIER
						AND D.LIST_ID = AA.LIST_ID
						AND (D.REVIEW_STATUS IS NULL  OR D.REVIEW_STATUS <> 'REJECTED') 
				) A
				INNER JOIN 
					WLF_LIST_ENTRIES B WITH (FORCESEEK)
					ON 
					A.LIST_ID              = B.LIST_ID 
					AND A.LIST_ENTRY_KEY   = B.LIST_ENTRY_KEY 
					AND A.MAX_ENTRY_SORTER = B.LIST_ENTRY_SORTER 
					AND A.LIST_VERSION_IDENTIFIER = B.LIST_VERSION_IDENTIFIER);
	
	-----------------
	
				UPDATE WLF_LIST_DEFINITIONS
				SET LATEST_LIST_ID_PART = @P_LIST_ID_PART
				WHERE	LIST_ID = @P_LIST_ID;
				
			END
	
			IF @P_OLD_LIST_ID_PART IS NOT NULL 
			BEGIN
				EXECUTE WLF_LM_DROP_PARTITION_LIST @P_LIST_ID_PART = @P_OLD_LIST_ID_PART
			END
	
			IF @P_ENTRY_COUNT = 0 
			BEGIN
				UPDATE WLF_LIST_DEFINITIONS
				SET LATEST_LIST_ID_PART = NULL
				WHERE	LIST_ID = @P_LIST_ID
			END
	
	        /* ----------------------------  Delete all old partitions for this list ----------------------- */
            DECLARE
            @P_PARTITION int

            DECLARE
            SET_ODD_PARTITIONS CURSOR LOCAL FOR
            SELECT DISTINCT LIST_ID_PART FROM WLF_LATEST_LIST_ENTRIES
            WHERE LIST_ID = @P_LIST_ID AND LIST_ID_PART <> @P_LIST_ID_PART


            OPEN SET_ODD_PARTITIONS
            FETCH NEXT FROM SET_ODD_PARTITIONS INTO @P_PARTITION
            WHILE @@FETCH_STATUS = 0
            BEGIN
                IF @P_PARTITION IS NOT NULL
                BEGIN
                    EXECUTE WLF_LM_DROP_PARTITION_LIST @P_LIST_ID_PART = @P_PARTITION
                END
                FETCH NEXT FROM SET_ODD_PARTITIONS INTO @P_PARTITION
            END
            CLOSE SET_ODD_PARTITIONS
        COMMIT TRANSACTION;
		END TRY
	
		BEGIN CATCH
			SELECT
			ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			ROLLBACK TRANSACTION;
			THROW
	
		END CATCH
	
	END	
		
	@go@	



]

	/* ---------------------------------------------------------------------------- */
	/*  Maintenance	- Clear CF DB Result Logs										*/
	/* ---------------------------------------------------------------------------- */

[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_CLEAR_CF_DB_RESULT_LOGS
	(NUMBER_OF_DAYS IN number)
		AS
		
		DELETE_BEFORE_DATE @datetime@ := SYSDATE - NUMBER_OF_DAYS;
		
		BEGIN
			
			DELETE from WLF_RL_ADDRESS A
			WHERE A.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE);
			
			DELETE from WLF_RL_ALIAS A
			WHERE A.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE);
			
			DELETE from WLF_RL_ID I
			WHERE I.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE);
			
			DELETE from WLF_RL_NATIONALITY N
			WHERE N.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE);
			
			DELETE from WLF_RL_HIT_ADDINFO HA
			WHERE HA.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_ADDRESS HA
			WHERE HA.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_ALIAS HA
			WHERE HA.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_CATEGORY HC
			WHERE HC.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_DOB HD
			WHERE HD.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
		
			DELETE from WLF_RL_HIT_ID HI
			WHERE HI.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_KEYWORD HK
			WHERE HK.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_NATIONALITY HN
			WHERE HN.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_POB HP
			WHERE HP.HIT_ID IN (SELECT H.ID FROM WLF_RL_HIT H WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE));
		
			DELETE from WLF_RL_HIT H
			WHERE H.PARTY_ID IN (SELECT P.ID FROM WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE);
		
			DELETE from WLF_RL_PARTY P WHERE P.PROCESS_DATE < DELETE_BEFORE_DATE;

			COMMIT;
	
		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
				END;
	END;
	@go@

]

[mssql

	if exists (select * from sysobjects where name = 'WLF_CLEAR_CF_DB_RESULT_LOGS')
		drop procedure @env:lm_schema_name@.WLF_CLEAR_CF_DB_RESULT_LOGS
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_CLEAR_CF_DB_RESULT_LOGS  
	@NUMBER_OF_DAYS int
	AS 
   
   BEGIN
	  SET NOCOUNT ON;
      DECLARE
         @DELETE_BEFORE_DATE datetime
      BEGIN TRY
         SET @DELETE_BEFORE_DATE = getdate() - @NUMBER_OF_DAYS
         
		 DELETE WLF_RL_ADDRESS
		 FROM WLF_RL_ADDRESS AS A
		 WHERE A.PARTY_ID IN 
			(
				SELECT P.ID 
				FROM WLF_RL_PARTY AS P 
				WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
			)
		 
		 DELETE WLF_RL_ALIAS
		 FROM WLF_RL_ALIAS AS A
		 WHERE A.PARTY_ID IN 
			(
				SELECT P.ID 
				FROM WLF_RL_PARTY AS P 
				WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
			)
		 
		 DELETE WLF_RL_ID
		 FROM WLF_RL_ID AS I
		 WHERE I.PARTY_ID IN 
			(
				SELECT P.ID 
				FROM WLF_RL_PARTY AS P 
				WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
			)
         
		 DELETE WLF_RL_NATIONALITY
		 FROM WLF_RL_NATIONALITY AS N
		 WHERE N.PARTY_ID IN 
			(
				SELECT P.ID 
				FROM WLF_RL_PARTY AS P 
				WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
			)
			
		 DELETE WLF_RL_HIT_ADDINFO
		 FROM WLF_RL_HIT_ADDINFO AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
		
		 DELETE WLF_RL_HIT_ADDRESS
		 FROM WLF_RL_HIT_ADDRESS AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_ALIAS
		 FROM WLF_RL_HIT_ALIAS AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_CATEGORY
		 FROM WLF_RL_HIT_CATEGORY AS HC
		 WHERE HC.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_DOB
		 FROM WLF_RL_HIT_DOB AS HD
		 WHERE HD.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_ID
		 FROM WLF_RL_HIT_ID AS HI
		 WHERE HI.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_KEYWORD
		 FROM WLF_RL_HIT_KEYWORD AS HK
		 WHERE HK.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_NATIONALITY
		 FROM WLF_RL_HIT_NATIONALITY AS HN
		 WHERE HN.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_POB
		 FROM WLF_RL_HIT_POB AS HP
		 WHERE HP.HIT_ID IN 
			(
				SELECT H.ID 
				FROM WLF_RL_HIT AS H 
				WHERE H.PARTY_ID IN 
					(
						SELECT P.ID 
						FROM WLF_RL_PARTY AS P 
						WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT
		 FROM WLF_RL_HIT AS H
		 WHERE H.PARTY_ID IN 
			(
				SELECT P.ID 
				FROM WLF_RL_PARTY AS P 
				WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
			)
			
		 DELETE WLF_RL_PARTY
		 FROM WLF_RL_PARTY AS P
		 WHERE P.PROCESS_DATE < @DELETE_BEFORE_DATE
         
         IF @@TRANCOUNT > 0
            COMMIT
      END TRY
      BEGIN CATCH
 			 SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			THROW
      END CATCH
   END

	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  Maintenance	- Clear MS DB Result Logs										*/
	/* ---------------------------------------------------------------------------- */

[oracle

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_CLEAR_MS_DB_RESULT_LOGS
	(NUMBER_OF_DAYS IN number)
		AS
		
		DELETE_BEFORE_DATE @datetime@ := SYSDATE - NUMBER_OF_DAYS;
		
		BEGIN
			
			DELETE from WLF_RL_MESSAGE_INTERMEDIATE_FI MI
			WHERE MI.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
			
			DELETE from WLF_RL_HIT_ADDINFO HA
			WHERE HA.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_ADDRESS HA
			WHERE HA.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_ALIAS HA
			WHERE HA.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_CATEGORY HC
			WHERE HC.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_DOB HD
			WHERE HD.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
		
			DELETE from WLF_RL_HIT_ID HI
			WHERE HI.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_KEYWORD HK
			WHERE HK.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_NATIONALITY HN
			WHERE HN.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
			
			DELETE from WLF_RL_HIT_POB HP
			WHERE HP.HIT_ID IN (SELECT MH.ID FROM WLF_RL_MESSAGE_HIT MH WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE));
		
			DELETE from WLF_RL_MESSAGE_HIT MH
			WHERE MH.WLF_RL_MESSAGE_ID IN (SELECT M.ID FROM WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE);
		
			DELETE from WLF_RL_MESSAGE M WHERE M.JOB_TIMESTAMP < DELETE_BEFORE_DATE;
			
			DELETE FROM WLF_POLICY_RULES_AUDIT WHERE process_date < DELETE_BEFORE_DATE;

			COMMIT;
	
		EXCEPTION
			WHEN OTHERS THEN
				BEGIN
					ROLLBACK;
					RAISE;	
				END;
	END;
	@go@

]

[mssql

	if exists (select * from sysobjects where name = 'WLF_CLEAR_MS_DB_RESULT_LOGS')
		drop procedure @env:lm_schema_name@.WLF_CLEAR_MS_DB_RESULT_LOGS
	@go@

	CREATE PROCEDURE @env:lm_schema_name@.WLF_CLEAR_MS_DB_RESULT_LOGS  
	@NUMBER_OF_DAYS int
	AS 
   
   BEGIN
	  SET NOCOUNT ON;
      DECLARE
         @DELETE_BEFORE_DATE datetime
      BEGIN TRY
         SET @DELETE_BEFORE_DATE = getdate() - @NUMBER_OF_DAYS
                
		 DELETE WLF_RL_MESSAGE_INTERMEDIATE_FI
		 FROM WLF_RL_MESSAGE_INTERMEDIATE_FI AS MI
		 WHERE MI.WLF_RL_MESSAGE_ID IN 
			(
				SELECT M.ID 
				FROM WLF_RL_MESSAGE AS M 
				WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
			)
			
		 DELETE WLF_RL_HIT_ADDINFO
		 FROM WLF_RL_HIT_ADDINFO AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
		
		 DELETE WLF_RL_HIT_ADDRESS
		 FROM WLF_RL_HIT_ADDRESS AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_ALIAS
		 FROM WLF_RL_HIT_ALIAS AS HA
		 WHERE HA.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_CATEGORY
		 FROM WLF_RL_HIT_CATEGORY AS HC
		 WHERE HC.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_DOB
		 FROM WLF_RL_HIT_DOB AS HD
		 WHERE HD.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_ID
		 FROM WLF_RL_HIT_ID AS HI
		 WHERE HI.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_KEYWORD
		 FROM WLF_RL_HIT_KEYWORD AS HK
		 WHERE HK.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_NATIONALITY
		 FROM WLF_RL_HIT_NATIONALITY AS HN
		 WHERE HN.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_HIT_POB
		 FROM WLF_RL_HIT_POB AS HP
		 WHERE HP.HIT_ID IN 
			(
				SELECT MH.ID 
				FROM WLF_RL_MESSAGE_HIT AS MH 
				WHERE MH.WLF_RL_MESSAGE_ID IN 
					(
						SELECT M.ID 
						FROM WLF_RL_MESSAGE AS M 
						WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
					)
			)
			
		 DELETE WLF_RL_MESSAGE_HIT
		 FROM WLF_RL_MESSAGE_HIT AS MH
		 WHERE MH.WLF_RL_MESSAGE_ID IN 
			(
				SELECT M.ID 
				FROM WLF_RL_MESSAGE M 
				WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
			)
			
		 DELETE WLF_RL_MESSAGE
		 FROM WLF_RL_MESSAGE M
		 WHERE M.JOB_TIMESTAMP < @DELETE_BEFORE_DATE
		 
		 DELETE FROM WLF_POLICY_RULES_AUDIT WHERE PROCESS_DATE < @DELETE_BEFORE_DATE
         
         IF @@TRANCOUNT > 0
            COMMIT
      END TRY
      BEGIN CATCH
 			 SELECT 
			 ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;

			THROW
      END CATCH
   END

	@go@
]


[mssql

	if exists (select * from sysobjects where name = 'V_WLF_CDD_LISTCHECKING')
		drop view @env:lm_schema_name@.V_WLF_CDD_LISTCHECKING 
	@go@
			
	CREATE VIEW @env:lm_schema_name@.V_WLF_CDD_LISTCHECKING AS

	SELECT h.PARTY_KEY, h.LIST_ID as WATCH_LIST_CD, h.ALERT_ID, h.HIT_TIMESTAMP AS FROM_DATE, getdate() as ROW_UPDATE_DATE, j.JOB_USER as USER_ID
	FROM WLF_HITS h, V_CF_JOBS j 
	WHERE h.JOB_ID=j.JOB_ID
	
]
[oracle

	CREATE OR REPLACE VIEW @env:lm_schema_name@.V_WLF_CDD_LISTCHECKING AS

	SELECT h.PARTY_KEY, h.LIST_ID as WATCH_LIST_CD, h.ALERT_ID, h.HIT_TIMESTAMP AS FROM_DATE, SYSDATE as ROW_UPDATE_DATE, j.job_user as USER_ID
	FROM WLF_HITS h, V_CF_JOBS j 
	WHERE h.job_id=j.job_id
 
]
	@go@
	
	
	
[mssql
	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_METADATA_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_DELETE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_DELETE 
	ON @env:lm_schema_name@.WLF_SRCHDEF_METADATA AFTER DELETE
	AS
	BEGIN
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS WHERE SRCHDEF_ID IN (SELECT ID FROM DELETED);
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_BU WHERE SRCHDEF_ID IN (SELECT ID FROM DELETED);
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS WHERE SRCHDEF_ID IN (SELECT ID FROM DELETED);  
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_METADATA_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_UPDATE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_UPDATE
	ON @env:lm_schema_name@.WLF_SRCHDEF_METADATA
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_id varchar(100)
		DECLARE @new_id varchar(100)

		SELECT @old_id = DELETED.ID FROM DELETED
		SELECT @new_id=ID FROM Inserted

		IF @old_id != @new_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS SET SRCHDEF_ID = @new_id WHERE SRCHDEF_ID=@old_id;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_BU SET SRCHDEF_ID = @new_id WHERE SRCHDEF_ID=@old_id;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS SET SRCHDEF_ID = @new_id WHERE SRCHDEF_ID=@old_id;
		END	
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_CURRENT_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CURRENT_DELETE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CURRENT_DELETE 
	ON @env:lm_schema_name@.WLF_SRCHDEF_CURRENT AFTER DELETE
	AS
	BEGIN
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_BU_CURRENT WHERE SRCHDEF_ID IN
	  		(SELECT ID FROM DELETED);
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_SRCHCONF_METADATA_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_DELETE 
	ON @env:lm_schema_name@.WLF_SRCHCONF_METADATA AFTER DELETE
	AS
	BEGIN
  		DELETE FROM @env:lm_schema_name@.WLF_SRCHCONF_LISTS WHERE SRCHCFG_ID IN (SELECT ID FROM DELETED)
  		DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS WHERE SRCHCFG_ID IN (SELECT ID FROM DELETED)
	END
 	@go@
 	
	if exists (select * from sysobjects where name = 'WLF_SRCHCONF_METADATA_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_UPDATE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_UPDATE
	ON @env:lm_schema_name@.WLF_SRCHCONF_METADATA
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_id varchar(100)
		DECLARE @new_id varchar(100)

		SELECT @old_id = DELETED.ID FROM DELETED
		SELECT @new_id=ID FROM Inserted

		IF @old_id != @new_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SRCHCONF_LISTS SET SRCHCFG_ID = @new_id WHERE SRCHCFG_ID=@old_id;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS SET SRCHCFG_ID = @new_id WHERE SRCHCFG_ID=@old_id;
		END	
	END
	@go@

 	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_CONFIGS_INSERT')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_INSERT
	@go@
	
 	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_INSERT
	ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS AFTER INSERT
	AS
	BEGIN
		DECLARE @new_srchdef_id varchar(100)
		DECLARE @new_srchcfg_id varchar(100)
		SELECT @new_srchdef_id = INSERTED.SRCHDEF_ID, @new_srchcfg_id = INSERTED.SRCHCFG_ID FROM INSERTED
	  	INSERT INTO @env:lm_schema_name@.WLF_SD_CONF_FILTER (SRCHDEF_ID, SRCHCFG_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (@new_srchdef_id, @new_srchcfg_id, 'keywords', 'EXCLUDE');
	  	INSERT INTO @env:lm_schema_name@.WLF_SD_CONF_FILTER (SRCHDEF_ID, SRCHCFG_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (@new_srchdef_id, @new_srchcfg_id, 'categories', 'EXCLUDE');
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_CONFIGS_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_DELETE
	ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS AFTER DELETE
	AS
	BEGIN
	  	DELETE A FROM @env:lm_schema_name@.WLF_SD_CONF_FILTER AS A JOIN DELETED AS B ON A.SRCHDEF_ID=B.SRCHDEF_ID AND A.SRCHCFG_ID=B.SRCHCFG_ID
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_SRCHDEF_CONFIGS_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_UPDATE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_UPDATE
	ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_srchdef_id varchar(100)
		DECLARE @new_srchdef_id varchar(100)
		DECLARE @old_srchcfg_id varchar(100)
		DECLARE @new_srchcfg_id varchar(100)

		SELECT @old_srchdef_id = DELETED.SRCHDEF_ID FROM DELETED
		SELECT @new_srchdef_id=SRCHDEF_ID FROM Inserted
		SELECT @old_srchcfg_id = DELETED.SRCHCFG_ID FROM DELETED
		SELECT @new_srchcfg_id=SRCHCFG_ID FROM Inserted

		IF @old_srchdef_id != @new_srchdef_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER SET SRCHDEF_ID = @new_srchdef_id WHERE SRCHDEF_ID=@old_srchdef_id;
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL SET SRCHDEF_ID = @new_srchdef_id WHERE SRCHDEF_ID=@old_srchdef_id;
		END	
		IF @old_srchcfg_id != @new_srchcfg_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER SET SRCHCFG_ID = @new_srchcfg_id WHERE SRCHDEF_ID=@new_srchdef_id AND SRCHCFG_ID=@old_srchcfg_id;
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL SET SRCHCFG_ID = @new_srchcfg_id WHERE SRCHDEF_ID=@new_srchdef_id AND SRCHCFG_ID=@old_srchcfg_id;
		END	
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_SD_CONF_FILTER_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SD_CONF_FILTER_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SD_CONF_FILTER_DELETE 
	ON @env:lm_schema_name@.WLF_SD_CONF_FILTER AFTER DELETE
	AS 
	BEGIN
	  	DELETE A FROM @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL AS A JOIN DELETED AS B ON A.SRCHDEF_ID=B.SRCHDEF_ID AND A.SRCHCFG_ID=B.SRCHCFG_ID and A.FILTER_TYPE=B.FILTER_TYPE
	END
	@go@
 	
 	if exists (select * from sysobjects where name = 'WLF_SRCHCONF_LISTS_INSERT')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_INSERT
	@go@
	
 	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_INSERT 
	ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS AFTER INSERT
	AS 
	BEGIN
		DECLARE @new_list_id varchar(100)
		DECLARE @new_srchcfg_id varchar(100)
		SELECT @new_list_id = INSERTED.LIST_ID, @new_srchcfg_id = INSERTED.SRCHCFG_ID FROM INSERTED
	  	INSERT INTO @env:lm_schema_name@.WLF_SC_LIST_FILTER (SRCHCFG_ID, LIST_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (@new_srchcfg_id, @new_list_id, 'keywords', 'EXCLUDE')
	  	INSERT INTO @env:lm_schema_name@.WLF_SC_LIST_FILTER (SRCHCFG_ID, LIST_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (@new_srchcfg_id, @new_list_id, 'categories', 'EXCLUDE')
	END
 	@go@
 	
 	if exists (select * from sysobjects where name = 'WLF_SRCHCONF_LISTS_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_DELETE
	@go@
	
 	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_DELETE
	ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS AFTER DELETE
	AS 
	BEGIN
	  	DELETE A FROM @env:lm_schema_name@.WLF_SC_LIST_FILTER AS A JOIN DELETED AS B ON A.SRCHCFG_ID=B.SRCHCFG_ID AND A.LIST_ID=B.LIST_ID
	END
	@go@
	
 	if exists (select * from sysobjects where name = 'WLF_SRCHCONF_LISTS_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_UPDATE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_UPDATE
	ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_list_id varchar(100)
		DECLARE @new_list_id varchar(100)
		DECLARE @old_srchcfg_id varchar(100)
		DECLARE @new_srchcfg_id varchar(100)

		SELECT @old_list_id = DELETED.LIST_ID FROM DELETED
		SELECT @new_list_id=LIST_ID FROM Inserted
		SELECT @old_srchcfg_id = DELETED.SRCHCFG_ID FROM DELETED
		SELECT @new_srchcfg_id=SRCHCFG_ID FROM Inserted

		IF @old_srchcfg_id != @new_srchcfg_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER SET SRCHCFG_ID = @new_srchcfg_id WHERE SRCHCFG_ID=@old_srchcfg_id;
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL SET SRCHCFG_ID = @new_srchcfg_id WHERE SRCHCFG_ID=@old_srchcfg_id;
		END	
		IF @old_list_id != @new_list_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER SET LIST_ID = @new_list_id WHERE SRCHCFG_ID=@new_srchcfg_id AND LIST_ID=@old_list_id;
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL SET LIST_ID = @new_list_id WHERE SRCHCFG_ID=@new_srchcfg_id AND LIST_ID=@old_list_id;
		END	
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_SC_LIST_FILTER_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_SC_LIST_FILTER_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_SC_LIST_FILTER_DELETE 
	ON @env:lm_schema_name@.WLF_SC_LIST_FILTER AFTER DELETE
	AS 
	BEGIN
		DELETE A FROM @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL AS A JOIN DELETED AS B ON A.SRCHCFG_ID=B.SRCHCFG_ID AND A.LIST_ID=B.LIST_ID AND A.FILTER_TYPE=B.FILTER_TYPE
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_EXCLUDE_LIST_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_DELETE 
	ON @env:lm_schema_name@.WLF_EXCLUDE_LIST AFTER DELETE
	AS 
	BEGIN
		DECLARE @old_list_id varchar(100)
		SELECT @old_list_id = DELETED.LIST_ID FROM DELETED
	  	DELETE FROM @env:lm_schema_name@.WLF_ENTITY_EXCLUDE_ENTRIES WHERE LIST_ID = @old_list_id
	  	DELETE FROM @env:lm_schema_name@.WLF_HIT_EXCLUDE_ENTRIES WHERE LIST_ID = @old_list_id
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS WHERE EXCLUDE_LIST_ID = @old_list_id
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_EXCLUDE_LIST_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_UPDATE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_UPDATE
	ON @env:lm_schema_name@.WLF_EXCLUDE_LIST
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_list_id varchar(100)
		DECLARE @new_list_id varchar(100)

		SELECT @old_list_id = DELETED.LIST_ID FROM DELETED
		SELECT @new_list_id=LIST_ID FROM Inserted

		IF @old_list_id != @new_list_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_ENTITY_EXCLUDE_ENTRIES SET LIST_ID = @new_list_id WHERE LIST_ID=@old_list_id;
			UPDATE @env:lm_schema_name@.WLF_HIT_EXCLUDE_ENTRIES SET LIST_ID = @new_list_id WHERE LIST_ID=@old_list_id;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS SET EXCLUDE_LIST_ID = @new_list_id WHERE EXCLUDE_LIST_ID=@old_list_id;
		END	
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_TUNING_METADATA_INSERT')
		drop TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_INSERT
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_INSERT	
	ON @env:lm_schema_name@.WLF_TUNING_METADATA AFTER INSERT
	AS 
	BEGIN
	  DECLARE @new_tuning_id varchar(100)
	  SELECT @new_tuning_id = INSERTED.TUNING_ID FROM INSERTED
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_idMatch', 'CF','FIXED_VALUE',0,1, 'ID Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_idMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_idMatch', 'STRONG_MISMATCH',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_idMatch', 'WEAK_MISMATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_idMatch', 'MISSING',0);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_lowQualityAliases', 'CF','FIXED_VALUE',0,1, 'Low Quality Aliases');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'LOW',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'MEDIUM',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_countryMatch', 'CF','FIXED_VALUE',0,1, 'Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_countryMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_countryMatch', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_countryMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_numberOfKeywords', 'CF','RANGE_BASED',0,1, 'No. of Keywords');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_numberOfKeywords', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_numberOfKeywords', 5,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_numberOfKeywords', 10,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_LowRiskKeywords', 'CF','FIXED_VALUE',0,1, 'Low Risk Keywords');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_LowRiskKeywords', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_LowRiskKeywords', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_LowRiskCategories', 'CF','FIXED_VALUE',0,1, 'Low Risk Categories');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_LowRiskCategories', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_LowRiskCategories', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_singleTokenMatch', 'CF','FIXED_VALUE',0,1, 'Single Token Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_singleTokenMatch', 'YES',-30);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_singleTokenMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_orgExactMatch', 'CF','FIXED_VALUE',0,1, 'Organization Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_orgExactMatch', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_orgExactMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_personExactMatch', 'CF','FIXED_VALUE',0,1, 'Person Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_personExactMatch', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_personExactMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_localCountry', 'CF','FIXED_VALUE',0,1, 'Local Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_localCountry', 'YES',5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_localCountry', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_yearOfBirthMatch', 'CF','FIXED_VALUE',0,1, 'Year of Birth Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MISMATCH',-50);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_genderMatch', 'CF','FIXED_VALUE',0,1, 'Gender Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_genderMatch', 'MATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_genderMatch', 'MISMATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_genderMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_initialHitsNumber', 'CF','RANGE_BASED',0,1, 'No. of Initial Hits');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_initialHitsNumber', 3,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_initialHitsNumber', 6,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_initialHitsNumber', 8,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_initialHitsNumber', 10,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_initialHitsNumber', 20,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_isOrganization', 'CF','FIXED_VALUE',0,1, 'Is Organization');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_isOrganization', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_isOrganization', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorHitsFreq', 'CF','RANGE_BASED',0,1, 'Prior Hits Frequency');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsFreq', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsFreq', 5,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsFreq', 10,20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorHitsIssue', 'CF','RANGE_BASED',0,1, 'Prior Hits - Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsIssue', 1,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsIssue', 2,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorHitsNonIssue', 'CF','RANGE_BASED',0,1, 'Prior Hits - Non-Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsNonIssue', 1,-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsNonIssue', 2,-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorHitsNonDet', 'CF','RANGE_BASED',0,1, 'Prior Hits - Non-Determination');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsNonDet', 1,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorHitsNonDet', 2,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorAlertsIssue', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsIssue', 1,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsIssue', 2,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorAlertsNonIssue', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Non-Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsNonIssue', 1,-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsNonIssue', 2,-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_priorAlertsNonDet', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Non-Determination');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsNonDet', 1,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF','AML_WLF_CF_SF_priorAlertsNonDet', 2,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_countryCode', 'MS','FIXED_VALUE',0,1, 'Country Code');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryCode', 'CITY',-20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryCode', 'COUNTRY CODE',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryCode', 'BIC',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryCode', 'COUNTRY',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_isExactMatchSF', 'MS','FIXED_VALUE',0,1, 'Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_isExactMatchSF', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_isExactMatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_lowQualityAliases', 'MS','FIXED_VALUE',0,1, 'Low Quality Aliases');
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'LOW',-10);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'MEDIUM',-5);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_countryMatchSF', 'MS','FIXED_VALUE',0,1, 'Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryMatchSF', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryMatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_countryMismatchSF', 'MS','FIXED_VALUE',0,1, 'Country Mismatch');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryMismatchSF', 'YES',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_countryMismatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_isLocalCountry', 'MS','FIXED_VALUE',0,1, 'Is Local Country');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_singleToken', 'MS','FIXED_VALUE',0,1, 'Match On Single Token');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'NEGATIVE',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_SINGLE',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_MULTI',-8);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_MULTI_LOW_RISK',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_SINGLE_LOW_RISK',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'ENTRY_SINGLE_MULTI',-8);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_singleToken', 'ENTRY_SINGLE_MULTI_LOW_RISK',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_LowRiskMatches', 'MS','FIXED_VALUE',0,1, 'Low Risk Matches');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_implicitCountryMatch', 'MS','FIXED_VALUE',0,1, 'Implicit Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_LowRiskAdjacent', 'MS','FIXED_VALUE',0,1, 'Low Risk Adjacent');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_MS_SF_priorHitsFreq', 'MS','RANGE_BASED',0,1, 'Prior Hits Frequency');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_priorHitsFreq', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_priorHitsFreq', 5,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS','AML_WLF_MS_SF_priorHitsFreq', 10,20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 80,81);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 90,91);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 100,101);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 110,111);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 120,121);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 130,131);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 140,141);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 150,151);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'CF', 160,161);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 80,81);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 90,91);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 100,101);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 110,111);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 120,121);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 130,131);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 140,141);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 150,151);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (@new_tuning_id, 'MS', 160,161);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (@new_tuning_id, 'HIGH',100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (@new_tuning_id, 'MEDIUM',50);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (@new_tuning_id, 'LOW',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (@new_tuning_id, 'CORRECTIVE',-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (@new_tuning_id, 'AML_WLF_CF_SF_editDistanceMatch', 'CF','FIXED_VALUE',0,1, 'Edit Distance Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (@new_tuning_id, 'AML_WLF_NT_removeSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (@new_tuning_id, 'AML_WLF_NT_removeTAQsSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (@new_tuning_id, 'AML_WLF_NT_personRemoveTAQsSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (@new_tuning_id, 'AML_WLF_NT_orgRemoveTAQsSpacesAndPunctuation');

	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_TUNING_METADATA_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_DELETE
	@go@
	
	create TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_DELETE	
	ON @env:lm_schema_name@.WLF_TUNING_METADATA AFTER DELETE
	AS 
	BEGIN
	  DECLARE @old_tuning_id varchar(100)
	  SELECT @old_tuning_id = DELETED.TUNING_ID FROM DELETED
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS WHERE TUNING_ID=@old_tuning_id
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_IMPACTS WHERE TUNING_ID=@old_tuning_id
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES WHERE TUNING_ID=@old_tuning_id
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS WHERE TUNING_ID=@old_tuning_id
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_TUNING_METADATA_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_UPDATE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_UPDATE
	ON @env:lm_schema_name@.WLF_TUNING_METADATA
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_tuning_id varchar(100)
		DECLARE @new_tuning_id varchar(100)

		SELECT @old_tuning_id = DELETED.TUNING_ID FROM DELETED
		SELECT @new_tuning_id = TUNING_ID FROM Inserted

		IF @old_tuning_id != @new_tuning_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
			UPDATE @env:lm_schema_name@.WLF_TUNING_IMPACTS SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
			UPDATE @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_METADATA SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
	  		UPDATE @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;			
		END	
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_TUNING_SF_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_DELETE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_DELETE
	ON @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS AFTER DELETE
	AS 
	BEGIN
	 DELETE A FROM dbo.WLF_TUNING_SF_FIXED_VALUES AS A JOIN DELETED AS D ON 
	 A.TUNING_ID = D.TUNING_ID AND A.SCORE_FACTOR_ID=D.SCORE_FACTOR_ID AND A.SF_USAGE=D.SF_USAGE
     DELETE A FROM dbo.WLF_TUNING_SF_SCORE_RANGES AS A JOIN DELETED AS D ON 
     A.TUNING_ID = D.TUNING_ID AND A.SCORE_FACTOR_ID=D.SCORE_FACTOR_ID AND A.SF_USAGE=D.SF_USAGE
	END
	@go@

	if exists (select * from sysobjects where name = 'WLF_TUNING_SF_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_UPDATE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_UPDATE
	ON @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS
	FOR UPDATE
	AS
	BEGIN
		DECLARE @old_tuning_id varchar(100)
		DECLARE @new_tuning_id varchar(100)
		DECLARE @old_sf_id varchar(100)
		DECLARE @new_sf_id varchar(100)
		DECLARE @old_sf_usage varchar(100)

		SELECT @old_tuning_id = DELETED.TUNING_ID FROM DELETED
		SELECT @new_tuning_id=TUNING_ID FROM Inserted
		SELECT @old_sf_id = DELETED.SCORE_FACTOR_ID FROM DELETED
		SELECT @new_sf_id=SCORE_FACTOR_ID FROM Inserted
		SELECT @old_sf_usage=DELETED.SF_USAGE FROM DELETED

		IF @old_tuning_id != @new_tuning_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES SET TUNING_ID = @new_tuning_id WHERE TUNING_ID=@old_tuning_id;
		END	
		IF @old_sf_id != @new_sf_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES SET SCORE_FACTOR_ID = @new_sf_id WHERE TUNING_ID=@new_tuning_id AND SCORE_FACTOR_ID = @old_sf_id AND SF_USAGE = @old_sf_usage;
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES SET SCORE_FACTOR_ID = @new_sf_id WHERE TUNING_ID=@new_tuning_id AND SCORE_FACTOR_ID = @old_sf_id AND SF_USAGE = @old_sf_usage;
		END	
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_NAME_TRANSFORMS_DELETE')
		drop TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_DELETE
	@go@

	CREATE TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_DELETE 
	ON @env:lm_schema_name@.WLF_NAME_TRANSFORMS AFTER DELETE
	AS 
	BEGIN
		DECLARE @old_name_transform_id varchar(100)
		DECLARE @new_name_transform_id varchar(100)
		SELECT @new_name_transform_id=NAME_TRANSFORM_ID FROM Inserted
		SELECT @old_name_transform_id = DELETED.NAME_TRANSFORM_ID FROM DELETED
		DELETE FROM @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS WHERE NAME_TRANSFORM_ID=@old_name_transform_id;
	END
	@go@
	
	if exists (select * from sysobjects where name = 'WLF_NAME_TRANSFORMS_UPDATE')
		drop TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_UPDATE
	@go@
	
	CREATE TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_UPDATE 
	ON @env:lm_schema_name@.WLF_NAME_TRANSFORMS AFTER UPDATE
	AS 
	BEGIN
		DECLARE @old_name_transform_id varchar(100)
		DECLARE @new_name_transform_id varchar(100)
		
		if @old_name_transform_id != @new_name_transform_id
		BEGIN
			UPDATE @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS SET NAME_TRANSFORM_ID = @new_name_transform_id WHERE NAME_TRANSFORM_ID=@old_name_transform_id
		END
	END
	@go@

]
[oracle
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_DELETE
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SRCHDEF_METADATA 
	FOR EACH ROW 	
	BEGIN
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS WHERE SRCHDEF_ID=:OLD.ID;
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_BU WHERE SRCHDEF_ID=:OLD.ID;
	  	DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS WHERE SRCHDEF_ID=:OLD.ID;  
	END;
	@go@
 	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_METADATA_UPDATE
	AFTER UPDATE ON @env:lm_schema_name@.WLF_SRCHDEF_METADATA 
	FOR EACH ROW 
	BEGIN
		IF :OLD.ID !=:NEW.ID THEN
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS SET SRCHDEF_ID=:NEW.ID WHERE SRCHDEF_ID=:OLD.ID;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_BU SET SRCHDEF_ID=:NEW.ID WHERE SRCHDEF_ID=:OLD.ID;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS SET SRCHDEF_ID=:NEW.ID WHERE SRCHDEF_ID=:OLD.ID;
		END IF;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CURRENT_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SRCHDEF_CURRENT 
	FOR EACH ROW 
	BEGIN
  		DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_BU_CURRENT WHERE SRCHDEF_ID=:OLD.ID;
	END;
	@go@	

 	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SRCHCONF_METADATA 
	FOR EACH ROW
	BEGIN
  		DELETE FROM @env:lm_schema_name@.WLF_SRCHCONF_LISTS WHERE SRCHCFG_ID=:OLD.ID;
  		DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS WHERE SRCHCFG_ID=:OLD.ID;
	END;
 	@go@
 	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_METADATA_UPDATE
	AFTER UPDATE ON @env:lm_schema_name@.WLF_SRCHCONF_METADATA 
	FOR EACH ROW 
	BEGIN
		IF :OLD.ID !=:NEW.ID THEN
			UPDATE @env:lm_schema_name@.WLF_SRCHCONF_LISTS SET SRCHCFG_ID=:NEW.ID WHERE SRCHCFG_ID=:OLD.ID;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS SET SRCHCFG_ID=:NEW.ID WHERE SRCHCFG_ID=:OLD.ID;
		END IF;
	END;
	@go@

 	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_INSERT
	AFTER INSERT ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS 
	FOR EACH ROW
	BEGIN
	  INSERT INTO @env:lm_schema_name@.WLF_SD_CONF_FILTER (SRCHDEF_ID, SRCHCFG_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (:NEW.SRCHDEF_ID, :NEW.SRCHCFG_ID, 'keywords', 'EXCLUDE');
	  INSERT INTO @env:lm_schema_name@.WLF_SD_CONF_FILTER (SRCHDEF_ID, SRCHCFG_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (:NEW.SRCHDEF_ID, :NEW.SRCHCFG_ID, 'categories', 'EXCLUDE');
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_DELETE
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS 
	FOR EACH ROW
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_SD_CONF_FILTER WHERE SRCHDEF_ID=:OLD.SRCHDEF_ID AND SRCHCFG_ID=:OLD.SRCHCFG_ID;
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_SRCHDEF_CONFIGS 
	FOR EACH ROW 
	BEGIN
		IF :OLD.SRCHDEF_ID !=:NEW.SRCHDEF_ID THEN
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER SET SRCHDEF_ID = :NEW.SRCHDEF_ID WHERE SRCHDEF_ID=:OLD.SRCHDEF_ID;
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL SET SRCHDEF_ID = :NEW.SRCHDEF_ID WHERE SRCHDEF_ID=:OLD.SRCHDEF_ID;
		END IF;
		IF :OLD.SRCHCFG_ID !=:NEW.SRCHCFG_ID THEN
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER SET SRCHCFG_ID = :NEW.SRCHCFG_ID WHERE SRCHDEF_ID=:NEW.SRCHDEF_ID AND SRCHCFG_ID=:OLD.SRCHCFG_ID;
			UPDATE @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL SET SRCHCFG_ID = :NEW.SRCHCFG_ID WHERE SRCHDEF_ID=:NEW.SRCHDEF_ID and SRCHCFG_ID=:OLD.SRCHCFG_ID;
		END IF;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SD_CONF_FILTER_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SD_CONF_FILTER 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_SD_CONF_FILTER_VAL WHERE SRCHDEF_ID=:OLD.SRCHDEF_ID AND SRCHCFG_ID=:OLD.SRCHCFG_ID and FILTER_TYPE=:OLD.FILTER_TYPE;
	END;
	@go@
 	
 	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_INSERT 
	AFTER INSERT ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS 
	FOR EACH ROW 
	BEGIN
	  INSERT INTO @env:lm_schema_name@.WLF_SC_LIST_FILTER (SRCHCFG_ID, LIST_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (:NEW.SRCHCFG_ID, :NEW.LIST_ID, 'keywords', 'EXCLUDE');
	  INSERT INTO @env:lm_schema_name@.WLF_SC_LIST_FILTER (SRCHCFG_ID, LIST_ID, FILTER_TYPE, FILTER_IMPACT) VALUES (:NEW.SRCHCFG_ID, :NEW.LIST_ID, 'categories', 'EXCLUDE');
	END;
 	@go@
 	
 	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_DELETE
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_SC_LIST_FILTER WHERE SRCHCFG_ID=:OLD.SRCHCFG_ID and LIST_ID=:OLD.LIST_ID;
	END;
	@go@
	
	create or replace TRIGGER @env:lm_schema_name@.WLF_SRCHCONF_LISTS_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_SRCHCONF_LISTS 
	FOR EACH ROW 
	BEGIN
		IF :OLD.SRCHCFG_ID !=:NEW.SRCHCFG_ID THEN
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER SET SRCHCFG_ID = :NEW.SRCHCFG_ID WHERE SRCHCFG_ID=:OLD.SRCHCFG_ID;
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL SET SRCHCFG_ID = :NEW.SRCHCFG_ID WHERE SRCHCFG_ID=:OLD.SRCHCFG_ID;
		END IF;
		IF :OLD.LIST_ID !=:NEW.LIST_ID THEN
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER SET LIST_ID = :NEW.LIST_ID WHERE SRCHCFG_ID=:NEW.SRCHCFG_ID AND LIST_ID=:OLD.LIST_ID;
			UPDATE @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL SET LIST_ID = :NEW.LIST_ID WHERE SRCHCFG_ID=:NEW.SRCHCFG_ID and LIST_ID=:OLD.LIST_ID;
		END IF;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_SC_LIST_FILTER_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_SC_LIST_FILTER 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_SC_LIST_FILTER_VAL WHERE SRCHCFG_ID=:OLD.SRCHCFG_ID and LIST_ID=:OLD.LIST_ID AND FILTER_TYPE=:OLD.FILTER_TYPE;
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_EXCLUDE_LIST 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_ENTITY_EXCLUDE_ENTRIES WHERE LIST_ID = :OLD.LIST_ID;
	  DELETE FROM @env:lm_schema_name@.WLF_HIT_EXCLUDE_ENTRIES WHERE LIST_ID = :OLD.LIST_ID;
	  DELETE FROM @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS WHERE EXCLUDE_LIST_ID = :OLD.LIST_ID;
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_EXCLUDE_LIST_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_EXCLUDE_LIST 
	FOR EACH ROW 
	BEGIN
		IF :OLD.LIST_ID !=:NEW.LIST_ID THEN
			UPDATE @env:lm_schema_name@.WLF_ENTITY_EXCLUDE_ENTRIES SET LIST_ID = :NEW.LIST_ID WHERE LIST_ID=:OLD.LIST_ID;
			UPDATE @env:lm_schema_name@.WLF_HIT_EXCLUDE_ENTRIES SET LIST_ID = :NEW.LIST_ID WHERE LIST_ID=:OLD.LIST_ID;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_EXCLUDE_LISTS SET EXCLUDE_LIST_ID = :NEW.LIST_ID WHERE EXCLUDE_LIST_ID=:OLD.LIST_ID;
		END IF;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_INSERT	
	AFTER INSERT ON @env:lm_schema_name@.WLF_TUNING_METADATA 
	FOR EACH ROW 
	BEGIN
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_idMatch', 'CF','FIXED_VALUE',0,1, 'ID Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_idMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_idMatch', 'STRONG_MISMATCH',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_idMatch', 'WEAK_MISMATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_idMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_countryMatch', 'CF','FIXED_VALUE',0,1, 'Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_lowQualityAliases', 'CF','FIXED_VALUE',0,1, 'Low Quality Aliases');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'LOW',-10);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'MEDIUM',-5);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_lowQualityAliases', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_countryMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_countryMatch', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_countryMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_numberOfKeywords', 'CF','RANGE_BASED',0,1, 'No. of Keywords');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_numberOfKeywords', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_numberOfKeywords', 5,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_numberOfKeywords', 10,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_LowRiskKeywords', 'CF','FIXED_VALUE',0,1, 'Low Risk Keywords');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_LowRiskKeywords', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_LowRiskKeywords', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_LowRiskCategories', 'CF','FIXED_VALUE',0,1, 'Low Risk Categories');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_LowRiskCategories', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_LowRiskCategories', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_singleTokenMatch', 'CF','FIXED_VALUE',0,1, 'Single Token Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_singleTokenMatch', 'YES',-30);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_singleTokenMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_orgExactMatch', 'CF','FIXED_VALUE',0,1, 'Organization Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_orgExactMatch', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_orgExactMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_personExactMatch', 'CF','FIXED_VALUE',0,1, 'Person Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_personExactMatch', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_personExactMatch', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_localCountry', 'CF','FIXED_VALUE',0,1, 'Local Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_localCountry', 'YES',5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_localCountry', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_yearOfBirthMatch', 'CF','FIXED_VALUE',0,1, 'Year of Birth Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MISMATCH',-50);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_yearOfBirthMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_genderMatch', 'CF','FIXED_VALUE',0,1, 'Gender Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_genderMatch', 'MATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_genderMatch', 'MISMATCH',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_genderMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_initialHitsNumber', 'CF','RANGE_BASED',0,1, 'No. of Initial Hits');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_initialHitsNumber', 3,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_initialHitsNumber', 6,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_initialHitsNumber', 8,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_initialHitsNumber', 10,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_initialHitsNumber', 20,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_isOrganization', 'CF','FIXED_VALUE',0,1, 'Is Organization');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_isOrganization', 'YES',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_isOrganization', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorHitsFreq', 'CF','RANGE_BASED',0,1, 'Prior Hits Frequency');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsFreq', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsFreq', 5,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsFreq', 10,20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorHitsIssue', 'CF','RANGE_BASED',0,1, 'Prior Hits - Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsIssue', 1,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsIssue', 2,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorHitsNonIssue', 'CF','RANGE_BASED',0,1, 'Prior Hits - Non-Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsNonIssue', 1,-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsNonIssue', 2,-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorHitsNonDet', 'CF','RANGE_BASED',0,1, 'Prior Hits - Non-Determination');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsNonDet', 1,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorHitsNonDet', 2,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorAlertsIssue', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsIssue', 1,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsIssue', 2,100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorAlertsNonIssue', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Non-Issue');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsNonIssue', 1,-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsNonIssue', 2,-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_priorAlertsNonDet', 'CF','RANGE_BASED',0,1, 'Prior Alerts - Non-Determination');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsNonDet', 1,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF','AML_WLF_CF_SF_priorAlertsNonDet', 2,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_countryCode', 'MS','FIXED_VALUE',0,1, 'Country Code');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryCode', 'CITY',-20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryCode', 'COUNTRY CODE',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryCode', 'BIC',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryCode', 'COUNTRY',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_lowQualityAliases', 'MS','FIXED_VALUE',0,1, 'Low Quality Aliases');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'LOW',-10);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'MEDIUM',-5);
      INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_lowQualityAliases', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_isExactMatchSF', 'MS','FIXED_VALUE',0,1, 'Exact Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_isExactMatchSF', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_isExactMatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_countryMatchSF', 'MS','FIXED_VALUE',0,1, 'Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryMatchSF', 'YES',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryMatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_countryMismatchSF', 'MS','FIXED_VALUE',0,1, 'Country Mismatch');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryMismatchSF', 'YES',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_countryMismatchSF', 'NO',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_isLocalCountry', 'MS','FIXED_VALUE',0,1, 'Is Local Country');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_isLocalCountry', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_singleToken', 'MS','FIXED_VALUE',0,1, 'Match On Single Token');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'NEGATIVE',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_SINGLE',-5);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_MULTI',-8);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_MULTI_LOW_RISK',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'SINGLE_SINGLE_LOW_RISK',-10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'ENTRY_SINGLE_MULTI',-8);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_singleToken', 'ENTRY_SINGLE_MULTI_LOW_RISK',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_LowRiskMatches', 'MS','FIXED_VALUE',0,1, 'Low Risk Matches');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_implicitCountryMatch', 'MS','FIXED_VALUE',0,1, 'Implicit Country Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MATCH',10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MISMATCH',-15);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FIXED_VALUE_ID, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_implicitCountryMatch', 'MISSING',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_LowRiskAdjacent', 'MS','FIXED_VALUE',0,1, 'Low Risk Adjacent');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_MS_SF_priorHitsFreq', 'MS','RANGE_BASED',0,1, 'Prior Hits Frequency');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_priorHitsFreq', 0,0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_priorHitsFreq', 5,10);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES (TUNING_ID, SF_USAGE, SCORE_FACTOR_ID, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS','AML_WLF_MS_SF_priorHitsFreq', 10,20);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 80,81);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 90,91);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 100,101);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 110,111);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 120,121);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 130,131);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 140,141);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 150,151);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'CF', 160,161);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 80,81);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 90,91);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 100,101);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 110,111);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 120,121);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 130,131);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 140,141);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 150,151);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES (TUNING_ID, NM_USAGE, FROM_VALUE, SCORE) VALUES (:NEW.TUNING_ID, 'MS', 160,161);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (:NEW.TUNING_ID, 'HIGH',100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (:NEW.TUNING_ID, 'MEDIUM',50);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (:NEW.TUNING_ID, 'LOW',0);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_IMPACTS (TUNING_ID, IMPACT_ID, FROM_VALUE) VALUES (:NEW.TUNING_ID, 'CORRECTIVE',-100);
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS (TUNING_ID, SCORE_FACTOR_ID, SF_USAGE, SF_TYPE, IS_CUSTOM, IS_ACTIVE, SF_NAME) VALUES (:NEW.TUNING_ID, 'AML_WLF_CF_SF_editDistanceMatch', 'CF','FIXED_VALUE',0,1, 'Edit Distance Match');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (:NEW.TUNING_ID, 'AML_WLF_NT_removeSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (:NEW.TUNING_ID, 'AML_WLF_NT_removeTAQsSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (:NEW.TUNING_ID, 'AML_WLF_NT_personRemoveTAQsSpacesAndPunctuation');
	  INSERT INTO @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS (TUNING_ID, NAME_TRANSFORM_ID) VALUES (:NEW.TUNING_ID, 'AML_WLF_NT_orgRemoveTAQsSpacesAndPunctuation');
	  
	END;
	@go@
	
	create or replace TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_DELETE	
	BEFORE DELETE ON @env:lm_schema_name@.WLF_TUNING_METADATA 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS WHERE TUNING_ID=:OLD.TUNING_ID;
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_IMPACTS WHERE TUNING_ID=:OLD.TUNING_ID;
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES WHERE TUNING_ID=:OLD.TUNING_ID;
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS WHERE TUNING_ID=:OLD.TUNING_ID;
	END;
	@go@
	
	create or replace TRIGGER @env:lm_schema_name@.WLF_TUNING_METADATA_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_TUNING_METADATA 
	FOR EACH ROW 
	BEGIN
		IF :OLD.TUNING_ID !=:NEW.TUNING_ID THEN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
			UPDATE @env:lm_schema_name@.WLF_TUNING_IMPACTS SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
			UPDATE @env:lm_schema_name@.WLF_TUNING_NM_SCORE_RANGES SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
			UPDATE @env:lm_schema_name@.WLF_SRCHDEF_METADATA SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
			UPDATE @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
	  		UPDATE @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
		END IF;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_DELETE
	BEFORE DELETE ON @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES WHERE TUNING_ID=:OLD.TUNING_ID AND SCORE_FACTOR_ID=:OLD.SCORE_FACTOR_ID AND SF_USAGE=:OLD.SF_USAGE;
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES WHERE TUNING_ID=:OLD.TUNING_ID AND SCORE_FACTOR_ID=:OLD.SCORE_FACTOR_ID AND SF_USAGE=:OLD.SF_USAGE;
	END;
	@go@

	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_TUNING_SF_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_TUNING_SCORE_FACTORS 
	FOR EACH ROW 
	BEGIN
		IF :OLD.TUNING_ID !=:NEW.TUNING_ID THEN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES SET TUNING_ID = :NEW.TUNING_ID WHERE TUNING_ID=:OLD.TUNING_ID;
		END IF;
		IF :OLD.SCORE_FACTOR_ID !=:NEW.SCORE_FACTOR_ID THEN
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_FIXED_VALUES SET SCORE_FACTOR_ID = :NEW.SCORE_FACTOR_ID WHERE TUNING_ID=:NEW.TUNING_ID AND SCORE_FACTOR_ID = :OLD.SCORE_FACTOR_ID AND SF_USAGE = :OLD.SF_USAGE;
			UPDATE @env:lm_schema_name@.WLF_TUNING_SF_SCORE_RANGES SET SCORE_FACTOR_ID = :NEW.SCORE_FACTOR_ID WHERE TUNING_ID=:NEW.TUNING_ID AND SCORE_FACTOR_ID = :OLD.SCORE_FACTOR_ID AND SF_USAGE = :OLD.SF_USAGE;
		END IF;
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_DELETE 
	BEFORE DELETE ON @env:lm_schema_name@.WLF_NAME_TRANSFORMS 
	FOR EACH ROW 
	BEGIN
	  DELETE FROM @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS WHERE NAME_TRANSFORM_ID=:OLD.NAME_TRANSFORM_ID;
	END;
	@go@
	
	CREATE OR REPLACE TRIGGER @env:lm_schema_name@.WLF_NAME_TRANSFORMS_UPDATE 
	AFTER UPDATE ON @env:lm_schema_name@.WLF_NAME_TRANSFORMS 
	FOR EACH ROW 
	BEGIN
		IF :OLD.NAME_TRANSFORM_ID !=:NEW.NAME_TRANSFORM_ID THEN
			UPDATE @env:lm_schema_name@.WLF_TUNING_NAME_TRANSFORMS SET NAME_TRANSFORM_ID = :NEW.NAME_TRANSFORM_ID WHERE NAME_TRANSFORM_ID=:OLD.NAME_TRANSFORM_ID;
		END IF;
	END;
	@go@	
]
[mssql

	/* ------------------------------------------------------------ */
	/* 			create RL partition 								*/
	/* ------------------------------------------------------------ */
	
	if exists (select * from sysobjects where name = 'WLF_RL_CREATE_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_RL_CREATE_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_RL_CREATE_PARTITION
	@JOB_ID @ustring@(50)
	AS 
	BEGIN

      BEGIN TRY

         DECLARE
			@var1 int,
            @P_PART_NAME varchar(30), 
			@EXEC_STR varchar(1000)
            
			SET @P_PART_NAME = @JOB_ID + 'Z';
                  BEGIN
				  
				  SELECT  @var1 = COUNT(*)   
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'rl_partfunc') and  cast(sprv.value as varchar) = @P_PART_NAME;

						IF @var1 <> 1
						BEGIN
							ALTER PARTITION SCHEME rl_partscheme NEXT USED [PRIMARY];
              
							SET @EXEC_STR = 
								'alter partition function rl_partfunc()
								SPLIT RANGE (''' + @P_PART_NAME + ''');'
							EXECUTE (@EXEC_STR)
						END
                  END
          EXECUTE WLF_SRCHLOG_CREATE_PARTITION
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		THROW

      END CATCH

	END	
    @go@
	
	/* ------------------------------------------------------------ */
	/*	RL_MS create partition		*/
	/* ------------------------------------------------------------ */

	if exists (select * from sysobjects where name = 'WLF_RL_MS_CREATE_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_RL_MS_CREATE_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_RL_MS_CREATE_PARTITION
	@JOB_ID @ustring@(50)
	AS 
	BEGIN

      BEGIN TRY

         DECLARE
			@var1 int,
            @P_PART_NAME varchar(30), 
			@EXEC_STR varchar(1000)
            
			SET @P_PART_NAME = @JOB_ID + 'Z';
                  BEGIN
				  
				  SELECT  @var1 = COUNT(*)   
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'rl_ms_partfunc') and  sprv.value = @P_PART_NAME;

						IF @var1 <> 1
						BEGIN
							ALTER PARTITION SCHEME rl_ms_partscheme NEXT USED [PRIMARY];
              
							SET @EXEC_STR = 
								'alter partition function rl_ms_partfunc()
								SPLIT RANGE (''' + @P_PART_NAME + ''');'
							EXECUTE (@EXEC_STR)
						END
                  END
                  EXECUTE WLF_MS_SRCHLOG_CREATE_PARTITION
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		THROW

      END CATCH

	END	
	@go@
	
	/* ------------------------------------------------------------ */
	/*	drop RL table partitions									 */
	/* ------------------------------------------------------------ */
	if exists (select * from sysobjects where name = 'WLF_RL_DROP_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_RL_DROP_PARTITION
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_RL_DROP_PARTITION
	@job_id varchar(30)
		
	AS	
	BEGIN
	  SET NOCOUNT ON;
		  BEGIN TRY
			 DECLARE
			   
				@var varchar(30),
				@RL_TABLE_NAME varchar(30),
				@EXEC_STR varchar(1000),
				@RL_TABLE_NAME_TEMP varchar(30),
				@PARTITION int
		
			
				  SELECT @var = @job_id + 'Z';
			  
			  SELECT @PARTITION = $partition.rl_partfunc(@var);
			DECLARE RL_TABLE_CURSOR CURSOR LOCAL FOR 
			SELECT NAME
			FROM sys.tables
			where name like 'WLF_RL%' and name not like 'WLF_RL_MESSAGE%' and name not like 'WLF_RL%TEMP';
			  
			OPEN RL_TABLE_CURSOR
		FETCH NEXT FROM RL_TABLE_CURSOR 
		INTO @RL_TABLE_NAME
		
		
		WHILE @@FETCH_STATUS = 0
			BEGIN
				
				SET @RL_TABLE_NAME_TEMP = @RL_TABLE_NAME + '_TEMP';
				
				EXECUTE dbo.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @RL_TABLE_NAME, @P_TABLE_NONPART = @RL_TABLE_NAME_TEMP, @PARTITION_NAME = @PARTITION;
				
				SET @EXEC_STR = 'TRUNCATE TABLE @env:lm_schema_name@.' + @RL_TABLE_NAME + '_TEMP;'
				EXECUTE (@EXEC_STR)
				
				FETCH NEXT FROM RL_TABLE_CURSOR 
				INTO @RL_TABLE_NAME
		
			END
			 
		CLOSE RL_TABLE_CURSOR;
		DEALLOCATE RL_TABLE_CURSOR;
		
			
			ALTER PARTITION FUNCTION rl_partfunc() MERGE RANGE (@var);
		
		END TRY
		  BEGIN CATCH
		SELECT 
			ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			THROW
		 END CATCH
	END
	RETURN

	@go@
	
		
	/* ------------------------------------------------------------ */
	/* drop RL MS TABLE PARTITIONS */
	/* ------------------------------------------------------------ */
	
	if exists (select * from sysobjects where name = 'WLF_RL_MS_DROP_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_RL_MS_DROP_PARTITION
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_RL_MS_DROP_PARTITION
	@job_id varchar(30)
		
	AS	
	BEGIN
	  SET NOCOUNT ON;
		  BEGIN TRY
			 DECLARE
			   
				@var varchar(30),
				@RL_TABLE_NAME varchar(30),
				@EXEC_STR varchar(1000),
				@RL_TABLE_NAME_TEMP varchar(30),
				@PARTITION int
		
			
				  SELECT @var = @job_id + 'Z';
			  
			  SELECT @PARTITION = $partition.rl_partfunc(@var);
			DECLARE RL_TABLE_CURSOR CURSOR LOCAL FOR 
			SELECT NAME
			FROM sys.tables
			where name like 'WLF_RL_MESSAGE%' and name not like 'WLF_RL_MESSAGE%TEMP' and name <> 'WLF_RL_MESSAGE_INTERMEDIATE_FI';
			  
			OPEN RL_TABLE_CURSOR
		FETCH NEXT FROM RL_TABLE_CURSOR 
		INTO @RL_TABLE_NAME
		
		
		WHILE @@FETCH_STATUS = 0
			BEGIN

					SET @RL_TABLE_NAME_TEMP = @RL_TABLE_NAME + '_TEMP';
					EXECUTE dbo.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @RL_TABLE_NAME, @P_TABLE_NONPART = @RL_TABLE_NAME_TEMP, @PARTITION_NAME = @PARTITION;

					SET @EXEC_STR = 'TRUNCATE TABLE dbo.' + @RL_TABLE_NAME + '_TEMP;'
					EXECUTE (@EXEC_STR)

				FETCH NEXT FROM RL_TABLE_CURSOR 
				INTO @RL_TABLE_NAME
		
			END
			 
		CLOSE RL_TABLE_CURSOR;
		DEALLOCATE RL_TABLE_CURSOR;
		
			
			EXECUTE WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = 'WLF_RL_MESSAGE_INTERMEDIATE_FI', @P_TABLE_NONPART = 'WLF_RL_MESSAGE_INTERMED_TEMP', @PARTITION_NAME = @PARTITION;
		  SET @EXEC_STR = 'TRUNCATE TABLE dbo.WLF_RL_MESSAGE_INTERMED_TEMP;'
		  EXECUTE (@EXEC_STR)			
			ALTER PARTITION FUNCTION rl_ms_partfunc() MERGE RANGE (@var);
		
		END TRY
		  BEGIN CATCH
		SELECT 
			ERROR_NUMBER() AS ErrorNumber
			,ERROR_SEVERITY() AS ErrorSeverity
			,ERROR_STATE() AS ErrorState
			,ERROR_PROCEDURE() AS ErrorProcedure
			,ERROR_LINE() AS ErrorLine
			,ERROR_MESSAGE() AS ErrorMessage;
			THROW
		 END CATCH
	END
	RETURN
	@go@
]
[oracle 
	
	/* ------------------------------------------------------------ */
	/* create RL partions				 */
	/* ------------------------------------------------------------ */
    CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_RL_CREATE_PARTITION
    (
        P_JOB_ID VARCHAR2
    )
    AS

        V_PART_NAME VARCHAR2(30);
        V_COUNT NUMBER;
        V_EXEC_STR VARCHAR2(1000);
		c_timeout NUMBER;

    BEGIN
	    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
        /***  that locks tables that this process try to create partition in. ***/
        select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
        execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;

        /*********** Step 1 - Get the partition name */
        V_PART_NAME := 'P' || rtrim(substr(P_JOB_ID,1,2)) || '_' || rtrim(substr(P_JOB_ID,4,10));

        /*********** Step 2 - For each partitioned table create new partition (if not exists), partition by LIST(JOB_ID) */
        FOR REC IN (
            SELECT DISTINCT TABLE_NAME
            FROM USER_TAB_PARTITIONS
            WHERE TABLE_NAME LIKE 'WLF_RL%'
                AND TABLE_NAME NOT LIKE 'WLF_RL_MESSAGE%'
            ORDER BY TABLE_NAME
        )
        LOOP

            SELECT COUNT(*)
            INTO V_COUNT
            FROM USER_TAB_PARTITIONS
            WHERE TABLE_NAME = REC.TABLE_NAME
            AND PARTITION_NAME = V_PART_NAME;

            /********* Check if the partition doesn't exist */
            IF V_COUNT = 0 THEN
            BEGIN
                V_EXEC_STR := 'ALTER TABLE @env:lm_schema_name@.' || REC.TABLE_NAME || ' add partition ' || V_PART_NAME || ' values (''' || P_JOB_ID || ''') storage (initial @env:initial_extent@)';
                --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                EXECUTE IMMEDIATE (V_EXEC_STR);
            EXCEPTION WHEN OTHERS THEN
                IF SQLCODE = -14312 THEN
                    NULL;
                    --DBMS_OUTPUT.PUT_LINE('ORA-14312 : ' || SQLERRM || ', query: ' || V_EXEC_STR);
                ELSE
                    RAISE_APPLICATION_ERROR(-20001,'Error while creating partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
                END IF;
            END;
            END IF;

        END LOOP;

        /*********** Note that partition will be created automatically to table WLF_SRCH_LOG table at the time of inserting new row for new month, because table uses interval partitioning by JOB_TIMESTAMP */

        EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20001,'Error while creating partition for the job: ' || P_JOB_ID || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
    END;
	@go@
	
	
	/* ------------------------------------------------------------ */
	/* MESSAGE SCREENING RL TABLES PARTITIONING */
	/* ------------------------------------------------------------ */
	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_RL_MS_CREATE_PARTITION ( JOB_ID VARCHAR2 )
	AS
	
	CURSOR	PARTITIONED_TABLES_SET IS
	SELECT	DISTINCT TABLE_NAME
	FROM	USER_TAB_PARTITIONS WHERE TABLE_NAME LIKE 'WLF_RL_MESSAGE%'
	ORDER BY TABLE_NAME;

	PARTITIONED_TABLE	PARTITIONED_TABLES_SET%ROWTYPE;

	P_TABLE_NAME		VARCHAR2(30);
	P_PART_NAME		VARCHAR2(30);
	P_COUNTER		NUMBER;
	EXEC_STR		VARCHAR2(1000);
	c_timeout NUMBER;
	
	BEGIN
	    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
        /***  that locks tables that this process try to create partition in. ***/
        select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
        execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;

		/* Generated the partition name */
		P_PART_NAME := 'P' || rtrim(substr(JOB_ID,1,2)) || '_' || rtrim(substr(JOB_ID,4,10));
		

			OPEN PARTITIONED_TABLES_SET;
		
		LOOP
		
			FETCH PARTITIONED_TABLES_SET INTO PARTITIONED_TABLE;
			EXIT WHEN PARTITIONED_TABLES_SET%NOTFOUND;
			
			P_TABLE_NAME := PARTITIONED_TABLE.TABLE_NAME;
			--DBMS_OUTPUT.put_line ('Table Name: ' || to_char(P_TABLE_NAME));
					
			SELECT	count(*)
			INTO	P_COUNTER 
			FROM	USER_TAB_PARTITIONS 
			WHERE	TABLE_NAME = P_TABLE_NAME and PARTITION_NAME = P_PART_NAME;
			
			--DBMS_OUTPUT.put_line ('Counter: ' || to_char(P_COUNTER));
										
			IF P_COUNTER = 0 THEN
				BEGIN
					EXEC_STR := 'alter table @env:lm_schema_name@.' || P_TABLE_NAME || ' add partition ' ||
						P_PART_NAME || ' values (''' || JOB_ID || ''') storage (initial @env:initial_extent@)' ;
				
					--DBMS_OUTPUT.put_line (EXEC_STR);
					EXECUTE IMMEDIATE (EXEC_STR);
				END;			
			END IF;
		
		END LOOP;
		
		CLOSE PARTITIONED_TABLES_SET;		
			
					
		EXCEPTION
			WHEN OTHERS THEN
				RAISE;
	END;
	@go@
	
		CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_CHECK_TOTAL_PART(TABL_NAME IN VARCHAR2, TOT_CNT OUT NUMBER)
	AS
	BEGIN
		SELECT COUNT(*) INTO TOT_CNT FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = TABL_NAME;
	END;
	@go@
	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_REBUILD_INDEXES(TABL_NAME VARCHAR2)
		AS
		BEGIN
		
			FOR INDX IN ( SELECT INDEX_NAME,PARTITIONED,STATUS FROM USER_INDEXES WHERE TABLE_NAME = TABL_NAME AND STATUS NOT IN ('VALID') )
			LOOP
				IF (INDX.PARTITIONED = 'YES') 
				THEN 
					FOR INDX_PART IN (SELECT INDEX_NAME,STATUS,PARTITION_NAME FROM USER_IND_PARTITIONS WHERE INDEX_NAME = INDX.INDEX_NAME AND STATUS NOT IN ('USABLE') ) 
					LOOP
						EXECUTE IMMEDIATE (' ALTER INDEX ' || INDX.INDEX_NAME || ' REBUILD PARTITION ' || INDX_PART.PARTITION_NAME);
					END LOOP;
					
				ELSE
					EXECUTE IMMEDIATE (' ALTER INDEX ' || INDX.INDEX_NAME || ' REBUILD ');
				END IF;
			END LOOP;
		END;
	@go@
		
	/*	drop RL table partitions */
    CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_RL_DROP_PARTITION
    (
        P_JOB_ID VARCHAR2
    )
    AS

        V_PART_NAME VARCHAR2(50);
        V_EXEC_STR VARCHAR2(1000);

    BEGIN
        /* Generate the partition name */
        V_PART_NAME := 'P' || rtrim(substr(P_JOB_ID,1,2)) || '_' || rtrim(substr(P_JOB_ID,4,10));

        FOR REC IN (
            SELECT DISTINCT TABLE_NAME
            FROM USER_TAB_PARTITIONS
            WHERE TABLE_NAME LIKE 'WLF_RL%'
                AND TABLE_NAME NOT LIKE 'WLF_RL_MESSAGE%'
                AND PARTITION_NAME <> 'P0'
            ORDER BY TABLE_NAME
        )
        LOOP
            BEGIN

                V_EXEC_STR := 'ALTER TABLE @env:lm_schema_name@.' || REC.TABLE_NAME || ' drop partition ' || V_PART_NAME;
                --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                EXECUTE IMMEDIATE (V_EXEC_STR);

            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE = -14083 THEN
                        NULL;
                        --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR );
                    ELSIF SQLCODE = -02149 THEN
                        NULL;
                        --DBMS_OUTPUT.PUT_LINE('ORA - 13117: ' || SQLERRM || ', query: ' || V_EXEC_STR );
                    ELSIF SQLCODE = -54 THEN
                        --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
                        DBMS_LOCK.SLEEP(10);
                        --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                        EXECUTE IMMEDIATE (V_EXEC_STR);
                    ELSE
                        RAISE_APPLICATION_ERROR(-20001,'Unexpected error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
                    END IF;
            END;
        END LOOP;
    EXCEPTION
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR(-20001,'Unexpected error while dropping partition for job id: ' || P_JOB_ID || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
    END;
	@go@
	
	/*	drop RL MS table partitions */
	
	create or replace
	PROCEDURE   @env:lm_schema_name@.WLF_RL_MS_DROP_PARTITION ( JOB_ID VARCHAR2 )
	AS

	CURSOR	PARTITIONED_TABLES_SET IS
	SELECT	DISTINCT TABLE_NAME
	FROM	USER_TAB_PARTITIONS WHERE TABLE_NAME LIKE 'WLF_RL_MESSAGE%'
	ORDER BY TABLE_NAME;

	PARTITIONED_TABLE	PARTITIONED_TABLES_SET%ROWTYPE;

	P_TABLE_NAME		VARCHAR2(30);
	P_PART_NAME		VARCHAR2(30);
	P_COUNTER		NUMBER;
	EXEC_STR		VARCHAR2(1000);

	BEGIN

		/* Generated the partition name */
		P_PART_NAME := 'P' || rtrim(substr(JOB_ID,1,2)) || '_' || rtrim(substr(JOB_ID,4,10));

		OPEN PARTITIONED_TABLES_SET;

		LOOP

			FETCH PARTITIONED_TABLES_SET INTO PARTITIONED_TABLE;
			EXIT WHEN PARTITIONED_TABLES_SET%NOTFOUND;

			P_TABLE_NAME := PARTITIONED_TABLE.TABLE_NAME;
			--DBMS_OUTPUT.put_line ('Table Name: ' || to_char(P_TABLE_NAME));

			SELECT	count(*)
			INTO	P_COUNTER
			FROM	USER_TAB_PARTITIONS
			WHERE	TABLE_NAME = P_TABLE_NAME and PARTITION_NAME = P_PART_NAME;

			--DBMS_OUTPUT.put_line ('Counter: ' || to_char(P_COUNTER));

			IF P_COUNTER = 1 THEN
				BEGIN
					EXEC_STR := 'alter table @env:lm_schema_name@.' || P_TABLE_NAME || ' drop partition ' || P_PART_NAME;

					--DBMS_OUTPUT.put_line (EXEC_STR);
					EXECUTE IMMEDIATE (EXEC_STR);
				END;
			END IF;

		END LOOP;

		CLOSE PARTITIONED_TABLES_SET;


		EXCEPTION
			WHEN OTHERS THEN
				RAISE;
	END;
	
	@go@
]
[mssql

	if exists (select * from sysobjects where name = 'WLF_SRCHLOG_CREATE_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_SRCHLOG_CREATE_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_SRCHLOG_CREATE_PARTITION
	AS 
	BEGIN

      BEGIN TRY

         DECLARE
            @var1 varchar(8),
            @var2 varchar(8),
            @P_JOB_DATE varchar(10),
            @EXEC_STR varchar(1000)
  
                  BEGIN
                  
				 /* compares system next month to the last existing partition boundary and if not equal alters the partition function 
				 to include the next month */
					 
                      SELECT  @var1 = substring(max(CONVERT(VARCHAR(8),(sprv.value), 112)),1,6)  
						FROM sys.partition_functions AS spf 
						INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
						WHERE (spf.name=N'srch_log_partfunc');
	
						select @var2 = substring(CONVERT(VARCHAR(8), DATEADD(MM,1,GETDATE()), 112),1,6);
						IF 	@var1 <> @var2
					     BEGIN	
								SET @P_JOB_DATE = @var2+'01'
								SET @EXEC_STR = 
								'alter partition function srch_log_partfunc()
								SPLIT RANGE (''' + @P_JOB_DATE + ''');'
							 
							 EXECUTE (@EXEC_STR)
							 
							 /* prepares the partition scheme to add more partitions for the next time */
							 
							 ALTER PARTITION SCHEME srch_log_partscheme NEXT USED [PRIMARY];
						END
                     END
                  
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		 THROW
      END CATCH

	END	
	@go@
	
	/* create MS search LOG partitions */
	
	if exists (select * from sysobjects where name = 'WLF_MS_SRCHLOG_CREATE_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_MS_SRCHLOG_CREATE_PARTITION
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_MS_SRCHLOG_CREATE_PARTITION
	AS 
	BEGIN

      BEGIN TRY

         DECLARE
            @var1 varchar(8),
            @var2 varchar(8),
            @P_JOB_DATE varchar(10),
            @EXEC_STR varchar(1000)
  
                  BEGIN
                  
				 /* compares system next month to the last existing partition boundary and if not equal alters the partition function 
				 to include the next month */
					 
                      SELECT  @var1 = substring(max(CONVERT(VARCHAR(8),(sprv.value), 112)),1,6)  
						FROM sys.partition_functions AS spf 
						INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
						WHERE (spf.name=N'srch_log_ms_partfunc');
	
						select @var2 = substring(CONVERT(VARCHAR(8), DATEADD(MM,1,GETDATE()), 112),1,6);
						IF @var1 <> @var2
						BEGIN 
								SET @P_JOB_DATE = @var2+'01'
								SET @EXEC_STR = 
								'alter partition function srch_log_ms_partfunc()
								SPLIT RANGE (''' + @P_JOB_DATE + ''');'
							 
							 EXECUTE (@EXEC_STR)
							 
							 /* prepares the partition scheme to add more partitions for the next time */
							 
							 ALTER PARTITION SCHEME srch_log_ms_partscheme NEXT USED [PRIMARY];
						END
                     END
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		THROW

      END CATCH

	END	
	@go@
	
	/* PROCEDURE FOR SRCH LOG DROP OLD PARTITIONS */
	
	
	if exists (select * from sysobjects where name = 'WLF_SRCHLOG_DROP_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_SRCHLOG_DROP_PARTITION
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_SRCHLOG_DROP_PARTITION
	@P_JOB_DATE_PART varchar(8)
	
	AS	
	BEGIN
	  SET NOCOUNT ON;
      BEGIN TRY

         DECLARE
            @var1 datetime,
            @var2 varchar(10),
            @EXEC_STR varchar(1000),
			@PARTITION int
			
              SELECT @var1 = CAST( @P_JOB_DATE_PART as datetime);
              
			SELECT @PARTITION = $partition.srch_log_partfunc(@var1);
			
    
 		EXECUTE @env:lm_schema_name@.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = 'WLF_SRCH_LOG', @P_TABLE_NONPART = 'WLF_SRCH_LOG_TEMP', @PARTITION_NAME = @PARTITION
	
	
		SET @EXEC_STR = 'TRUNCATE TABLE @env:lm_schema_name@.' + 'WLF_SRCH_LOG_TEMP' + ';'
		EXECUTE (@EXEC_STR)
		ALTER PARTITION FUNCTION srch_log_partfunc() MERGE RANGE (@var1);
		
		
		END TRY

      BEGIN CATCH
		SELECT 
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;
		THROW
	
     END CATCH
	END
	RETURN

	@go@

	/* PROCEDURE FOR MS SRCH LOG DROP OLD PARTITIONS */
	
	if exists (select * from sysobjects where name = 'WLF_MS_SRCHLOG_DROP_PARTITION')
		drop procedure @env:lm_schema_name@.WLF_MS_SRCHLOG_DROP_PARTITION
	@go@
	
	create PROCEDURE @env:lm_schema_name@.WLF_MS_SRCHLOG_DROP_PARTITION
	@P_JOB_DATE_PART varchar(8)
	
	AS	
	BEGIN
	  SET NOCOUNT ON;
      BEGIN TRY

         DECLARE
            @var1 datetime,
            @var2 varchar(10),
            @EXEC_STR varchar(1000),
			@PARTITION int
			
              SELECT @var1 = CAST( @P_JOB_DATE_PART as datetime);
              
			SELECT @PARTITION = $partition.srch_log_ms_partfunc(@var1);
			
    
 		EXECUTE @env:lm_schema_name@.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = 'WLF_MESSAGE_SEARCH_LOG', @P_TABLE_NONPART = 'WLF_MS_SRCH_LOG_TEMP', @PARTITION_NAME = @PARTITION
	
	
		SET @EXEC_STR = 'TRUNCATE TABLE @env:lm_schema_name@.' + 'WLF_MS_SRCH_LOG_TEMP' + ';'
		EXECUTE (@EXEC_STR)
		ALTER PARTITION FUNCTION srch_log_ms_partfunc() MERGE RANGE (@var1);
		
		
		END TRY

      BEGIN CATCH
		SELECT 
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;

		THROW	
     END CATCH
	END
	RETURN

	@go@
	
	/* RL and SRCH LOG table maintenance */
	
	if exists (select * from sysobjects where name = 'WLF_SRCHLOG_RL_MAINT')
		drop procedure @env:lm_schema_name@.WLF_SRCHLOG_RL_MAINT
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_SRCHLOG_RL_MAINT
	@SRCH_LOG_DATE varchar(8)
	AS 
	BEGIN

      BEGIN TRY
         DECLARE
            @JOB_ID varchar(30),
            @SRCHLOG_DT varchar(8),
            @EXEC_STR varchar(1000),
            @var1 varchar(30),
			@var int,
			@v_count int
                  
	SET NOCOUNT ON;
	
	BEGIN
		DECLARE SRCH_LOG_CURSOR CURSOR LOCAL FOR 
		select  distinct JOB_ID
		from @env:lm_schema_name@.WLF_SRCH_LOG where JOB_TIMESTAMP < CAST(@SRCH_LOG_DATE as datetime) ;

		/* JOBS_LOG_CURSOR cleans up partitions older than input date in WLF_RL* tables which are not referenced by WLF_SRCH_LOG or WLF_MESSAGE_SEARCH_LOG */
        		DECLARE JOBS_LOG_CURSOR CURSOR LOCAL FOR
        		WITH q2 AS (
        					SELECT max(cast(Substring(JOB_ID, CHARINDEX('-',JOB_ID)+1,LEN(JOB_ID)-CHARINDEX('-',JOB_ID)) as numeric)) as max_val,
        						   Substring(max(JOB_ID), 1, CHARINDEX('-',max(JOB_ID))) as instance_val
        					FROM @env:lm_schema_name@.WLF_JOBS_LOG
        					WHERE JOB_TIMESTAMP < CAST(@SRCH_LOG_DATE as datetime)
        					)
        		SELECT q1.job_id
        		FROM
        			(
        			SELECT cast(Substring(cast(value as varchar), CHARINDEX('-',cast(value as varchar))+1,CHARINDEX('Z',cast(value as varchar))-CHARINDEX('-',cast(value as varchar))-1) as numeric) as val,
        			Substring(cast(value as varchar), 1, CHARINDEX('-',cast(value as varchar))) as inst_val,
        			value,
        			Substring(cast(value as varchar), 1, CHARINDEX('Z',cast(value as varchar))-1) as job_id
        			FROM sys.partition_range_values WHERE function_id=(SELECT function_id FROM sys.partition_functions WHERE name='rl_partfunc')
        			) as q1, q2
        		WHERE
        			q1.val <= q2.max_val
        			--AND q1.inst_val = q2.instance_val
        		ORDER BY 1

		DECLARE SRCHLOG_DT_CURSOR CURSOR LOCAL STATIC FOR 
		SELECT  CONVERT(VARCHAR(8),(sprv.value), 112) AS Value
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'srch_log_partfunc') and sprv.value < DATEADD(MM,1,CAST(@SRCH_LOG_DATE AS datetime))
            order by value desc;
		
	OPEN SRCH_LOG_CURSOR
	FETCH NEXT FROM SRCH_LOG_CURSOR 
	INTO @JOB_ID
	
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			SELECT @var1 = @JOB_ID + 'Z';
			
			SELECT  @var = COUNT(*) 
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'rl_partfunc') and sprv.value = @var1;

			if @var = 1
			
			BEGIN
			
			SET @EXEC_STR = 
                        'EXECUTE @env:lm_schema_name@.WLF_RL_DROP_PARTITION N'''+@JOB_ID+''';'
                     
                     EXECUTE (@EXEC_STR)
            END
			
			FETCH NEXT FROM SRCH_LOG_CURSOR 
			INTO @JOB_ID
    
		END
		 
	CLOSE SRCH_LOG_CURSOR;
	DEALLOCATE SRCH_LOG_CURSOR;
	
	OPEN JOBS_LOG_CURSOR
    	FETCH NEXT FROM JOBS_LOG_CURSOR
    	INTO @JOB_ID


    	WHILE @@FETCH_STATUS = 0
    			BEGIN

    			SELECT @v_count = (
    				(SELECT COUNT(JOB_ID) FROM WLF_SRCH_LOG WHERE JOB_ID = @JOB_ID)
    						+
    				(SELECT COUNT(JOB_ID) FROM WLF_MESSAGE_SEARCH_LOG WHERE JOB_ID = @JOB_ID)
    			)

    			if @v_count = 0
    				BEGIN

    					SELECT @var1 = @JOB_ID + 'Z';

    					SELECT  @var = COUNT(1)
    					FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id
    					WHERE (spf.name=N'rl_partfunc') and sprv.value = @var1;

    					if @var = 1

    					BEGIN

    					SET @EXEC_STR =
    								'EXECUTE @env:lm_schema_name@.WLF_RL_DROP_PARTITION N'''+@JOB_ID+''';'

    							EXECUTE (@EXEC_STR)
    					END

    				END

    				FETCH NEXT FROM JOBS_LOG_CURSOR
    				INTO @JOB_ID

    			END

    	CLOSE JOBS_LOG_CURSOR;
    	DEALLOCATE JOBS_LOG_CURSOR;

    OPEN SRCHLOG_DT_CURSOR
	FETCH NEXT FROM SRCHLOG_DT_CURSOR 
	INTO @SRCHLOG_DT
	
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @SRCHLOG_DT <>'19800101'
			BEGIN
				SET @EXEC_STR = 'EXECUTE @env:lm_schema_name@.WLF_SRCHLOG_DROP_PARTITION N'''+@SRCHLOG_DT+''';'

				EXECUTE (@EXEC_STR)
			END
			
			FETCH NEXT FROM SRCHLOG_DT_CURSOR 
			INTO @SRCHLOG_DT
    
		END
		 
	CLOSE SRCHLOG_DT_CURSOR;
	DEALLOCATE SRCHLOG_DT_CURSOR;
	END 
     
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		THROW
      END CATCH

	END
	@go@
	
	/* MS RL and MS SRCH LOG table maintenance */
	if exists (select * from sysobjects where name = 'WLF_MS_SRCHLOG_RL_MAINT')
		drop procedure @env:lm_schema_name@.WLF_MS_SRCHLOG_RL_MAINT
	@go@
	
	CREATE PROCEDURE @env:lm_schema_name@.WLF_MS_SRCHLOG_RL_MAINT
	@SRCH_LOG_DATE varchar(8)
	AS 
	BEGIN

      BEGIN TRY
         DECLARE
            @JOB_ID varchar(30),
            @SRCHLOG_DT varchar(8),
            @EXEC_STR varchar(1000),
			@EXEC_STR1 varchar(1000),
			@var2 varchar(30),
			@var int,
			@var1 int
                  
	SET NOCOUNT ON;
	
	BEGIN
		DECLARE SRCH_LOG_CURSOR CURSOR LOCAL FOR 
		select  distinct JOB_ID
		from @env:lm_schema_name@.WLF_MESSAGE_SEARCH_LOG where JOB_TIMESTAMP < CAST(@SRCH_LOG_DATE as datetime) ;
		
		DECLARE SRCHLOG_DT_CURSOR CURSOR LOCAL STATIC FOR 
		SELECT  CONVERT(VARCHAR(8),(sprv.value), 112) AS Value
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'srch_log_ms_partfunc') and sprv.value < DATEADD(MM,1,CAST(@SRCH_LOG_DATE AS datetime));
		
	OPEN SRCH_LOG_CURSOR
	FETCH NEXT FROM SRCH_LOG_CURSOR 
	INTO @JOB_ID
	
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			SELECT @var2 = @JOB_ID + 'Z';
			
			SELECT  @var = COUNT(*) 
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'rl_ms_partfunc') and sprv.value = @var2;

			if @var = 1
			
			BEGIN
			
			SET @EXEC_STR = 
                        'EXECUTE @env:lm_schema_name@.WLF_RL_MS_DROP_PARTITION N'''+@JOB_ID+''';'
                     
                     EXECUTE (@EXEC_STR)
            END
			 
			SELECT  @var1 = COUNT(*) 
            FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
            WHERE (spf.name=N'rl_partfunc') and sprv.value = @var2;

			if @var1 = 1
			
			BEGIN
			
			SET @EXEC_STR1 = 
                        'EXECUTE @env:lm_schema_name@.WLF_RL_DROP_PARTITION N'''+@JOB_ID+''';'
                     
                     EXECUTE (@EXEC_STR1)
			END		 
			
			FETCH NEXT FROM SRCH_LOG_CURSOR 
			INTO @JOB_ID
    
		END
		 
	CLOSE SRCH_LOG_CURSOR;
	DEALLOCATE SRCH_LOG_CURSOR;
	
	
    OPEN SRCHLOG_DT_CURSOR
	FETCH NEXT FROM SRCHLOG_DT_CURSOR 
	INTO @SRCHLOG_DT
	
	
	WHILE @@FETCH_STATUS = 0
		BEGIN
			IF @SRCHLOG_DT <>'19800101'
			BEGIN
				SET @EXEC_STR = 
					'EXECUTE @env:lm_schema_name@.WLF_MS_SRCHLOG_DROP_PARTITION N'''+@SRCHLOG_DT+''';'
				EXECUTE (@EXEC_STR)
			END
			FETCH NEXT FROM SRCHLOG_DT_CURSOR 
			INTO @SRCHLOG_DT
    
		END
		 
	CLOSE SRCHLOG_DT_CURSOR;
	DEALLOCATE SRCHLOG_DT_CURSOR;
	END 
     
      END TRY

      BEGIN CATCH
         
         SELECT 
		 ERROR_NUMBER() AS ErrorNumber
		,ERROR_SEVERITY() AS ErrorSeverity
		,ERROR_STATE() AS ErrorState
		,ERROR_PROCEDURE() AS ErrorProcedure
		,ERROR_LINE() AS ErrorLine
		,ERROR_MESSAGE() AS ErrorMessage;
		THROW

      END CATCH

	END	
	@go@
	
]



[oracle

	/* ------------------------------------------------------------ */
	/* create RL partitions	procedure			 */
	/* ------------------------------------------------------------ */

    CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_SRCHLOG_RL_MAINT
    (
        P_PURGE_DATE VARCHAR2
    )
    AS
        V_PURGE_DATE DATE;
        V_EXEC_STR VARCHAR2(4000);
        V_DATE_VAL VARCHAR2(200);
        V_COUNT NUMBER;

    BEGIN

        V_PURGE_DATE := TO_DATE(P_PURGE_DATE, 'yyyymmdd');

        /********* Step 1 - Drop partitions older than input date from WLF_RL* tables (partitioned by LIST(JOB_ID)) which are referenced from WLF_SRCH_LOG table */
        FOR REC IN (
            SELECT DISTINCT JOB_ID
            FROM WLF_SRCH_LOG
            WHERE JOB_TIMESTAMP < V_PURGE_DATE
        )
        LOOP

            --DBMS_OUTPUT.PUT_LINE('WLF_RL_DROP_PARTITION(''' || REC.JOB_ID || ''')');
            WLF_RL_DROP_PARTITION(REC.JOB_ID);

        END LOOP;

        /********* Step 2 - Drop partitions older than input date from WLF_SRCH_LOG - partitioned by RANGE(JOB_TIMESTAMP), MONTHLY INTERVAL */
        FOR REC IN (
            SELECT HIGH_VALUE, PARTITION_NAME
            FROM USER_TAB_PARTITIONS p
            WHERE TABLE_NAME = 'WLF_SRCH_LOG'
                AND PARTITION_NAME <> 'PER0'
        )
        LOOP
            BEGIN

                EXECUTE IMMEDIATE ('SELECT ' || REC.HIGH_VALUE || ' FROM DUAL') INTO V_DATE_VAL;

                IF (V_DATE_VAL <= V_PURGE_DATE) THEN
                    V_EXEC_STR := 'ALTER TABLE @env:lm_schema_name@.WLF_SRCH_LOG DROP PARTITION ' || REC.PARTITION_NAME;
                    --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                    EXECUTE IMMEDIATE V_EXEC_STR;
                END IF;

                EXCEPTION WHEN OTHERS THEN
                    IF SQLCODE = -14083 THEN
                        NULL;
                        --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR);
                    ELSIF SQLCODE = -54 THEN
                        --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
                        DBMS_LOCK.SLEEP(10);
                        --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                        EXECUTE IMMEDIATE (V_EXEC_STR);
                    ELSE
                        RAISE_APPLICATION_ERROR(-20001,'Error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
                    END IF;
            END;
        END LOOP;

        /********** Step 3 - Delete the records from WLF_SRCH_LOG older than input date for the month input date belongs to, we can't drop the whole partition */
        --DBMS_OUTPUT.PUT_LINE('DELETE FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < ' || V_PURGE_DATE);
        DELETE FROM WLF_SRCH_LOG
        WHERE JOB_TIMESTAMP < V_PURGE_DATE;

        COMMIT;

        /********** Step 4 - Maintenance clean up in case there are partitions older than input date in WLF_RL* tables which are not referenced by WLF_SRCH_LOG or WLF_MESSAGE_SEARCH_LOG */
        FOR REC IN (
            SELECT DISTINCT SUBSTR(REPLACE(part.partition_name, '_','-'), 2) as JOB_ID, TABLE_NAME, PARTITION_NAME
            FROM USER_TAB_PARTITIONS part,
                USER_OBJECTS obj
            WHERE part.TABLE_NAME LIKE 'WLF_RL%'
                AND part.TABLE_NAME NOT LIKE 'WLF_RL_MESSAGE%'
                AND part.PARTITION_NAME <> 'P0'
                AND part.TABLE_NAME = obj.OBJECT_NAME
                AND part.PARTITION_NAME = obj.SUBOBJECT_NAME
                AND obj.OBJECT_TYPE = 'TABLE PARTITION'
                AND obj.CREATED < V_PURGE_DATE
        )
        LOOP
            BEGIN
                /********** Check if partition is referenced by parent LOG tables */
                SELECT (
                    (SELECT COUNT(*)
                    FROM WLF_SRCH_LOG
                    WHERE REC.JOB_ID = JOB_ID)
                    +
                    (SELECT COUNT(*)
                    FROM WLF_MESSAGE_SEARCH_LOG
                    WHERE REC.JOB_ID = JOB_ID)
                    )
                INTO V_COUNT
                FROM DUAL;

                IF(V_COUNT = 0) THEN
                    V_EXEC_STR := 'ALTER TABLE @env:lm_schema_name@.' || REC.TABLE_NAME || ' drop partition ' || REC.PARTITION_NAME;
                    --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                    EXECUTE IMMEDIATE (V_EXEC_STR);
                END IF;

            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE = -14083 THEN
                        NULL;
                        --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR);
                    ELSIF SQLCODE = -13117 THEN
                        NULL;
                        --DBMS_OUTPUT.PUT_LINE('ORA - 13117: ' || SQLERRM || ', query: ' || V_EXEC_STR);
                    ELSIF SQLCODE = -54 THEN
                        --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
                        DBMS_LOCK.SLEEP(10);
                        --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                        EXECUTE IMMEDIATE (V_EXEC_STR);
                    ELSE
                        RAISE_APPLICATION_ERROR(-20001,'Error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
                    END IF;
            END;
        END LOOP;

        /********** Step 5 - Rebuild Invalid/Unused Indexes after dropping */
        FOR REC IN (
            SELECT DISTINCT TABLE_NAME
            FROM USER_TAB_PARTITIONS
            WHERE TABLE_NAME LIKE 'WLF_RL%'
                AND TABLE_NAME NOT LIKE 'WLF_RL_MESSAGE%'
        )
        LOOP
            --DBMS_OUTPUT.PUT_LINE('WLF_REBUILD_INDEXES(''' || REC.TABLE_NAME || ''')');
            WLF_REBUILD_INDEXES(REC.TABLE_NAME);
        END LOOP;

        --DBMS_OUTPUT.PUT_LINE('WLF_REBUILD_INDEXES(''WLF_SRCH_LOG'')');
        WLF_REBUILD_INDEXES('WLF_SRCH_LOG');

        --DBMS_OUTPUT.PUT_LINE('ALTER TABLE WLF_SRCH_LOG SET INTERVAL(NUMTOYMINTERVAL(1,''MONTH''))');
        --EXECUTE IMMEDIATE('ALTER TABLE WLF_SRCH_LOG SET INTERVAL(NUMTOYMINTERVAL(1,''MONTH''))');

    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20001,'Error while running search log maintenance for date: ' || P_PURGE_DATE || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
    END;
	@go@

	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_MS_SRCHLOG_RL_MAINT ( SRCH_LOG_DATE VARCHAR2 )
	AS
	
	CURSOR	SRCHLOG_JOBID_SET IS
	select  distinct JOB_ID
		from @env:lm_schema_name@.WLF_MESSAGE_SEARCH_LOG where JOB_TIMESTAMP < to_date(SRCH_LOG_DATE, 'yyyymmdd');
	
	CURSOR SRCHLOG_DT_SET IS
	SELECT HIGH_VALUE,PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE PARTITION_NAME IN (
	WITH   PARTS AS
		 (SELECT --+ MATERIALIZE
					data_object_id,
					 SUBOBJECT_NAME
		   FROM   USER_OBJECTS
		  WHERE  OBJECT_NAME = 'WLF_MESSAGE_SEARCH_LOG' AND
				  OBJECT_TYPE = 'TABLE PARTITION')
	SELECT DISTINCT SUBOBJECT_NAME
	FROM @env:lm_schema_name@.WLF_MESSAGE_SEARCH_LOG,
		PARTS
	WHERE  JOB_TIMESTAMP < TO_DATE(SRCH_LOG_DATE,'YYYYMMDD')
	and data_object_id = DBMS_MView.PMarker(WLF_MESSAGE_SEARCH_LOG.rowid));
	   
	SRCHLOG_JOBID	SRCHLOG_JOBID_SET%ROWTYPE;
	SRCHLOG_DT	SRCHLOG_DT_SET%ROWTYPE;
	
	EXEC_STR_RL		VARCHAR2(1000);
	EXEC_STR_RL2	VARCHAR2(1000);
	EXEC_STR		VARCHAR2(1000);
	TEMP_CRT_TABL_CMD VARCHAR2(1000);
	TEMP_DRP_TABL_CMD VARCHAR2(1000);
	TEMP_PRIMARY_KEY VARCHAR2(1000);
  	TEMP_DROP_UNUSED VARCHAR2(1000);
  	EXEC_STR_ADD_COL VARCHAR2(1000);
    EXEC_STR_UPDATE_COL VARCHAR2(1000);
    EXEC_STR_DROP_COL VARCHAR2(1000);
    EXEC_STR_RENAME_COL VARCHAR2(1000);
    EXEC_STR_INVIS VARCHAR2(5000);
    EXEC_STR_VIS VARCHAR2(5000);
	EXCHG_TABL_CMD VARCHAR2(2000);
	DRP_PART_CMD VARCHAR2(2000);
	P_PART_NAME VARCHAR2(30);
	TOT_PREV_PART_COUNT NUMBER;
	MESG_COL_CNT NUMBER;
	TEMP_COL_CNT NUMBER;
		
	PART_NOT_EXISTS EXCEPTION;
	PRAGMA EXCEPTION_INIT(PART_NOT_EXISTS,-02149);
	C1_HIGH_VALUE VARCHAR2(4000);
	C1_DATE_VAL VARCHAR2(200);
	DRP_MSG_LOG_TABL VARCHAR2(4000);
		
	BEGIN
		SELECT COUNT(*) INTO MESG_COL_CNT FROM all_tab_cols WHERE table_name = 'WLF_RL_MESSAGE' AND owner = '@env:lm_schema_name@';
		TEMP_CRT_TABL_CMD := ' CREATE TABLE TEMP_MSG AS SELECT * FROM WLF_RL_MESSAGE WHERE 1 = 0';
		TEMP_DRP_TABL_CMD := ' DROP TABLE TEMP_MSG CASCADE CONSTRAINTS';
		/* These next two commands are done in order to get the temp_msg table to be similiar enough to the
		    WLF_RL_MESSAGE table that the exchange partition command will succeed. The Oracle error that this
		    fixes is ORA-14097: column type or size mismatch in ALTER TABLE EXCHANGE PARTITION. The idea is to remove unused columns if they are present. Adding unused columns create problems*/
		TEMP_PRIMARY_KEY := ' ALTER TABLE temp_msg ADD PRIMARY KEY(id,instance_id,job_id)';
    	TEMP_DROP_UNUSED := ' ALTER TABLE WLF_RL_MESSAGE DROP UNUSED COLUMNS';
    	EXEC_STR_ADD_COL := 'ALTER TABLE TEMP_MSG ADD MESSAGE_REF_NUMBER_1 varchar2(255)';
        EXEC_STR_UPDATE_COL := 'UPDATE TEMP_MSG SET MESSAGE_REF_NUMBER_1 = MESSAGE_REF_NUMBER';
        EXEC_STR_DROP_COL := 'ALTER table TEMP_MSG DROP COLUMN MESSAGE_REF_NUMBER';
        EXEC_STR_RENAME_COL := 'ALTER TABLE TEMP_MSG RENAME COLUMN MESSAGE_REF_NUMBER_1 TO MESSAGE_REF_NUMBER';
        EXEC_STR_INVIS := 'ALTER TABLE TEMP_MSG modify (
        MESSAGE_SOURCE_TYPE INVISIBLE,
        MESSAGE_TYPE_CD INVISIBLE,
        MESSAGE_DATE_TIME INVISIBLE,
        AMOUNT INVISIBLE,
        CURRENCY_CD INVISIBLE,
        PRODUCT_KEY INVISIBLE,
        MESSAGE_DIRECTION INVISIBLE,
        MESSAGE_INSTRUCTIONS INVISIBLE,
        ADDITIONAL_MESSAGE_TEXT INVISIBLE,
        MESSAGE_TEXT INVISIBLE,
        ORIGINATOR_NAME INVISIBLE,
        ORIGINATOR_PARTY_IDS INVISIBLE,
        ORIGINATOR_ADDRESS_LINE_1 INVISIBLE,
        ORIGINATOR_ADDRESS_LINE_2 INVISIBLE,
        ORIGINATOR_ADDRESS_LINE_3 INVISIBLE,
        ORIGINATOR_CITY INVISIBLE,
        ORIGINATOR_COUNTRY_CD INVISIBLE,
        ORIGINATOR_PARTY_TYPE_CD INVISIBLE,
        ORIGINATOR_PO_BOX INVISIBLE,
        ORIGINATOR_STATE_PROVINCE INVISIBLE,
        ORIGINATOR_ZIP_CD INVISIBLE,
        ORIGINATOR_ADDITIONAL_INFO INVISIBLE,
        ORIGINATING_FI_CD INVISIBLE,
        ORIGINATING_FI_COUNTRY_CD INVISIBLE,
        ORIGINATING_FI_ORG_NAME INVISIBLE,
        BENEFICIARY_PRIMARY_NAME INVISIBLE,
        BENEFICIARY_PARTY_IDS INVISIBLE,
        BENEFICIARY_ADDRESS_LINE_1 INVISIBLE,
        BENEFICIARY_ADDRESS_LINE_2 INVISIBLE,
        BENEFICIARY_ADDRESS_LINE_3 INVISIBLE,
        BENEFICIARY_PO_BOX INVISIBLE,
        BENEFICIARY_CITY INVISIBLE,
        BENEFICIARY_STATE_PROVINCE INVISIBLE,
        BENEFICIARY_ZIP_CD INVISIBLE,
        BENEFICIARY_COUNTRY_CD INVISIBLE,
        BENEFICIARY_ADDITIONAL_INFO INVISIBLE,
        BENEFICIARY_FI_ORG_NAME INVISIBLE,
        BENEFICIARY_FI_CD INVISIBLE,
        BENEFICIARY_FI_PARTY_TYPE_CD INVISIBLE,
        BENEFICIARY_FI_COUNTRY_CD INVISIBLE,
        RECEIVING_FI_ADDITIONAL_INFO INVISIBLE,
        RECEIVING_FI_CD INVISIBLE,
        RECEIVING_FI_COUNTRY_CD INVISIBLE,
        RECEIVING_FI_ORGANIZATION_NAME INVISIBLE,
        SENDING_FI_ADDITIONAL_INFO INVISIBLE,
        SENDING_FI_CD INVISIBLE,
        SENDING_FI_COUNTRY_CD INVISIBLE,
        SENDING_FI_ORGANIZATION_NAME INVISIBLE,
        FI_TO_FI_INFO INVISIBLE,
        CUSTOM_FIELD1 INVISIBLE,
        CUSTOM_FIELD2 INVISIBLE,
        CUSTOM_FIELD3 INVISIBLE,
        CUSTOM_FIELD4 INVISIBLE,
        CUSTOM_FIELD5 INVISIBLE,
        CUSTOM_FIELD6 INVISIBLE,
        CUSTOM_FIELD7 INVISIBLE,
        CUSTOM_FIELD8 INVISIBLE,
        CUSTOM_FIELD9 INVISIBLE,
        CUSTOM_FIELD10 INVISIBLE,
        CUSTOM_FIELD11 INVISIBLE,
        CUSTOM_FIELD12 INVISIBLE,
        CUSTOM_FIELD13 INVISIBLE,
        CUSTOM_FIELD14 INVISIBLE,
        CUSTOM_FIELD15 INVISIBLE,
        CUSTOM_FIELD16 INVISIBLE,
        CUSTOM_FIELD17 INVISIBLE,
        CUSTOM_FIELD18 INVISIBLE,
        CUSTOM_FIELD19 INVISIBLE,
        CUSTOM_FIELD20 INVISIBLE,
        CUSTOM_STRING_21 INVISIBLE,
        CUSTOM_STRING_22 INVISIBLE,
        CUSTOM_STRING_23 INVISIBLE,
        CUSTOM_STRING_24 INVISIBLE,
        CUSTOM_STRING_25 INVISIBLE,
        CUSTOM_STRING_26 INVISIBLE,
        CUSTOM_STRING_27 INVISIBLE,
        CUSTOM_STRING_28 INVISIBLE,
        CUSTOM_STRING_29 INVISIBLE,
        CUSTOM_STRING_30 INVISIBLE,
        CUSTOM_STRING_31 INVISIBLE,
        CUSTOM_STRING_32 INVISIBLE,
        CUSTOM_STRING_33 INVISIBLE,
        CUSTOM_STRING_34 INVISIBLE,
        CUSTOM_STRING_35 INVISIBLE,
        CUSTOM_STRING_36 INVISIBLE,
        CUSTOM_STRING_37 INVISIBLE,
        CUSTOM_STRING_38 INVISIBLE,
        CUSTOM_STRING_39 INVISIBLE,
        CUSTOM_STRING_40 INVISIBLE,
        CUSTOM_DATE_6 INVISIBLE,
        CUSTOM_DATE_7 INVISIBLE,
        CUSTOM_DATE_8 INVISIBLE,
        CUSTOM_DATE_9 INVISIBLE,
        CUSTOM_DATE_10 INVISIBLE,
        CUSTOM_DATE_11 INVISIBLE,
        CUSTOM_DATE_12 INVISIBLE,
        CUSTOM_DATE_13 INVISIBLE,
        CUSTOM_DATE_14 INVISIBLE,
        CUSTOM_DATE_15 INVISIBLE,
        CUSTOM_BOOLEAN_6 INVISIBLE,
        CUSTOM_BOOLEAN_7 INVISIBLE,
        CUSTOM_BOOLEAN_8 INVISIBLE,
        CUSTOM_BOOLEAN_9 INVISIBLE,
        CUSTOM_BOOLEAN_10 INVISIBLE,
        CUSTOM_NUMBER_1 INVISIBLE,
        CUSTOM_NUMBER_2 INVISIBLE,
        CUSTOM_NUMBER_3 INVISIBLE,
        CUSTOM_NUMBER_4 INVISIBLE,
        CUSTOM_NUMBER_5 INVISIBLE
        )';

        EXEC_STR_VIS := 'ALTER TABLE TEMP_MSG modify (
        MESSAGE_SOURCE_TYPE VISIBLE,
        MESSAGE_TYPE_CD VISIBLE,
        MESSAGE_DATE_TIME VISIBLE,
        AMOUNT VISIBLE,
        CURRENCY_CD VISIBLE,
        PRODUCT_KEY VISIBLE,
        MESSAGE_DIRECTION VISIBLE,
        MESSAGE_INSTRUCTIONS VISIBLE,
        ADDITIONAL_MESSAGE_TEXT VISIBLE,
        MESSAGE_TEXT VISIBLE,
        ORIGINATOR_NAME VISIBLE,
        ORIGINATOR_PARTY_IDS VISIBLE,
        ORIGINATOR_ADDRESS_LINE_1 VISIBLE,
        ORIGINATOR_ADDRESS_LINE_2 VISIBLE,
        ORIGINATOR_ADDRESS_LINE_3 VISIBLE,
        ORIGINATOR_CITY VISIBLE,
        ORIGINATOR_COUNTRY_CD VISIBLE,
        ORIGINATOR_PARTY_TYPE_CD VISIBLE,
        ORIGINATOR_PO_BOX VISIBLE,
        ORIGINATOR_STATE_PROVINCE VISIBLE,
        ORIGINATOR_ZIP_CD VISIBLE,
        ORIGINATOR_ADDITIONAL_INFO VISIBLE,
        ORIGINATING_FI_CD VISIBLE,
        ORIGINATING_FI_COUNTRY_CD VISIBLE,
        ORIGINATING_FI_ORG_NAME VISIBLE,
        BENEFICIARY_PRIMARY_NAME VISIBLE,
        BENEFICIARY_PARTY_IDS VISIBLE,
        BENEFICIARY_ADDRESS_LINE_1 VISIBLE,
        BENEFICIARY_ADDRESS_LINE_2 VISIBLE,
        BENEFICIARY_ADDRESS_LINE_3 VISIBLE,
        BENEFICIARY_PO_BOX VISIBLE,
        BENEFICIARY_CITY VISIBLE,
        BENEFICIARY_STATE_PROVINCE VISIBLE,
        BENEFICIARY_ZIP_CD VISIBLE,
        BENEFICIARY_COUNTRY_CD VISIBLE,
        BENEFICIARY_ADDITIONAL_INFO VISIBLE,
        BENEFICIARY_FI_ORG_NAME VISIBLE,
        BENEFICIARY_FI_CD VISIBLE,
        BENEFICIARY_FI_PARTY_TYPE_CD VISIBLE,
        BENEFICIARY_FI_COUNTRY_CD VISIBLE,
        RECEIVING_FI_ADDITIONAL_INFO VISIBLE,
        RECEIVING_FI_CD VISIBLE,
        RECEIVING_FI_COUNTRY_CD VISIBLE,
        RECEIVING_FI_ORGANIZATION_NAME VISIBLE,
        SENDING_FI_ADDITIONAL_INFO VISIBLE,
        SENDING_FI_CD VISIBLE,
        SENDING_FI_COUNTRY_CD VISIBLE,
        SENDING_FI_ORGANIZATION_NAME VISIBLE,
        FI_TO_FI_INFO VISIBLE,
        CUSTOM_FIELD1 VISIBLE,
        CUSTOM_FIELD2 VISIBLE,
        CUSTOM_FIELD3 VISIBLE,
        CUSTOM_FIELD4 VISIBLE,
        CUSTOM_FIELD5 VISIBLE,
        CUSTOM_FIELD6 VISIBLE,
        CUSTOM_FIELD7 VISIBLE,
        CUSTOM_FIELD8 VISIBLE,
        CUSTOM_FIELD9 VISIBLE,
        CUSTOM_FIELD10 VISIBLE,
        CUSTOM_FIELD11 VISIBLE,
        CUSTOM_FIELD12 VISIBLE,
        CUSTOM_FIELD13 VISIBLE,
        CUSTOM_FIELD14 VISIBLE,
        CUSTOM_FIELD15 VISIBLE,
        CUSTOM_FIELD16 VISIBLE,
        CUSTOM_FIELD17 VISIBLE,
        CUSTOM_FIELD18 VISIBLE,
        CUSTOM_FIELD19 VISIBLE,
        CUSTOM_FIELD20 VISIBLE,
        CUSTOM_STRING_21 VISIBLE,
        CUSTOM_STRING_22 VISIBLE,
        CUSTOM_STRING_23 VISIBLE,
        CUSTOM_STRING_24 VISIBLE,
        CUSTOM_STRING_25 VISIBLE,
        CUSTOM_STRING_26 VISIBLE,
        CUSTOM_STRING_27 VISIBLE,
        CUSTOM_STRING_28 VISIBLE,
        CUSTOM_STRING_29 VISIBLE,
        CUSTOM_STRING_30 VISIBLE,
        CUSTOM_STRING_31 VISIBLE,
        CUSTOM_STRING_32 VISIBLE,
        CUSTOM_STRING_33 VISIBLE,
        CUSTOM_STRING_34 VISIBLE,
        CUSTOM_STRING_35 VISIBLE,
        CUSTOM_STRING_36 VISIBLE,
        CUSTOM_STRING_37 VISIBLE,
        CUSTOM_STRING_38 VISIBLE,
        CUSTOM_STRING_39 VISIBLE,
        CUSTOM_STRING_40 VISIBLE,
        CUSTOM_DATE_6 VISIBLE,
        CUSTOM_DATE_7 VISIBLE,
        CUSTOM_DATE_8 VISIBLE,
        CUSTOM_DATE_9 VISIBLE,
        CUSTOM_DATE_10 VISIBLE,
        CUSTOM_DATE_11 VISIBLE,
        CUSTOM_DATE_12 VISIBLE,
        CUSTOM_DATE_13 VISIBLE,
        CUSTOM_DATE_14 VISIBLE,
        CUSTOM_DATE_15 VISIBLE,
        CUSTOM_BOOLEAN_6 VISIBLE,
        CUSTOM_BOOLEAN_7 VISIBLE,
        CUSTOM_BOOLEAN_8 VISIBLE,
        CUSTOM_BOOLEAN_9 VISIBLE,
        CUSTOM_BOOLEAN_10 VISIBLE,
        CUSTOM_NUMBER_1 VISIBLE,
        CUSTOM_NUMBER_2 VISIBLE,
        CUSTOM_NUMBER_3 VISIBLE,
        CUSTOM_NUMBER_4 VISIBLE,
        CUSTOM_NUMBER_5 VISIBLE
        )';
			
		FOR TMP_TAB IN (SELECT 1 FROM USER_TABLES WHERE TABLE_NAME ='TEMP_MSG')
		LOOP
			EXECUTE IMMEDIATE (TEMP_DRP_TABL_CMD);
		END LOOP;	
					
		OPEN SRCHLOG_JOBID_SET;
	
		LOOP
			
			FETCH SRCHLOG_JOBID_SET INTO SRCHLOG_JOBID;
			EXIT WHEN SRCHLOG_JOBID_SET%NOTFOUND;
			P_PART_NAME := 'P' || rtrim(substr(SRCHLOG_JOBID.JOB_ID,1,2)) || '_' || rtrim(substr(SRCHLOG_JOBID.JOB_ID,4,10));
			/* 	Drop MS Partitions one by one */
				
			WLF_CHECK_TOTAL_PART('WLF_RL_MESSAGE',TOT_PREV_PART_COUNT);
			IF(TOT_PREV_PART_COUNT > 1) 
			THEN
					-- DBMS_OUTPUT.PUT_LINE(' WLF_RL_MESAGE_TBLE WORK');
				FOR TMP_TAB IN (SELECT count(*) AS CNT FROM USER_TABLES WHERE TABLE_NAME ='TEMP_MSG')
					LOOP
						IF (TMP_TAB.CNT = 0) 
						THEN
							EXECUTE IMMEDIATE (TEMP_CRT_TABL_CMD);
							EXECUTE IMMEDIATE (TEMP_PRIMARY_KEY);
							EXECUTE IMMEDIATE (EXEC_STR_ADD_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_UPDATE_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_DROP_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_RENAME_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_INVIS);
                            EXECUTE IMMEDIATE (EXEC_STR_VIS);
							SELECT COUNT(*) INTO TEMP_COL_CNT FROM all_tab_cols WHERE table_name = 'TEMP_MSG' AND owner = '@env:lm_schema_name@';
            				IF (MESG_COL_CNT > TEMP_COL_CNT) THEN
           						EXECUTE IMMEDIATE (TEMP_DROP_UNUSED);
           					END IF;
							--DBMS_OUTPUT.PUT_LINE(TEMP_CRT_TABL_CMD);
						ELSIF (TMP_TAB.CNT = 1 ) 
						THEN
							EXECUTE IMMEDIATE (TEMP_DRP_TABL_CMD);
							--DBMS_OUTPUT.PUT_LINE(TEMP_DRP_TABL_CMD);
							EXECUTE IMMEDIATE (TEMP_CRT_TABL_CMD);
							EXECUTE IMMEDIATE (TEMP_PRIMARY_KEY);
							EXECUTE IMMEDIATE (EXEC_STR_ADD_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_UPDATE_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_DROP_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_RENAME_COL);
                            EXECUTE IMMEDIATE (EXEC_STR_INVIS);
                            EXECUTE IMMEDIATE (EXEC_STR_VIS);
							SELECT COUNT(*) INTO TEMP_COL_CNT FROM all_tab_cols WHERE table_name = 'TEMP_MSG' AND owner = '@env:lm_schema_name@';
            				IF (MESG_COL_CNT > TEMP_COL_CNT) THEN
           						EXECUTE IMMEDIATE (TEMP_DROP_UNUSED);
           					END IF;
							--DBMS_OUTPUT.PUT_LINE(TEMP_CRT_TABL_CMD);
						END IF;
				END LOOP;	
			
				EXCHG_TABL_CMD := 'ALTER TABLE WLF_RL_MESSAGE EXCHANGE PARTITION ' || P_PART_NAME || ' WITH TABLE TEMP_MSG WITHOUT VALIDATION';
				DRP_PART_CMD := ' ALTER TABLE WLF_RL_MESSAGE DROP PARTITION ' || P_PART_NAME ;
					
				BEGIN
					--DBMS_OUTPUT.PUT_LINE(EXCHG_TABL_CMD);
					EXECUTE IMMEDIATE (EXCHG_TABL_CMD);
						
					--DBMS_OUTPUT.PUT_LINE(DRP_PART_CMD);
					EXECUTE IMMEDIATE (DRP_PART_CMD);
						
					WLF_REBUILD_INDEXES('WLF_RL_MESSAGE');
						
					--DBMS_OUTPUT.PUT_LINE(TEMP_DRP_TABL_CMD);
					EXECUTE IMMEDIATE (TEMP_DRP_TABL_CMD);
						
					--DBMS_OUTPUT.PUT_LINE(TEMP_CRT_TABL_CMD);
					EXECUTE IMMEDIATE (TEMP_CRT_TABL_CMD);
					EXCEPTION
						WHEN PART_NOT_EXISTS THEN 
						NULL;
				END;
					
			ELSE
				DRP_PART_CMD := 'ALTER TABLE WLF_RL_MESSAGE TRUNCATE PARTITION ' || P_PART_NAME;
				EXECUTE IMMEDIATE (DRP_PART_CMD);
				FOR INDX_NAME IN ( SELECT INDEX_NAME FROM USER_INDEXES WHERE TABLE_NAME = 'WLF_RL_MESSAGE' )
				LOOP
					EXECUTE IMMEDIATE ('ALTER INDEX ' || INDX_NAME.INDEX_NAME || ' REBUILD ');
				END LOOP;
			END IF;
				
			WLF_REBUILD_INDEXES('WLF_RL_MESSAGE');
				
			TOT_PREV_PART_COUNT := 0;
			WLF_CHECK_TOTAL_PART('WLF_RL_MESSAGE_INTERMEDIATE_FI',TOT_PREV_PART_COUNT);
			
			IF(TOT_PREV_PART_COUNT > 1) 
			THEN
				--DBMS_OUTPUT.PUT_LINE(' WLF_RL_MESSAGE_INTERMEDIATE_FI WORK');
				DRP_PART_CMD := ' ALTER TABLE WLF_RL_MESSAGE_INTERMEDIATE_FI DROP PARTITION ' || P_PART_NAME ;
				BEGIN
					EXECUTE IMMEDIATE (DRP_PART_CMD);
					EXCEPTION
						WHEN PART_NOT_EXISTS THEN
							NULL;
				END;
			ELSE
				DRP_PART_CMD := 'ALTER TABLE WLF_RL_MESSAGE_INTERMEDIATE_FI TRUNCATE PARTITION ' || P_PART_NAME;
				EXECUTE IMMEDIATE (DRP_PART_CMD);
			END IF;
				
			TOT_PREV_PART_COUNT := 0;
			WLF_CHECK_TOTAL_PART('WLF_RL_MESSAGE_HIT',TOT_PREV_PART_COUNT);
			IF(TOT_PREV_PART_COUNT > 1) 
			THEN
				--DBMS_OUTPUT.PUT_LINE(' WLF_RL_MESSAGE_HIT WORK');
				DRP_PART_CMD := ' ALTER TABLE WLF_RL_MESSAGE_HIT DROP PARTITION ' || P_PART_NAME ;
				BEGIN
					EXECUTE IMMEDIATE (DRP_PART_CMD);
					EXCEPTION
						WHEN PART_NOT_EXISTS THEN
							NULL;
				END;
			ELSE
				DRP_PART_CMD := 'ALTER TABLE WLF_RL_MESSAGE_HIT TRUNCATE PARTITION ' || P_PART_NAME;
				EXECUTE IMMEDIATE (DRP_PART_CMD);
			END IF;
	
			EXEC_STR_RL2 := 'call @env:lm_schema_name@.WLF_RL_DROP_PARTITION(''' || SRCHLOG_JOBID.JOB_ID || ''')';
			EXECUTE IMMEDIATE (EXEC_STR_RL2);
		 --DBMS_OUTPUT.put_line (EXEC_STR_RL2);
		END LOOP;
		CLOSE SRCHLOG_JOBID_SET;
	
			
		EXECUTE IMMEDIATE ('ALTER TABLE WLF_MESSAGE_SEARCH_LOG SET INTERVAL()');
		OPEN SRCHLOG_DT_SET;
		LOOP
			FETCH SRCHLOG_DT_SET INTO SRCHLOG_DT;
			EXIT WHEN SRCHLOG_DT_SET%NOTFOUND;
			C1_HIGH_VALUE := SRCHLOG_DT.HIGH_VALUE;
			--DBMS_OUTPUT.PUT_LINE(C1_HIGH_VALUE);
			EXECUTE IMMEDIATE (' SELECT TO_CHAR(' || C1_HIGH_VALUE || ' -1,''DD-MM-YYYY'') FROM DUAL ' ) INTO C1_DATE_VAL;
			DRP_MSG_LOG_TABL := ' ALTER TABLE WLF_MESSAGE_SEARCH_LOG DROP PARTITION FOR(TO_DATE(''' || C1_DATE_VAL || ''',''DD-MM-YYYY''))';
			--DBMS_OUTPUT.PUT_LINE(DRP_MSG_LOG_TABL);
			EXECUTE IMMEDIATE DRP_MSG_LOG_TABL;
		END LOOP;
		EXECUTE IMMEDIATE ('ALTER TABLE WLF_MESSAGE_SEARCH_LOG SET INTERVAL(NUMTOYMINTERVAL(1,''MONTH''))');
		CLOSE SRCHLOG_DT_SET;
		WLF_REBUILD_INDEXES('WLF_MESSAGE_SEARCH_LOG');
	END;
	@go@
]

	/* ---------------------------------------------------------------------------- */
	/*  GDPR - Purge                                                        		*/
	/* ---------------------------------------------------------------------------- */
[oracle
	CREATE OR REPLACE TYPE JobList is table of varchar2(50)
	/
	
	CREATE OR REPLACE PROCEDURE  @env:lm_schema_name@.WLF_PURGE_RL_HIT(p_type IN varchar2, p_id IN number, p_job_id IN varchar2, p_instance_id varchar, p_result OUT boolean)
	 AS
	/****  p_type = 'P'  -  party - purge from WLF_RL_HIT tables *****/
	/****  p_type = 'M'  -  message - purge from WLF_RL_MESSAGE_HIT tables *****/
	purged boolean := false;
	cur_id number(9);
	cur_instance_id varchar2(255);
	cur_job_id  varchar2(255);
	rl_tables_cur  SYS_REFCURSOR;

	begin
			case p_type
				when 'M' then
				   open rl_tables_cur for
					  select id,job_id, instance_id 
					 from  WLF_RL_MESSAGE_HIT 
					 where  wlf_rl_message_id = p_id and job_id = p_job_id and instance_id = p_instance_id;
				when 'P' then
					open rl_tables_cur for
					select id,job_id, instance_id 
					from  WLF_RL_HIT 
					where  party_id = p_id and job_id = p_job_id and instance_id = p_instance_id;
			end case;
			
			loop      
				  fetch  rl_tables_cur into cur_id,  cur_job_id, cur_instance_id;   
				  exit when rl_tables_cur%notfound;
				  
				  delete from WLF_RL_HIT_ADDINFO 
				  where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id ;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;
					  
				  delete from WLF_RL_HIT_ADDRESS 
				  where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_ALIAS 
				 where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id ;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_CATEGORY 
				 where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id ;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_DOB 
				 where hit_id = cur_id and job_id = cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_ID 
				 where hit_id = cur_id and job_id = cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_KEYWORD 
				 where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_NATIONALITY 
				 where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				 delete from WLF_RL_HIT_POB 
				 where hit_id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id;
				  if SQL%ROWCOUNT > 0 then 
						purged := true; 
				  end if;

				  if p_type = 'M' then 
					   delete from WLF_RL_MESSAGE_HIT 
					   where  id = cur_id and job_id =  cur_job_id and instance_id = cur_instance_id;
				  else
					   delete from WLF_RL_HIT
					   where id = cur_id and job_id = cur_job_id and instance_id = cur_instance_id;
				  end if;
					   
				   if SQL%ROWCOUNT > 0 then 
						purged := true; 
				   end if;           
			   
			end loop;
			close rl_tables_cur;
		   
		  p_result := purged;

		 exception when others then
			p_result := false;
			RAISE_APPLICATION_ERROR(-20001,'Error while purging from RL HIT tables, hit_id:   '||p_id||'.'|| SQLERRM);
	end WLF_PURGE_RL_HIT;    
	/  

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE_RL(p_type IN varchar2, p_message_key IN varchar2, p_retention_date date, p_result OUT boolean)
	 AS
	/****  p_type = 'K'  -  purge by message_key *****/
	/****  p_type = 'R' -  purge by retention period ***/
	purged boolean := false;

	begin
		   for cur in (select id, job_id, instance_id 
		   from  WLF_RL_MESSAGE 
		   where (p_type = 'K' and message_key = p_message_key)  /* purge by message_key */
				 or (p_type = 'R' and job_timestamp < p_retention_date))  /* purge by retention period */
			loop
			
			   WLF_PURGE_RL_HIT('M', cur.id, cur.job_id, cur.instance_id, purged);

				delete from WLF_RL_MESSAGE_INTERMEDIATE_FI  
				where wlf_rl_message_id = cur.id and job_id = cur.job_id and instance_id = cur.instance_id ;
				if SQL%ROWCOUNT > 0 then 
					purged := true; 
				end if;

			   delete from WLF_RL_MESSAGE
			   where id = cur.id  and job_id =  cur.job_id and instance_id =  cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
					purged := true; 
			   end if;
		  end loop; 
		  
		  p_result := purged;

		 exception when others then
			p_result := false;
			RAISE_APPLICATION_ERROR(-20001,'Error while purging from RL tables  '||p_message_key||'.'|| SQLERRM);
	end WLF_PURGE_MESSAGE_RL;
	/


	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_RL_DROP_PARTITION_G
	   (  P_TYPE VARCHAR2,
	   P_JOBS JobList)
	   AS
	   cur_parts   SYS_REFCURSOR;
	   c_table varchar2(30);
	   c_part VARCHAR2(30);
	   V_EXEC_STR VARCHAR2(1000);
	   table_current varchar2(30) := '';
	   c_order number(2);
	   
	   BEGIN
	  CASE p_type
	  WHEN 'M' THEN
		 OPEN cur_parts FOR WITH tab_partitions AS (SELECT /*+ materialize */  * FROM TABLE(P_JOBS))
		 SELECT DISTINCT TABLE_NAME, PARTITION_NAME,1 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL_HIT_%'OR TABLE_NAME LIKE 'WLF_RL_MESSAGE_INTERMEDIATE_FI')
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  UNION
		  SELECT DISTINCT TABLE_NAME, PARTITION_NAME,2 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL_MESSAGE_HIT') 
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  union
		  SELECT  DISTINCT TABLE_NAME, PARTITION_NAME,3 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL_MESSAGE') 
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  ORDER BY ord ;

	  WHEN 'P' THEN
	   OPEN cur_parts FOR WITH tab_partitions AS (SELECT /*+ materialize */  * FROM TABLE(P_JOBS))
		 SELECT DISTINCT TABLE_NAME, PARTITION_NAME,1 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL%' AND TABLE_NAME NOT LIKE 'WLF_RL_MESSAGE%' AND TABLE_NAME not in ('WLF_RL_PARTY', 'WLF_RL_HIT'))
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  UNION
		  SELECT DISTINCT TABLE_NAME, PARTITION_NAME,2 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL_HIT') 
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  union
		  SELECT  DISTINCT TABLE_NAME, PARTITION_NAME,3 ord
		  FROM USER_TAB_PARTITIONS
		  WHERE (TABLE_NAME LIKE 'WLF_RL_PARTY') 
		  AND PARTITION_NAME IN (SELECT * FROM tab_partitions)
		  ORDER BY ord ;
	   END CASE;

	  FETCH cur_parts INTO c_table, c_part, c_order;
	  table_current := c_table;

	   LOOP
	   EXIT WHEN cur_parts%NOTFOUND;
		 /* Drop partitions */
		 BEGIN
			V_EXEC_STR := 'ALTER TABLE ' || c_table || ' drop partition ' || c_part;
		   -- DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
			EXECUTE IMMEDIATE (V_EXEC_STR);
		  EXCEPTION
			WHEN OTHERS THEN
			 IF SQLCODE = -14083 THEN
			  NULL;
			  --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR );
			 ELSIF SQLCODE = -02149 THEN
			  NULL;
			  --DBMS_OUTPUT.PUT_LINE('ORA - 13117: ' || SQLERRM || ', query: ' || V_EXEC_STR );
			 ELSIF SQLCODE = -54 THEN null;
			  --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
			  DBMS_LOCK.SLEEP(10);
			  --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
			  EXECUTE IMMEDIATE (V_EXEC_STR);
			 ELSE
			  RAISE_APPLICATION_ERROR(-20001,'Unexpected error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
			 END IF;
		   END;

		   FETCH cur_parts INTO c_table, c_part, c_order;
		   IF (table_current <> c_table) THEN
			 /* Rebuild indexes */
			 WLF_REBUILD_INDEXES(table_current);
			 --DBMS_OUTPUT.PUT_LINE('Rebuild indexes '||table_current);
		   END IF;

		   table_current := c_table;

		END LOOP;
		CLOSE cur_parts;

	  /* Rebuild indexes  for the last table*/
		WLF_REBUILD_INDEXES(table_current);
		--DBMS_OUTPUT.PUT_LINE('Rebuild indexes '||table_current);
	   EXCEPTION
		 WHEN OTHERS THEN
		  RAISE_APPLICATION_ERROR(-20001,'Unexpected error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
	   END WLF_RL_DROP_PARTITION_G;
	/

    CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGES_BY_DATE
    (p_retention_date IN date)
     AS

    c_result boolean;
    jobs JobList;
	c_timeout NUMBER;

   cursor cur is  
           select 'P' || rtrim(substr(job_id,1,2)) || '_' || rtrim(substr(job_id,4,10)) job_id 
           from (select max(M.job_timestamp) max_date , M.job_id 
                   from WLF_RL_MESSAGE M
                   group by M.job_id) 
           where max_date <p_retention_date;
                 
    begin
	        /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
			/***  that locks tables that purge process should delete from. ***/
			select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
			execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;

            /***************  audit - purge candidates *****************************/
            execute immediate 'truncate table WLF_PURGE_MSG_CANDIDATES';
            execute immediate 'truncate table WLF_PURGE_MSG_RESULT';
                
            insert into WLF_PURGE_MSG_CANDIDATES(message_key)   
                   ( select message_key from WLF_RL_MESSAGE where job_timestamp < p_retention_date
                    union
                    select message_key from WLF_POLICY_RULES_AUDIT where process_date < p_retention_date
                    union
                    select message_key from WLF_MESSAGE_HITS where hit_timestamp < p_retention_date);
                     
            commit;

             /***************  Purge from WLF_MESSAGE_SEARCH_LOG *********************/
         --    WLF_PURGE_MESSAGE_SRCH_LOG(p_retention_date);
            
             /***************  Purge from WLF_RL_MESSAGE     **************************/
            /* Purge partitions  for finished not RT jobs */
            begin
              open cur; 
              fetch cur bulk collect into jobs;
              close cur;      
                   
              WLF_RL_DROP_PARTITION_G('M', jobs);
            end;           
          
            /* Purge rows that are from partitions that can't be dropped  or RT jobs ***/
             WLF_PURGE_MESSAGE_RL('R', '', p_retention_date, c_result);

            commit;
               
            /***************  Purge from WLF_POLICY_RULES_AUDIT **********************/
            delete from WLF_POLICY_RULES_AUDIT where process_date < p_retention_date;
           
            /***************  Purge from WLF_MESSAGE_HITS **************************/  
            delete from WLF_MESSAGE_HITS where hit_timestamp < p_retention_date;
       
            commit;
       
            /***************  audit - purge result *****************************/    
           insert into WLF_PURGE_MSG_RESULT(message_key)   
           (select message_key from WLF_PURGE_MSG_CANDIDATES
           minus
                   ( select message_key from WLF_RL_MESSAGE where job_timestamp < p_retention_date
                    union
                    select message_key from WLF_POLICY_RULES_AUDIT where process_date < p_retention_date
                    union
                    select message_key from WLF_MESSAGE_HITS where hit_timestamp < p_retention_date));
                
            commit;      

      exception when others then
	        /***************  audit - purge result *****************************/    
            insert into WLF_PURGE_MSG_RESULT(message_key)   
            (select message_key from WLF_PURGE_MSG_CANDIDATES
            minus
                   ( select message_key from WLF_RL_MESSAGE where job_timestamp < p_retention_date
                    union
                    select message_key from WLF_POLICY_RULES_AUDIT where process_date < p_retention_date
                    union
                    select message_key from WLF_MESSAGE_HITS where hit_timestamp < p_retention_date));
            commit;      

         RAISE_APPLICATION_ERROR(-20001,'Error while purging message. '|| SQLERRM);
    end WLF_PURGE_MESSAGES_BY_DATE;
    /

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE_SRCH_LOG(p_purge_date IN date)
	AS 
       V_EXEC_STR VARCHAR2(4000);
       V_DATE_VAL VARCHAR2(200);
	   c_timeout NUMBER;
     
	BEGIN
	    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
        /***  that locks tables that purge process should delete from. ***/
        select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
        execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;
	   
        /***************  audit - purge candidates *****************************/
            execute immediate 'truncate table WLF_PURGE_MS_SRCH_CANDIDATES';
            execute immediate 'truncate table WLF_PURGE_MS_SRCH_RESULT';
                
            insert into WLF_PURGE_MS_SRCH_CANDIDATES(message_key)   
              ( select distinct message_key from WLF_MESSAGE_SEARCH_LOG where job_timestamp < p_purge_date);
                    
            commit;

      /*********  Drop partitions older than input date from WLF_SRCH_LOG - partitioned by RANGE(JOB_TIMESTAMP), MONTHLY INTERVAL */
       FOR REC IN (
           SELECT HIGH_VALUE, PARTITION_NAME
           FROM USER_TAB_PARTITIONS p
           WHERE TABLE_NAME = 'WLF_MESSAGE_SEARCH_LOG'
               AND PARTITION_NAME <> 'PART_01'
       )
       LOOP
           BEGIN
               EXECUTE IMMEDIATE ('SELECT ' || REC.HIGH_VALUE || ' FROM DUAL') INTO V_DATE_VAL;
               IF (V_DATE_VAL <= P_PURGE_DATE) THEN
                   V_EXEC_STR := 'ALTER TABLE WLF_MESSAGE_SEARCH_LOG DROP PARTITION ' || REC.PARTITION_NAME;
                --   DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                   EXECUTE IMMEDIATE V_EXEC_STR;
               END IF;
               EXCEPTION WHEN OTHERS THEN
                   IF SQLCODE = -14083 THEN
                       NULL;
                       --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR);
                   ELSIF SQLCODE = -54 THEN
                      --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
                       DBMS_LOCK.SLEEP(10);
                     --  DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
                       EXECUTE IMMEDIATE (V_EXEC_STR);
                   ELSE
                       RAISE_APPLICATION_ERROR(-20001,'Error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
                   END IF;
           END;
       END LOOP;
       
       WLF_REBUILD_INDEXES('WLF_MESSAGE_SEARCH_LOG');
       
       /**********  Delete the records from WLF_SRCH_LOG older than input date for the month input date belongs to, we can't drop the whole partition */
      -- DBMS_OUTPUT.PUT_LINE('DELETE FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < ' || V_PURGE_DATE);
       DELETE FROM WLF_MESSAGE_SEARCH_LOG
       WHERE JOB_TIMESTAMP < P_PURGE_DATE;
       COMMIT;
       
		/***************  audit - purge result *****************************/                
		insert into WLF_PURGE_MS_SRCH_RESULT(message_key)   
		(select message_key from WLF_PURGE_MS_SRCH_CANDIDATES
		minus
		  ( select distinct message_key from WLF_MESSAGE_SEARCH_LOG where job_timestamp < p_purge_date));

			
		commit;      

        EXCEPTION
           WHEN OTHERS THEN
	        /***************  audit - purge result *****************************/                
            insert into WLF_PURGE_MS_SRCH_RESULT(message_key)   
            (select message_key from WLF_PURGE_MS_SRCH_CANDIDATES
            minus
              ( select distinct message_key from WLF_MESSAGE_SEARCH_LOG where job_timestamp < p_purge_date));
            commit;      
 
            RAISE_APPLICATION_ERROR(-20001,'Unexpected error while purging from WLF_MESSAGE_SEARCH_LOG. Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
	END WLF_PURGE_MESSAGE_SRCH_LOG;
	/
	
	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE
	(p_message_key IN varchar2
	,p_purgeSearchLog IN number
	,p_purgeResultLogs IN number
	,p_result OUT varchar2)
	 AS
	purged_message boolean := false;
	c_result boolean := false;
	c_timeout NUMBER;

	begin
	    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
        /***  that locks tables that purge process should delete from. ***/
        select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
        execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;
	   
		if p_purgeSearchLog = 1 then
		  /***************  AML_WLF_MS_PurgeSearchLog **************************/
		  delete from WLF_MESSAGE_SEARCH_LOG where message_key = p_message_key;
		  if SQL%ROWCOUNT > 0 then 
			purged_message := true; 
		 end if;
		end if;        
		
	   if  p_purgeResultLogs = 1 then
		   /***************  AML_WLF_MS_purgeResultLogs  **************************/
		   WLF_PURGE_MESSAGE_RL('K',p_message_key, '', c_result );
			
		   if c_result then purged_message := true;
		   end if;
		   
		  delete from WLF_POLICY_RULES_AUDIT where message_key = p_message_key;
		  if SQL%ROWCOUNT > 0 then 
			purged_message := true; 
		 end if;
		 
		 delete from WLF_MESSAGE_HITS where message_key = p_message_key;
		  if SQL%ROWCOUNT > 0 then 
			purged_message := true; 
		 end if;             
	   end if;
			
	   commit;
	   
	   if purged_message then p_result := 'P';
								   else p_result := 'N';
	   end if;

	  exception when others then
		rollback;
		p_result := 'E';
		RAISE_APPLICATION_ERROR(-20001,'Error while purging message '||p_message_key||'.'|| SQLERRM);
	end WLF_PURGE_MESSAGE;
	/

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTY_RL(p_type IN varchar2, p_party_key IN varchar2, p_retention_date date, p_result OUT boolean)
	 AS
	/****  p_type = 'K'  -  purge by party_key *****/
	/****  p_type = 'R' -  purge by retention period ***/
	purged boolean := false;

	begin
		   for cur in (select id, job_id, instance_id 
		   from  WLF_RL_PARTY 
		   where (p_type = 'K' and party_key = p_party_key)  /* purge by message_key */
				 or (p_type = 'R' and process_date < p_retention_date))  /* purge by retention period */
			loop
			
			   WLF_PURGE_RL_HIT('P', cur.id, cur.job_id, cur.instance_id, purged);

			  delete from WLF_RL_ADDRESS
			   where party_id = cur.id and job_id = cur.job_id and instance_id = cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
				purged := true; 
			   end if;
			   
			   delete from WLF_RL_ALIAS
			   where party_id = cur.id and job_id = cur.job_id and instance_id = cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
				purged := true; 
			   end if;
			   
			   delete from WLF_RL_ID 
			 where party_id = cur.id and job_id = cur.job_id and instance_id = cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
				purged := true; 
			   end if;
			   
			   delete from WLF_RL_NATIONALITY
			   where party_id = cur.id and job_id = cur.job_id and instance_id = cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
				purged := true; 
			   end if;
		   
			   delete from WLF_RL_PARTY
			   where id = cur.id  and job_id =  cur.job_id and instance_id =  cur.instance_id;
			   if SQL%ROWCOUNT > 0 then 
					purged := true; 
			   end if;
		  end loop; 
		  
		  p_result := purged;

		 exception when others then
			p_result := false;
			RAISE_APPLICATION_ERROR(-20001,'Error while purging from RL tables  '||p_party_key||'.'|| SQLERRM);
	end WLF_PURGE_PARTY_RL;
	/


	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_SRCH_LOG(p_purge_date IN date)
	 AS 
		V_EXEC_STR VARCHAR2(4000);
		V_DATE_VAL VARCHAR2(200);
		c_timeout NUMBER;

		BEGIN
		    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
			/***  that locks tables that purge process should delete from. ***/
			select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
			execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;
	   
			/***************  audit - purge candidates *****************************/
			execute immediate 'truncate table WLF_PURGE_SRCH_CANDIDATES';
			execute immediate 'truncate table WLF_PURGE_SRCH_RESULT';
				
			insert into WLF_PURGE_SRCH_CANDIDATES(party_key)   
			  ( select distinct party_key from WLF_SRCH_LOG where job_timestamp < p_purge_date);
					
			commit;

		   /********* Step 1 - Drop partitions older than input date from WLF_SRCH_LOG - partitioned by RANGE(JOB_TIMESTAMP), MONTHLY INTERVAL */
		   FOR REC IN (
			   SELECT HIGH_VALUE, PARTITION_NAME
			   FROM USER_TAB_PARTITIONS p
			   WHERE TABLE_NAME = 'WLF_SRCH_LOG'
				   AND PARTITION_NAME <> 'PER0'
		   )
		   LOOP
			   BEGIN
				   EXECUTE IMMEDIATE ('SELECT ' || REC.HIGH_VALUE || ' FROM DUAL') INTO V_DATE_VAL;
				   IF (V_DATE_VAL <= P_PURGE_DATE) THEN
					   V_EXEC_STR := 'ALTER TABLE WLF_SRCH_LOG DROP PARTITION ' || REC.PARTITION_NAME;
					   --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
					   EXECUTE IMMEDIATE V_EXEC_STR;
				   END IF;
				   EXCEPTION WHEN OTHERS THEN
					   IF SQLCODE = -14083 THEN
						   NULL;
						   --DBMS_OUTPUT.PUT_LINE('ORA - 14083: ' || SQLERRM || ', query: ' || V_EXEC_STR);
					   ELSIF SQLCODE = -54 THEN
						   --DBMS_OUTPUT.PUT_LINE('DBMS_LOCK.SLEEP(10)');
						   DBMS_LOCK.SLEEP(10);
						   --DBMS_OUTPUT.PUT_LINE(V_EXEC_STR);
						   EXECUTE IMMEDIATE (V_EXEC_STR);
					   ELSE
						   RAISE_APPLICATION_ERROR(-20001,'Error while dropping the partition : ' || V_EXEC_STR || ', Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
					   END IF;
			   END;
		   END LOOP;
		   
		   WLF_REBUILD_INDEXES('WLF_SRCH_LOG');
		   
		   /********** Step 2 - Delete the records from WLF_SRCH_LOG older than input date for the month input date belongs to, we can't drop the whole partition */
		   --DBMS_OUTPUT.PUT_LINE('DELETE FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < ' || V_PURGE_DATE);
		   DELETE FROM WLF_SRCH_LOG
		   WHERE JOB_TIMESTAMP < P_PURGE_DATE;
		   COMMIT;
		   
			/***************  audit - purge result *****************************/                
			insert into WLF_PURGE_SRCH_RESULT(party_key)   
			(select party_key from WLF_PURGE_SRCH_CANDIDATES
			minus
			 ( select distinct party_key from WLF_SRCH_LOG where job_timestamp < p_purge_date));
				
			commit;      
		   
    EXCEPTION
            WHEN OTHERS THEN
            /***************  audit - purge result *****************************/                
            insert into WLF_PURGE_SRCH_RESULT(party_key)   
            (select party_key from WLF_PURGE_SRCH_CANDIDATES
            minus
             ( select distinct party_key from WLF_SRCH_LOG where job_timestamp < p_purge_date));              
            commit;      
            
            RAISE_APPLICATION_ERROR(-20001,'Unexpected error while purging from WLF_SEARCH_LOG. Error code: ' || SQLCODE || ', Error message: ' || SQLERRM);
	END WLF_PURGE_SRCH_LOG;
	/

	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTIES_BY_DATE
	(p_retention_date IN date,
	 p_purgePriorHits IN number)
	 AS
		c_result boolean;
		jobs JobList;
		c_timeout NUMBER;

        cursor cur is  
                select 'P' || rtrim(substr(job_id,1,2)) || '_' || rtrim(substr(job_id,4,10)) job_id 
                from (select max(M.process_date) max_date , M.job_id 
                         from WLF_RL_PARTY M
                         group by M.job_id) 
                where max_date <p_retention_date;
				
		begin
		    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
			/***  that locks tables that purge process should delete from. ***/
			select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
			execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;
	   
			 /***************  audit - purge candidates *****************************/
			execute immediate 'truncate table WLF_PURGE_PARTY_CANDIDATES';
  			execute immediate 'truncate table WLF_PURGE_PARTY_RESULT';
				
		    insert into WLF_PURGE_PARTY_CANDIDATES(party_key)   
			   ( select party_key from WLF_RL_PARTY where process_date < p_retention_date
				union
				select party_key from WLF_HITS where hit_timestamp < p_retention_date and p_purgePriorHits = 1
				union
				select party_key from WLF_HIT_EXCLUDE_ENTRIES where expiration_date < p_retention_date
				union
				select party_key from WLF_ENTITY_EXCLUDE_ENTRIES where expiration_date <p_retention_date);
				
			commit;
				
			/***************  Purge from WLF_SEARCH_LOG *********************/
		 --    WLF_PURGE_SRCH_LOG(p_retention_date);
			
			 /***************  Purge from WLF_RL_MESSAGE     **************************/
			/* Purge partitions  for finished not RT jobs */
			begin
			  open cur; 
			  fetch cur bulk collect into jobs;
			  close cur;      
				   
			  WLF_RL_DROP_PARTITION_G('P', jobs);
			end;           
	  
			/* Purge rows that are from partitions that can't be dropped  or RT jobs ***/
			 WLF_PURGE_PARTY_RL('R', '', p_retention_date, c_result);

			 commit;
			 
			 delete from WLF_HIT_EXCLUDE_ENTRIES where expiration_date < p_retention_date;
				   
			 delete from WLF_ENTITY_EXCLUDE_ENTRIES where expiration_date < p_retention_date ;
				  
			 if p_purgePriorHits = 1 then
			   /***************  p_purgePriorHits **************************/
			   delete from WLF_HITS where hit_timestamp < p_retention_date;
			 end if;        
			   
			 commit;
			 
			/***************  audit - purge result *****************************/				
			insert into WLF_PURGE_PARTY_RESULT(party_key)   
			(select party_key from WLF_PURGE_PARTY_CANDIDATES
			minus
			( select party_key from WLF_RL_PARTY where process_date < p_retention_date
			union
			select party_key from WLF_HITS where hit_timestamp < p_retention_date and p_purgePriorHits = 1
			union
			select party_key from WLF_HIT_EXCLUDE_ENTRIES where expiration_date < p_retention_date
			union
			select party_key from WLF_ENTITY_EXCLUDE_ENTRIES where expiration_date <p_retention_date));
				
			commit;      
			  
	 exception when others then
			/***************  audit - purge result *****************************/				
			insert into WLF_PURGE_PARTY_RESULT(party_key)   
			(select party_key from WLF_PURGE_PARTY_CANDIDATES
			minus
			( select party_key from WLF_RL_PARTY where process_date < p_retention_date
			union
			select party_key from WLF_HITS where hit_timestamp < p_retention_date and p_purgePriorHits = 1
			union
			select party_key from WLF_HIT_EXCLUDE_ENTRIES where expiration_date < p_retention_date
			union
			select party_key from WLF_ENTITY_EXCLUDE_ENTRIES where expiration_date <p_retention_date));				
			commit;      
			  
		 RAISE_APPLICATION_ERROR(-20001,'Error while purging party. '|| SQLERRM);
	end WLF_PURGE_PARTIES_BY_DATE;
	/


	CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTY
	(p_party_key IN @ustring@
	,p_purgeSearchLog IN number
	,p_purgeResultLogs IN number
	,p_purgeExcludeLists IN number
	,p_purgePriorHits IN number
	,p_result OUT varchar2)
	 AS
	purged_party boolean := false;
	c_result boolean;
	c_timeout NUMBER;

	begin
	    /***  Setting DDL_lock_timeout  for case that process is running parallel with another WLF db process (e.g.SQL LOADER - DIRECT)  ***/ 
        /***  that locks tables that purge process should delete from. ***/
        select value into c_timeout from WLF_DB_SETTINGS where SETTING_ID = 'DDL_LOCK_TIMEOUT';      
        execute immediate 'alter session set ddl_lock_timeout= ' ||c_timeout;
       
		 if p_purgeSearchLog = 1 then
		 /***************  p_purgeSearchLog **************************/
		   delete from WLF_SRCH_LOG where party_key = p_party_key;
		   if SQL%ROWCOUNT > 0 then 
		  purged_party := true; 
		  end if;
		 end if;        
	 
	   if  p_purgeResultLogs = 1 then
		/***************  purgeResultLogs **************************/
		   WLF_PURGE_PARTY_RL('K',p_party_key, '', c_result );
			
		   if c_result then purged_party := true;
		   end if;
		   
		end if;
	 
		 if p_purgeExcludeLists = 1 then
			   /***************  p_purgeExcludeLists **************************/
			   delete from WLF_HIT_EXCLUDE_ENTRIES where party_key = p_party_key;
			   if SQL%ROWCOUNT > 0 then 
			  purged_party := true; 
		  end if;
			  
			  delete from WLF_ENTITY_EXCLUDE_ENTRIES where party_key = p_party_key;
			  if SQL%ROWCOUNT > 0 then 
			  purged_party := true; 
			 end if;              
		 end if;        
		 
		 if p_purgePriorHits = 1 then
		   /***************  p_purgePriorHits **************************/
		   delete from WLF_HITS where party_key = p_party_key;
		   if SQL%ROWCOUNT > 0 then 
		  purged_party := true; 
		  end if;
		 end if;        
		  
		 commit;
			
		 if purged_party then p_result := 'P';
			  else p_result := 'N';
		 end if;
		 
	exception when others then
	  rollback;
	  p_result := 'E';
	  RAISE_APPLICATION_ERROR(-20001,'Error while purging party '||p_party_key||'.'|| SQLERRM);
	end WLF_PURGE_PARTY;
	/

]

[mssql

		if exists (select * from sysobjects where name = 'WLF_PURGE_RL_HIT')
			drop procedure @env:lm_schema_name@.WLF_PURGE_RL_HIT
		@go@
	
		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_RL_HIT
        @P_TYPE VARCHAR(1),
        @P_ID INT, 
        @P_JOB_ID VARCHAR(50),
        @P_INSTANCE_ID VARCHAR(255),
        @P_RESULT INT OUTPUT	

		AS 
		BEGIN   
			SET NOCOUNT ON 
			DECLARE @PURGED INT = 0,
							@HIT_ID INT,
							@HIT_JOB_ID VARCHAR(50),
							@HIT_INSTANCE_ID VARCHAR(255)
			
			BEGIN 
			TRY    
					DECLARE
							 SET_PARTY_HITS CURSOR LOCAL FOR 
							 SELECT ID, JOB_ID, INSTANCE_ID 
							 FROM WLF_RL_HIT  
							 WHERE PARTY_ID = @P_ID AND JOB_ID = @P_JOB_ID AND INSTANCE_ID = @P_INSTANCE_ID
					DECLARE
							 SET_MESSAGE_HITS CURSOR LOCAL FOR 
							 SELECT ID, JOB_ID, INSTANCE_ID 
							 FROM WLF_RL_MESSAGE_HIT  
							 WHERE WLF_RL_MESSAGE_ID = @P_ID AND JOB_ID = @P_JOB_ID AND INSTANCE_ID = @P_INSTANCE_ID


					BEGIN
					 
					   If @P_TYPE = 'P'
						BEGIN  
							OPEN  SET_PARTY_HITS
							 FETCH NEXT FROM SET_PARTY_HITS
							 INTO @HIT_ID, @HIT_JOB_ID, @HIT_INSTANCE_ID 
						END   

					   If @P_TYPE = 'M' 
						  BEGIN
							 OPEN  SET_MESSAGE_HITS
							 FETCH NEXT FROM SET_MESSAGE_HITS
							 INTO @HIT_ID, @HIT_JOB_ID, @HIT_INSTANCE_ID 
						   END     

					   
						WHILE @@FETCH_STATUS = 0
						BEGIN
							 DELETE WLF_RL_HIT_ADDINFO  
							 FROM WLF_RL_HIT_ADDINFO 
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_ADDRESS  
							 FROM WLF_RL_HIT_ADDRESS  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_ALIAS  
							 FROM WLF_RL_HIT_ALIAS  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_CATEGORY  
							 FROM WLF_RL_HIT_CATEGORY  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_DOB  
							 FROM WLF_RL_HIT_DOB  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_ID  
							 FROM WLF_RL_HIT_ID  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_KEYWORD  
							 FROM WLF_RL_HIT_KEYWORD  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_NATIONALITY  
							 FROM WLF_RL_HIT_NATIONALITY  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 DELETE WLF_RL_HIT_POB  
							 FROM WLF_RL_HIT_POB  
							 WHERE HIT_ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
							 IF @@ROWCOUNT > 0 
									 SET @PURGED = 1

							 IF @P_TYPE = 'P' 
							 BEGIN   
								 DELETE WLF_RL_HIT  
								 FROM WLF_RL_HIT  
								 WHERE ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED = 1
								 
								  FETCH NEXT FROM SET_PARTY_HITS  INTO @HIT_ID, @HIT_JOB_ID, @HIT_INSTANCE_ID 
							 END

							 IF @P_TYPE = 'M' 
							 BEGIN   
								 DELETE WLF_RL_MESSAGE_HIT  
								 FROM WLF_RL_MESSAGE_HIT 
								 WHERE ID = @HIT_ID AND JOB_ID = @HIT_JOB_ID AND INSTANCE_ID = @HIT_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED = 1
								 
								  FETCH NEXT FROM SET_MESSAGE_HITS  INTO @HIT_ID, @HIT_JOB_ID, @HIT_INSTANCE_ID 
							 END
	 
					   END

						IF @P_TYPE = 'P' 
						BEGIN
						   CLOSE SET_PARTY_HITS
						   DEALLOCATE SET_PARTY_HITS
						END	
						IF @P_TYPE = 'M' 
						BEGIN
							CLOSE SET_MESSAGE_HITS   
							DEALLOCATE SET_MESSAGE_HITS
						END	

					 END 

					 SET @P_RESULT = @PURGED

			END  TRY
			BEGIN CATCH 
					SELECT 
							ERROR_NUMBER()    AS ERRORNUMBER ,
							ERROR_SEVERITY()  AS ERRORSEVERITY ,
							ERROR_STATE()     AS ERRORSTATE ,
							ERROR_PROCEDURE() AS ERRORPROCEDURE ,
							ERROR_LINE()      AS ERRORLINE ,
							ERROR_MESSAGE()   AS ERRORMESSAGE 
							SET @P_RESULT = 0;
							RETURN 1
			END CATCH 
		END
		@go@

		if exists (select * from sysobjects where name = 'WLF_RL_MS_DROP_PART_G')
			drop procedure @env:lm_schema_name@.WLF_RL_MS_DROP_PART_G
		@go@
		
		CREATE PROCEDURE @env:lm_schema_name@.WLF_RL_MS_DROP_PART_G
		@job_id varchar(30)

		AS 
		BEGIN
		  SET NOCOUNT ON
		   BEGIN TRY
		   DECLARE
			   @PART_VALUE varchar(30),
			   @RL_TABLE_NAME varchar(30),
			   @EXEC_STR varchar(1000),
			   @RL_TABLE_NAME_TEMP varchar(30),
			   @PARTITION int,
				@RL_ORD int,
			   @PART_EXISTS int

                      SELECT @PART_VALUE = @job_id + 'Z'

                      SELECT  @PART_EXISTS = COUNT(*) 
                               FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
                               WHERE (spf.name=N'rl_partfunc') and sprv.value = @PART_VALUE
                      IF @PART_EXISTS = 1
                        BEGIN
                                SELECT @PARTITION = $partition.rl_partfunc(@PART_VALUE)

                                DECLARE RL_TABLE_CURSOR CURSOR LOCAL FOR 
                                 SELECT NAME, 1 ord
                                 FROM sys.tables
                                 where (name like 'WLF_RL_HIT_%' and name not like 'WLF_RL%TEMP')
                                 UNION
                                 SELECT NAME, 2 ord
                                 FROM sys.tables
                                 where name = 'WLF_RL_MESSAGE_HIT'
                                 UNION
                                 SELECT NAME, 3 ord
                                 FROM sys.tables
                                 where name = 'WLF_RL_MESSAGE'
                                 order by ord desc                              
  
                                OPEN RL_TABLE_CURSOR
                                FETCH NEXT FROM RL_TABLE_CURSOR  INTO @RL_TABLE_NAME, @RL_ORD 

                                 WHILE @@FETCH_STATUS = 0
                                  BEGIN
                                        SET @RL_TABLE_NAME_TEMP = @RL_TABLE_NAME + '_TEMP'
                                        SET @EXEC_STR = 'TRUNCATE TABLE dbo.' + @RL_TABLE_NAME + '_TEMP;'
                                        EXECUTE (@EXEC_STR)

                                        EXECUTE dbo.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @RL_TABLE_NAME, @P_TABLE_NONPART = @RL_TABLE_NAME_TEMP, @PARTITION_NAME = @PARTITION

                                        SET @EXEC_STR = 'TRUNCATE TABLE dbo.' + @RL_TABLE_NAME + '_TEMP;'
                                        EXECUTE (@EXEC_STR)

                                        FETCH NEXT FROM RL_TABLE_CURSOR INTO @RL_TABLE_NAME, @RL_ORD
                                  END

                                 CLOSE RL_TABLE_CURSOR
                                 DEALLOCATE RL_TABLE_CURSOR

                                  SET @EXEC_STR = 'TRUNCATE TABLE dbo.WLF_RL_MESSAGE_INTERMED_TEMP;'
                                  EXECUTE (@EXEC_STR)

								 EXECUTE WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = 'WLF_RL_MESSAGE_INTERMEDIATE_FI', @P_TABLE_NONPART = 'WLF_RL_MESSAGE_INTERMED_TEMP', @PARTITION_NAME = @PARTITION
                                  SET @EXEC_STR = 'TRUNCATE TABLE dbo.WLF_RL_MESSAGE_INTERMED_TEMP;'
                                  EXECUTE (@EXEC_STR)

                                  ALTER PARTITION FUNCTION rl_partfunc() MERGE RANGE (@PART_VALUE)
                            END      
			   END TRY
			   BEGIN CATCH
				 SELECT 
				  ERROR_NUMBER() AS ErrorNumber
				  ,ERROR_SEVERITY() AS ErrorSeverity
				  ,ERROR_STATE() AS ErrorState
				  ,ERROR_PROCEDURE() AS ErrorProcedure
				  ,ERROR_LINE() AS ErrorLine
				  ,ERROR_MESSAGE() AS ErrorMessage;
					THROW
			  END CATCH
		END
		@go@
	
		if exists (select * from sysobjects where name = 'WLF_PURGE_MESSAGE_RL')
			drop procedure @env:lm_schema_name@.WLF_PURGE_MESSAGE_RL
		@go@
		
		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE_RL
			@P_TYPE VARCHAR(1),
			@P_MESSAGE_KEY @ustring@(255),
			@P_RETENTION_DATE DATE,
			@P_RESULT INT OUTPUT
			 AS 
			/****  p_type = 'K'  -  purge by message_key *****/
			/****  p_type = 'R' -  purge by retention period ***/
			 BEGIN  
				SET NOCOUNT ON 
				DECLARE @PURGED_MESSAGE INT = 0,
						@MESSAGE_ID INT,
						@MESSAGE_JOB_ID VARCHAR(50),
						@MESSAGE_INSTANCE_ID VARCHAR(255)

				BEGIN 
				TRY
						DECLARE
								 SET_MESSAGE CURSOR LOCAL FOR 
								 SELECT ID, JOB_ID, INSTANCE_ID 
								 FROM WLF_RL_MESSAGE 
								 WHERE (@P_TYPE = 'K' AND MESSAGE_KEY = @P_MESSAGE_KEY)  /* purge by message_key */
								 OR (@P_TYPE = 'R' AND JOB_TIMESTAMP < @P_RETENTION_DATE)  /* purge by retention period */
							   
						  OPEN  SET_MESSAGE
						  FETCH NEXT FROM SET_MESSAGE
						  INTO @MESSAGE_ID, @MESSAGE_JOB_ID, @MESSAGE_INSTANCE_ID
						  WHILE @@FETCH_STATUS = 0
						  BEGIN
						  
								EXECUTE WLF_PURGE_RL_HIT 'M', @MESSAGE_ID, @MESSAGE_JOB_ID, @MESSAGE_INSTANCE_ID, @PURGED_MESSAGE

								 DELETE WLF_RL_MESSAGE_INTERMEDIATE_FI 
								 FROM WLF_RL_MESSAGE_INTERMEDIATE_FI  
								 WHERE WLF_RL_MESSAGE_ID = @MESSAGE_ID AND JOB_ID = @MESSAGE_JOB_ID AND INSTANCE_ID = @MESSAGE_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_MESSAGE = 1

								 DELETE WLF_RL_MESSAGE 
								 FROM WLF_RL_MESSAGE 
								 WHERE ID = @MESSAGE_ID AND JOB_ID = @MESSAGE_JOB_ID AND INSTANCE_ID = @MESSAGE_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_MESSAGE = 1           

								FETCH NEXT FROM SET_MESSAGE
								INTO @MESSAGE_ID, @MESSAGE_JOB_ID, @MESSAGE_INSTANCE_ID
						END       
						CLOSE SET_MESSAGE
						DEALLOCATE SET_MESSAGE

						SET @P_RESULT = @PURGED_MESSAGE

					 
				END  TRY
				BEGIN CATCH 
						SELECT 
								ERROR_NUMBER()    AS ERRORNUMBER ,
								ERROR_SEVERITY()  AS ERRORSEVERITY ,
								ERROR_STATE()     AS ERRORSTATE ,
								ERROR_PROCEDURE() AS ERRORPROCEDURE ,
								ERROR_LINE()      AS ERRORLINE ,
								ERROR_MESSAGE()   AS ERRORMESSAGE 
								SET @P_RESULT = 0;
								RETURN 1
				END CATCH 
		END
		@go@



		if exists (select * from sysobjects where name = 'WLF_PURGE_MESSAGE')
			drop procedure @env:lm_schema_name@.WLF_PURGE_MESSAGE
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE 
		@P_MESSAGE_KEY @ustring@(255),
		@P_PURGESEARCHLOG INT,
		@P_PURGERESULTLOGS INT,
		@P_RESULT VARCHAR(1) OUTPUT
		 AS 
		 BEGIN   
			BEGIN 
			TRY
					SET NOCOUNT ON 
					DECLARE @PURGED_MESSAGE INT = 0,
										@PURGED_MESSAGE_RL INT = 0

					IF @P_PURGESEARCHLOG = 1 
					BEGIN
						
						DELETE WLF_MESSAGE_SEARCH_LOG  FROM WLF_MESSAGE_SEARCH_LOG WHERE MESSAGE_KEY = @P_MESSAGE_KEY
						IF @@ROWCOUNT > 0 
							 SET @PURGED_MESSAGE = 1
					END       

					IF @P_PURGERESULTLOGS = 1 
					BEGIN
					   
						EXECUTE WLF_PURGE_MESSAGE_RL 'K', @P_MESSAGE_KEY, '', @PURGED_MESSAGE_RL 

						IF @PURGED_MESSAGE_RL  = 1
							SET @PURGED_MESSAGE = 1

						DELETE WLF_POLICY_RULES_AUDIT FROM WLF_POLICY_RULES_AUDIT WHERE MESSAGE_KEY = @P_MESSAGE_KEY
						IF @@ROWCOUNT > 0 
							SET @PURGED_MESSAGE = 1

						DELETE WLF_MESSAGE_HITS FROM WLF_MESSAGE_HITS WHERE MESSAGE_KEY = @P_MESSAGE_KEY
						IF @@ROWCOUNT > 0 
							SET @PURGED_MESSAGE = 1
					END        
					
					IF @PURGED_MESSAGE = 1 
					  SET @P_RESULT = 'P'
					ELSE SET @P_RESULT = 'N'
					
				END TRY 
				BEGIN CATCH 
					SELECT 
						ERROR_NUMBER()    AS ErrorNumber ,
						ERROR_SEVERITY()  AS ErrorSeverity ,
						ERROR_STATE()     AS ErrorState ,
						ERROR_PROCEDURE() AS ErrorProcedure ,
						ERROR_LINE()      AS ErrorLine ,
						ERROR_MESSAGE()   AS ErrorMessage; 
						SET @P_RESULT = 'E';
						RETURN 1
				END CATCH 
			END
			@go@				

		if exists (select * from sysobjects where name = 'WLF_PURGE_MESSAGES_BY_DATE')
			drop procedure @env:lm_schema_name@.WLF_PURGE_MESSAGES_BY_DATE
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGES_BY_DATE
        @P_RETENTION_DATE DATE
		
		 AS 
		  BEGIN   
			SET NOCOUNT ON 
			DECLARE @C_RESULT INT,
							@JOB_ID VARCHAR(255)
			
					BEGIN 
			TRY    
						/********  audit - purge candidates **********/
						 TRUNCATE TABLE WLF_PURGE_MSG_CANDIDATES
						 TRUNCATE TABLE WLF_PURGE_MSG_RESULT

						 INSERT INTO WLF_PURGE_MSG_CANDIDATES(MESSAGE_KEY)   
						( SELECT MESSAGE_KEY FROM WLF_RL_MESSAGE WHERE JOB_TIMESTAMP < @P_RETENTION_DATE
						   UNION
						   SELECT MESSAGE_KEY FROM WLF_POLICY_RULES_AUDIT WHERE PROCESS_DATE < @P_RETENTION_DATE
						   UNION
						   SELECT MESSAGE_KEY FROM WLF_MESSAGE_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE)

						DECLARE
							SET_JOBS CURSOR LOCAL FOR 
							SELECT J.JOB_ID 
							FROM (SELECT MAX(M.JOB_TIMESTAMP) MAX_DATE , M.JOB_ID 
									FROM WLF_RL_MESSAGE M
							GROUP BY M.JOB_ID ) J
							WHERE MAX_DATE < @P_RETENTION_DATE



						   
						   OPEN  SET_JOBS
						   FETCH NEXT FROM SET_JOBS INTO @JOB_ID
						   WHILE @@FETCH_STATUS = 0
						   BEGIN

							   EXECUTE WLF_RL_MS_DROP_PART_G @JOB_ID

							  FETCH NEXT FROM SET_JOBS INTO @JOB_ID                  
						   END       
						   CLOSE SET_JOBS
						   DEALLOCATE SET_JOBS

						
						BEGIN
						  EXECUTE WLF_PURGE_MESSAGE_RL 'R', '', @P_RETENTION_DATE, @C_RESULT
						END

				   
						DELETE WLF_POLICY_RULES_AUDIT FROM WLF_POLICY_RULES_AUDIT WHERE PROCESS_DATE < @P_RETENTION_DATE

		   
						
					   DELETE WLF_MESSAGE_HITS FROM WLF_MESSAGE_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE

					   /***************  audit - purge result ****************/                
					   INSERT INTO WLF_PURGE_MSG_RESULT(MESSAGE_KEY)   
					   ( SELECT MESSAGE_KEY FROM  WLF_PURGE_MSG_CANDIDATES
						 EXCEPT
					   ( SELECT MESSAGE_KEY FROM WLF_RL_MESSAGE WHERE JOB_TIMESTAMP < @P_RETENTION_DATE
						   UNION
						   SELECT MESSAGE_KEY FROM WLF_POLICY_RULES_AUDIT WHERE PROCESS_DATE < @P_RETENTION_DATE
						   UNION
						   SELECT MESSAGE_KEY FROM WLF_MESSAGE_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE))


			END  TRY
			BEGIN CATCH 
						   /***************  audit - purge result ****************/                
						   INSERT INTO WLF_PURGE_MSG_RESULT(MESSAGE_KEY)   
						   ( SELECT MESSAGE_KEY FROM  WLF_PURGE_MSG_CANDIDATES
							 EXCEPT
						   ( SELECT MESSAGE_KEY FROM WLF_RL_MESSAGE WHERE JOB_TIMESTAMP < @P_RETENTION_DATE
							   UNION
							   SELECT MESSAGE_KEY FROM WLF_POLICY_RULES_AUDIT WHERE PROCESS_DATE < @P_RETENTION_DATE
							   UNION
							   SELECT MESSAGE_KEY FROM WLF_MESSAGE_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE))

				SELECT 
					ERROR_NUMBER()    AS ERRORNUMBER ,
					ERROR_SEVERITY()  AS ERRORSEVERITY ,
					ERROR_STATE()     AS ERRORSTATE ,
					ERROR_PROCEDURE() AS ERRORPROCEDURE ,
					ERROR_LINE()      AS ERRORLINE ,
					ERROR_MESSAGE()   AS ERRORMESSAGE; 
							THROW
					END CATCH 
		END
	@go@
	
		if exists (select * from sysobjects where name = 'WLF_PURGE_PARTY_RL')
			drop procedure @env:lm_schema_name@.WLF_PURGE_PARTY_RL
		@go@

			CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTY_RL
			@P_TYPE VARCHAR(1),
			@P_PARTY_KEY @ustring@(255),
			@P_RETENTION_DATE DATE,
			@P_RESULT INT OUTPUT
			/****  p_type = 'K'  -  purge by party_key *****/
			/****  p_type = 'R' -  purge by retention period ***/
			 AS 
			  BEGIN  
				SET NOCOUNT ON 
				DECLARE @PURGED_PARTY INT = 0,
								@PARTY_ID INT,
								@PARTY_JOB_ID VARCHAR(50),
								@PARTY_INSTANCE_ID VARCHAR(255)

				BEGIN 
				TRY
						DECLARE
								 SET_PARTIES CURSOR LOCAL FOR 
								 SELECT ID, JOB_ID, INSTANCE_ID 
								 FROM WLF_RL_PARTY 
								 WHERE (@P_TYPE = 'K' AND PARTY_KEY = @P_PARTY_KEY)  /* purge by message_key */
								 OR (@P_TYPE = 'R' and PROCESS_DATE < @P_RETENTION_DATE)  /* purge by retention period */
							   
						  OPEN  SET_PARTIES
						  FETCH NEXT FROM SET_PARTIES
						  INTO @PARTY_ID, @PARTY_JOB_ID, @PARTY_INSTANCE_ID
						  WHILE @@FETCH_STATUS = 0
						  BEGIN
						  
								 EXECUTE WLF_PURGE_RL_HIT 'P', @PARTY_ID, @PARTY_JOB_ID, @PARTY_INSTANCE_ID, @PURGED_PARTY

								 DELETE WLF_RL_ADDRESS  
								 FROM WLF_RL_ADDRESS 
								 WHERE PARTY_ID = @PARTY_ID AND JOB_ID = @PARTY_JOB_ID AND INSTANCE_ID = @PARTY_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_PARTY = 1

								 DELETE WLF_RL_ALIAS  
								 FROM WLF_RL_ALIAS 
								 WHERE PARTY_ID = @PARTY_ID AND JOB_ID = @PARTY_JOB_ID AND INSTANCE_ID = @PARTY_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_PARTY = 1

								 DELETE WLF_RL_ID  
								 FROM WLF_RL_ID 
								 WHERE PARTY_ID = @PARTY_ID AND JOB_ID = @PARTY_JOB_ID AND INSTANCE_ID = @PARTY_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_PARTY = 1

								 DELETE WLF_RL_NATIONALITY  
								 FROM WLF_RL_NATIONALITY 
								 WHERE PARTY_ID = @PARTY_ID AND JOB_ID = @PARTY_JOB_ID AND INSTANCE_ID = @PARTY_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										SET @PURGED_PARTY = 1   

								 DELETE WLF_RL_PARTY  
								 FROM WLF_RL_PARTY 
								 WHERE ID = @PARTY_ID AND JOB_ID = @PARTY_JOB_ID AND INSTANCE_ID = @PARTY_INSTANCE_ID
								 IF @@ROWCOUNT > 0 
										 SET @PURGED_PARTY = 1

								  FETCH NEXT FROM SET_PARTIES
								  INTO @PARTY_ID, @PARTY_JOB_ID, @PARTY_INSTANCE_ID
						  END       
						  CLOSE SET_PARTIES
						  DEALLOCATE SET_PARTIES

						  SET @P_RESULT = @PURGED_PARTY
					   
				END  TRY
				BEGIN CATCH 
						SELECT 
								ERROR_NUMBER()    AS ERRORNUMBER ,
								ERROR_SEVERITY()  AS ERRORSEVERITY ,
								ERROR_STATE()     AS ERRORSTATE ,
								ERROR_PROCEDURE() AS ERRORPROCEDURE ,
								ERROR_LINE()      AS ERRORLINE ,
								ERROR_MESSAGE()   AS ERRORMESSAGE 
								SET @P_RESULT = 0;
								RETURN 1
				END CATCH 
		END
		@go@



		if exists (select * from sysobjects where name = 'WLF_PURGE_PARTY')
			drop procedure @env:lm_schema_name@.WLF_PURGE_PARTY
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTY
			@P_PARTY_KEY @ustring@(255),
			@P_PURGESEARCHLOG INT,
			@P_PURGERESULTLOGS INT,
			@P_PURGEEXCLUDELISTS INT,
			@P_PURGEPRIORHITS INT,
			@P_RESULT VARCHAR(1) OUTPUT

			 AS 
			  BEGIN   
				SET NOCOUNT ON 
				DECLARE @PURGED_PARTY INT = 0,
						@PURGED_PARTY_RL INT = 0
				
				BEGIN 
				TRY    
					DECLARE
						 SET_PARTIES CURSOR LOCAL FOR 
						 SELECT ID, JOB_ID, INSTANCE_ID FROM WLF_RL_PARTY WHERE PARTY_KEY = @P_PARTY_KEY


					IF @P_PURGESEARCHLOG = 1 
					BEGIN
						
						DELETE WLF_SRCH_LOG  FROM WLF_SRCH_LOG WHERE PARTY_KEY = @P_PARTY_KEY
						IF @@ROWCOUNT > 0 
								 SET @PURGED_PARTY = 1
					END       

					IF @P_PURGERESULTLOGS = 1 
					BEGIN
					   
					   EXECUTE WLF_PURGE_PARTY_RL 'K', @P_PARTY_KEY, '', @PURGED_PARTY_RL 

					   IF @PURGED_PARTY_RL = 1
							SET @PURGED_PARTY = 1

					END

					IF @P_PURGEEXCLUDELISTS = 1 
					BEGIN
						
						DELETE WLF_HIT_EXCLUDE_ENTRIES  FROM WLF_HIT_EXCLUDE_ENTRIES WHERE PARTY_KEY = @P_PARTY_KEY
						IF @@ROWCOUNT > 0 
							 SET @PURGED_PARTY = 1

						DELETE WLF_ENTITY_EXCLUDE_ENTRIES  FROM WLF_ENTITY_EXCLUDE_ENTRIES WHERE PARTY_KEY = @P_PARTY_KEY
						IF @@ROWCOUNT > 0 
							 SET @PURGED_PARTY = 1

					END       

					IF @P_PURGEPRIORHITS = 1 
					BEGIN
						
						DELETE WLF_HITS  FROM WLF_HITS WHERE PARTY_KEY = @P_PARTY_KEY
						IF @@ROWCOUNT > 0 
							 SET @PURGED_PARTY = 1
					END       


					IF @PURGED_PARTY = 1 SET @P_RESULT = 'P'
					ELSE SET @P_RESULT = 'N'
				 
				END  TRY
				BEGIN CATCH 
					SELECT 
						ERROR_NUMBER()    AS ERRORNUMBER ,
						ERROR_SEVERITY()  AS ERRORSEVERITY ,
						ERROR_STATE()     AS ERRORSTATE ,
						ERROR_PROCEDURE() AS ERRORPROCEDURE ,
						ERROR_LINE()      AS ERRORLINE ,
						ERROR_MESSAGE()   AS ERRORMESSAGE 
						SET @P_RESULT = 'E';
						RETURN 1
				END CATCH 
			END
			@go@
			

		if exists (select * from sysobjects where name = 'WLF_RL_DROP_PARTITION_G')
			drop procedure @env:lm_schema_name@.WLF_RL_DROP_PARTITION_G
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_RL_DROP_PARTITION_G
		@job_id varchar(30)
		 
		AS 
		BEGIN
		  SET NOCOUNT ON
		   BEGIN TRY
			   DECLARE

			   @PART_VALUE varchar(30),
			   @RL_TABLE_NAME varchar(30),
			   @EXEC_STR varchar(1000),
			   @RL_TABLE_NAME_TEMP varchar(30),
			   @RL_ORD int,
			   @PARTITION int,
			   @PART_EXISTS int
		 
		  
			  SELECT @PART_VALUE = @job_id + 'Z'
			  SELECT  @PART_EXISTS = COUNT(*) 
					   FROM sys.partition_functions AS spf INNER JOIN sys.partition_range_values sprv ON sprv.function_id=spf.function_id 
					   WHERE (spf.name=N'rl_partfunc') and sprv.value = @PART_VALUE
			  IF @PART_EXISTS = 1
				BEGIN
					  SELECT @PARTITION = $partition.rl_partfunc(@PART_VALUE)
					  DECLARE RL_TABLE_CURSOR CURSOR LOCAL FOR 
					    SELECT NAME,1 as ord
						FROM sys.tables
						where name like 'WLF_RL%' and name not like 'WLF_RL_MESSAGE%' and name not like 'WLF_RL%TEMP' and name not in ('WLF_RL_PARTY', 'WLF_RL_HIT')
						UNION 
						SELECT NAME,2 as ord
						FROM sys.tables
						where name ='WLF_RL_HIT'
						UNION 
						SELECT NAME,3 as ord
						FROM sys.tables
						where name ='WLF_RL_PARTY'
						order by ord
						
					  OPEN RL_TABLE_CURSOR
					 FETCH NEXT FROM RL_TABLE_CURSOR 
					 INTO @RL_TABLE_NAME, @RL_ORD


					 WHILE @@FETCH_STATUS = 0
					  BEGIN

					   SET @RL_TABLE_NAME_TEMP = @RL_TABLE_NAME + '_TEMP'
					   SET @EXEC_STR = 'TRUNCATE TABLE dbo.' + @RL_TABLE_NAME + '_TEMP;'
					   EXECUTE (@EXEC_STR)

					   EXECUTE dbo.WLF_LM_INFRA_SWITCH_PARTITION @P_TABLE_PART = @RL_TABLE_NAME, @P_TABLE_NONPART = @RL_TABLE_NAME_TEMP, @PARTITION_NAME = @PARTITION

					   SET @EXEC_STR = 'TRUNCATE TABLE dbo.' + @RL_TABLE_NAME + '_TEMP;'
					   EXECUTE (@EXEC_STR)

					   FETCH NEXT FROM RL_TABLE_CURSOR 
					   INTO @RL_TABLE_NAME, @RL_ORD

					  END

						 CLOSE RL_TABLE_CURSOR
						 DEALLOCATE RL_TABLE_CURSOR

						ALTER PARTITION FUNCTION rl_partfunc() MERGE RANGE (@PART_VALUE)   
			   END
		 END TRY
		   BEGIN CATCH
		 SELECT 
		  ERROR_NUMBER() AS ErrorNumber
		  ,ERROR_SEVERITY() AS ErrorSeverity
		  ,ERROR_STATE() AS ErrorState
		  ,ERROR_PROCEDURE() AS ErrorProcedure
		  ,ERROR_LINE() AS ErrorLine
		  ,ERROR_MESSAGE() AS ErrorMessage;
			THROW
		  END CATCH
		END
		RETURN
		@go@
		
		if exists (select * from sysobjects where name = 'WLF_PURGE_PARTIES_BY_DATE')
			drop procedure @env:lm_schema_name@.WLF_PURGE_PARTIES_BY_DATE
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_PARTIES_BY_DATE
        @P_RETENTION_DATE DATE,
		@P_PURGEPRIORHITS INT
		
		 AS 
		  BEGIN   
				DECLARE @C_RESULT INT,
							@JOB_ID VARCHAR(255)
			
					BEGIN 
			TRY   
					   
					   TRUNCATE TABLE WLF_PURGE_PARTY_CANDIDATES
					   TRUNCATE TABLE WLF_PURGE_PARTY_RESULT

					   INSERT INTO WLF_PURGE_PARTY_CANDIDATES(PARTY_KEY)   
					  ( SELECT PARTY_KEY FROM WLF_RL_PARTY WHERE PROCESS_DATE < @P_RETENTION_DATE
						UNION
						SELECT PARTY_KEY FROM WLF_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE AND @P_PURGEPRIORHITS = 1
						UNION
						SELECT PARTY_KEY FROM WLF_HIT_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE
						UNION
						SELECT PARTY_KEY FROM WLF_ENTITY_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE)
	 
						DECLARE
							 SET_JOBS CURSOR LOCAL FOR 
							 SELECT J.JOB_ID 
					FROM (SELECT MAX(M.PROCESS_DATE) MAX_DATE , M.JOB_ID 
					FROM WLF_RL_PARTY M
					GROUP BY M.JOB_ID ) J
					WHERE MAX_DATE < @P_RETENTION_DATE
						   
						   OPEN  SET_JOBS
						   FETCH NEXT FROM SET_JOBS INTO @JOB_ID
						   WHILE @@FETCH_STATUS = 0
						   BEGIN
					 
							  EXECUTE WLF_RL_DROP_PARTITION_G @JOB_ID
	 
							  FETCH NEXT FROM SET_JOBS INTO @JOB_ID                  
						   END       
						   CLOSE SET_JOBS
						   DEALLOCATE SET_JOBS

						
						BEGIN
						  EXECUTE WLF_PURGE_PARTY_RL 'R', '', @P_RETENTION_DATE, @C_RESULT
						END

						
					   DELETE WLF_HIT_EXCLUDE_ENTRIES  FROM WLF_HIT_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE

					   DELETE WLF_ENTITY_EXCLUDE_ENTRIES  FROM WLF_ENTITY_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE

					   
			   IF @P_PURGEPRIORHITS = 1 
				DELETE WLF_HITS  FROM WLF_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE

									  
						 INSERT INTO WLF_PURGE_PARTY_RESULT(PARTY_KEY)   
					   ( SELECT PARTY_KEY FROM  WLF_PURGE_PARTY_CANDIDATES
						 EXCEPT
					   ( SELECT PARTY_KEY FROM WLF_RL_PARTY WHERE PROCESS_DATE < @P_RETENTION_DATE
							UNION
							SELECT PARTY_KEY FROM WLF_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE AND @P_PURGEPRIORHITS = 1
							UNION
							SELECT PARTY_KEY FROM WLF_HIT_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE
							UNION
							SELECT PARTY_KEY FROM WLF_ENTITY_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE))



			END  TRY
			BEGIN CATCH 
										  
							 INSERT INTO WLF_PURGE_PARTY_RESULT(PARTY_KEY)   
						   ( SELECT PARTY_KEY FROM  WLF_PURGE_PARTY_CANDIDATES
							 EXCEPT
						   ( SELECT PARTY_KEY FROM WLF_RL_PARTY WHERE PROCESS_DATE < @P_RETENTION_DATE
								UNION
								SELECT PARTY_KEY FROM WLF_HITS WHERE HIT_TIMESTAMP < @P_RETENTION_DATE AND @P_PURGEPRIORHITS = 1
								UNION
								SELECT PARTY_KEY FROM WLF_HIT_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE
								UNION
								SELECT PARTY_KEY FROM WLF_ENTITY_EXCLUDE_ENTRIES WHERE EXPIRATION_DATE < @P_RETENTION_DATE))

				SELECT 
					ERROR_NUMBER()    AS ERRORNUMBER ,
					ERROR_SEVERITY()  AS ERRORSEVERITY ,
					ERROR_STATE()     AS ERRORSTATE ,
					ERROR_PROCEDURE() AS ERRORPROCEDURE ,
					ERROR_LINE()      AS ERRORLINE ,
					ERROR_MESSAGE()   AS ERRORMESSAGE; 
						   THROW
					END CATCH 
		END
		@go@


		if exists (select * from sysobjects where name = 'WLF_PURGE_SRCH_LOG')
			drop procedure @env:lm_schema_name@.WLF_PURGE_SRCH_LOG
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_SRCH_LOG
        @P_PURGE_DATE DATE
		AS 
		 BEGIN  
			SET NOCOUNT ON 
			DECLARE @SRCHLOG_DT VARCHAR(8)

			  BEGIN TRY

					/********  audit - purge candidates **********/
					TRUNCATE TABLE WLF_PURGE_SRCH_CANDIDATES
					TRUNCATE TABLE WLF_PURGE_SRCH_RESULT

					 INSERT INTO WLF_PURGE_SRCH_CANDIDATES(PARTY_KEY)   
					 ( SELECT DISTINCT PARTY_KEY FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE)
						

					 DECLARE SRCHLOG_CUR CURSOR LOCAL STATIC FOR 
						   SELECT  CONVERT(VARCHAR(8),(sprv.value), 112) AS VALUE
						   FROM sys.partition_functions AS spf 
						   INNER JOIN sys.partition_range_values  sprv 
									ON sprv.function_id=spf.function_id  
						   WHERE (spf.name=N'srch_log_partfunc') 
							AND sprv.value <= @P_PURGE_DATE

					  OPEN SRCHLOG_CUR
					  FETCH NEXT FROM SRCHLOG_CUR 
					  INTO @SRCHLOG_DT

					  WHILE @@FETCH_STATUS = 0
						 BEGIN
						  IF @SRCHLOG_DT <> CAST('19800101' AS DATETIME)
							  BEGIN
								 EXECUTE WLF_SRCHLOG_DROP_PARTITION @SRCHLOG_DT
							 END
						  FETCH NEXT FROM SRCHLOG_CUR
						  INTO @SRCHLOG_DT
						 END

						CLOSE SRCHLOG_CUR
						DEALLOCATE SRCHLOG_CUR

						
						DELETE WLF_SRCH_LOG  FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE

					  /***************  audit - purge result ****************/                
					 INSERT INTO WLF_PURGE_SRCH_RESULT(PARTY_KEY)   
					 ( SELECT PARTY_KEY FROM  WLF_PURGE_SRCH_CANDIDATES 
					   EXCEPT
					 ( SELECT DISTINCT PARTY_KEY FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE))
				 
			END  TRY
			BEGIN CATCH 
					   /***************  audit - purge result ****************/                
						 INSERT INTO WLF_PURGE_SRCH_RESULT(PARTY_KEY)   
						( SELECT PARTY_KEY FROM  WLF_PURGE_SRCH_CANDIDATES 
						 EXCEPT
						( SELECT DISTINCT PARTY_KEY FROM WLF_SRCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE))

						SELECT 
							ERROR_NUMBER()    AS ERRORNUMBER ,
							ERROR_SEVERITY()  AS ERRORSEVERITY ,
							ERROR_STATE()     AS ERRORSTATE ,
							ERROR_PROCEDURE() AS ERRORPROCEDURE ,
							ERROR_LINE()      AS ERRORLINE ,
							ERROR_MESSAGE()   AS ERRORMESSAGE; 
							THROW
			END CATCH 
	END
	@go@
	
		
		if exists (select * from sysobjects where name = 'WLF_PURGE_MESSAGE_SRCH_LOG')
		drop procedure @env:lm_schema_name@.WLF_PURGE_MESSAGE_SRCH_LOG
		@go@

		CREATE PROCEDURE @env:lm_schema_name@.WLF_PURGE_MESSAGE_SRCH_LOG
        @P_PURGE_DATE DATE
	AS 
	 BEGIN  
		SET NOCOUNT ON 
		DECLARE @SRCHLOG_DT VARCHAR(8)

          BEGIN TRY
                 /********  audit - purge candidates **********/
                 TRUNCATE TABLE WLF_PURGE_MS_SRCH_CANDIDATES
                 TRUNCATE TABLE WLF_PURGE_MS_SRCH_RESULT

                 INSERT INTO WLF_PURGE_MS_SRCH_CANDIDATES(MESSAGE_KEY)   
                 ( SELECT DISTINCT MESSAGE_KEY FROM WLF_MESSAGE_SEARCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE)

 
                  DECLARE SRCHLOG_CUR CURSOR LOCAL STATIC FOR 
                       SELECT  CONVERT(VARCHAR(8),(sprv.value), 112) AS VALUE
                       FROM sys.partition_functions AS spf 
                       INNER JOIN sys.partition_range_values  sprv 
                                ON sprv.function_id=spf.function_id  
                       WHERE (spf.name=N'srch_log_ms_partfunc') 
                        AND sprv.value <= @P_PURGE_DATE

                  OPEN SRCHLOG_CUR
                  FETCH NEXT FROM SRCHLOG_CUR 
                  INTO @SRCHLOG_DT

                  WHILE @@FETCH_STATUS = 0
                     BEGIN
                      IF @SRCHLOG_DT <> CAST('19800101' AS DATETIME)
                          BEGIN
                             EXECUTE WLF_MS_SRCHLOG_DROP_PARTITION @SRCHLOG_DT
                         END
                      FETCH NEXT FROM SRCHLOG_CUR
                      INTO @SRCHLOG_DT
                     END

                    CLOSE SRCHLOG_CUR
                    DEALLOCATE SRCHLOG_CUR

                    
                    DELETE WLF_MESSAGE_SEARCH_LOG  FROM WLF_MESSAGE_SEARCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE

                  /***************  audit - purge result ****************/                
                 INSERT INTO  WLF_PURGE_MS_SRCH_RESULT(MESSAGE_KEY)   
                 ( SELECT MESSAGE_KEY FROM  WLF_PURGE_MS_SRCH_CANDIDATES
                   EXCEPT
                 ( SELECT DISTINCT MESSAGE_KEY FROM WLF_MESSAGE_SEARCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE))

             
        END  TRY
        BEGIN CATCH 
                  /***************  audit - purge result ****************/                
                 INSERT INTO  WLF_PURGE_MS_SRCH_RESULT(MESSAGE_KEY)   
                 ( SELECT MESSAGE_KEY FROM  WLF_PURGE_MS_SRCH_CANDIDATES
                   EXCEPT
                 ( SELECT DISTINCT MESSAGE_KEY FROM WLF_MESSAGE_SEARCH_LOG WHERE JOB_TIMESTAMP < @P_PURGE_DATE))

                SELECT 
                        ERROR_NUMBER()    AS ERRORNUMBER ,
                        ERROR_SEVERITY()  AS ERRORSEVERITY ,
                        ERROR_STATE()     AS ERRORSTATE ,
                        ERROR_PROCEDURE() AS ERRORPROCEDURE ,
                        ERROR_LINE()      AS ERRORLINE ,
                        ERROR_MESSAGE()   AS ERRORMESSAGE; 
                        THROW
        END CATCH 
		END
	@go@

]
[oracle
    CREATE OR REPLACE PROCEDURE @env:lm_schema_name@.WLF_LM_DROP_PARTITION ( P_LIST_VER_IDENTIFIER NUMBER )
    AS
    TYPE CURSOR_TABLE IS
    		TABLE OF VARCHAR2(50);
    C1_CURSOR_TABLE CURSOR_TABLE;
    P_PART_NAME     VARCHAR2(30);
    V_SQL           VARCHAR2(1000);
    EXEC_STR        VARCHAR2(1000);
    FILTER1  VARCHAR2(30) := 'WLF%';
    FILTER2  VARCHAR2(30) := 'WLF_LATEST_LIST_ENTRIES';

    BEGIN
        P_PART_NAME := 'P' || TO_CHAR(P_LIST_VER_IDENTIFIER);
        --dbms_output.put_line('v_sql: ' || to_char(v_sql));
        V_SQL := 'SELECT TABLE_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME LIKE '  || '''' || FILTER1 || ''''
                     || ' AND TABLE_NAME != '
                     || '''' || FILTER2 || ''''
                     || '  AND PARTITION_NAME = '''
                     || P_PART_NAME
                     || '''';
        --dbms_output.put_line('v_sql: ' || to_char(v_sql));
        EXECUTE IMMEDIATE V_SQL
        BULK COLLECT
        INTO C1_CURSOR_TABLE;
        FOR i IN 1..C1_CURSOR_TABLE.COUNT LOOP
            IF i IS NOT NULL THEN
                EXEC_STR := 'ALTER TABLE "'
                            || C1_CURSOR_TABLE(i)
                            || '"'
                            || ' DROP PARTITION '
                            || P_PART_NAME;
                EXECUTE IMMEDIATE ( EXEC_STR );
            END IF;
        END LOOP;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END;
	@go@
]

[oracle
    CREATE OR REPLACE PROCEDURE WLF_LM_DROP_ODD_PARTITION_LIST (P_LIST_ID VARCHAR2 )
     AS

     P_LIST_ID_PART  NUMBER;

     BEGIN

          SELECT NVL(LATEST_LIST_ID_PART, -1)
          INTO P_LIST_ID_PART
          FROM WLF_LIST_DEFINITIONS
          WHERE LIST_ID = P_LIST_ID;

          FOR CUR IN (SELECT DISTINCT LIST_ID_PART FROM WLF_LATEST_LIST_ENTRIES
          WHERE LIST_ID = P_LIST_ID AND LIST_ID_PART <> P_LIST_ID_PART)
          LOOP
            IF CUR.LIST_ID_PART IS NOT NULL THEN
               WLF_LM_DROP_PARTITION_LIST(CUR.LIST_ID_PART);
            END IF;
          END LOOP;


      EXCEPTION
       WHEN OTHERS THEN
       raise_application_error (-20001,SQLERRM);
    END;
    @go@
]



[mssql
    if exists (select * from sysobjects where name = 'WLF_LM_DROP_ODD_PARTITION_LIST')
            drop procedure dbo.WLF_LM_DROP_ODD_PARTITION_LIST
        @go@

        CREATE PROCEDURE dbo.WLF_LM_DROP_ODD_PARTITION_LIST
        @P_LIST_ID VARCHAR(50) WITH EXECUTE AS OWNER
        AS

        BEGIN

            BEGIN TRY

                DECLARE
                @P_LIST_ID_PART int,
                @P_PARTITION int


                SELECT @P_LIST_ID_PART = ISNULL(LATEST_LIST_ID_PART, -1)
                FROM WLF_LIST_DEFINITIONS
                WHERE LIST_ID = @P_LIST_ID

                DECLARE
                SET_ODD_PARTITIONS CURSOR LOCAL FOR
                SELECT DISTINCT LIST_ID_PART FROM WLF_LATEST_LIST_ENTRIES
                WHERE LIST_ID = @P_LIST_ID AND LIST_ID_PART <> @P_LIST_ID_PART

                OPEN SET_ODD_PARTITIONS
                FETCH NEXT FROM SET_ODD_PARTITIONS INTO @P_PARTITION
                WHILE @@FETCH_STATUS = 0
                BEGIN
                    IF @P_PARTITION IS NOT NULL
                    BEGIN
                        EXECUTE WLF_LM_DROP_PARTITION_LIST @P_PARTITION
                    END
                    FETCH NEXT FROM SET_ODD_PARTITIONS INTO @P_PARTITION
                END
                CLOSE SET_ODD_PARTITIONS

            END TRY

            BEGIN CATCH

                SELECT
                ERROR_NUMBER() AS ErrorNumber,
                ERROR_SEVERITY() AS ErrorSeverity,
                ERROR_STATE() AS ErrorState,
                ERROR_PROCEDURE() AS ErrorProcedure,
                ERROR_LINE() AS ErrorLine,
                ERROR_MESSAGE() AS ErrorMessage;
                THROW

            END CATCH

        END

       @go@
]

[oracle
	--------------------------------------------------------------------------------------------------------------
	---------- this part must be last in the main except the sqlplus ----------
	begin
	for obj in (select table_name from user_tables
			    where iot_name is null)
	  loop
	     execute immediate('grant select,insert,delete,update on @env:lm_schema_name@.'||obj.table_name||' to @env:role_batch_lm_objects@');
	  end loop;
	end;
	/
	begin
	for obj in (select view_name from user_views)
	  loop
	   execute immediate('grant select on @env:lm_schema_name@.'||obj.view_name||' to @env:role_batch_lm_objects@');
	  end loop;
	end;
	/
	begin
	for obj in (select object_name from user_procedures where object_type='FUNCTION' )
	  loop
	    execute immediate('grant execute on @env:lm_schema_name@.'||obj.object_name||' to @env:role_batch_lm_procs@');
	  end loop;
	end;
	/
	begin
	for obj in (select object_name from user_procedures where object_type='PROCEDURE' )
	  loop
	    execute immediate('grant execute on @env:lm_schema_name@.'||obj.object_name||' to @env:role_batch_lm_procs@');
	  end loop;
	end;
			/ 

	---------------------------------------------------------------------------------------------------------------------
	------------------------------   Permissions section ----------------------------------------------------------------
	---------------------------------------------------------------------------------------------------------------------
	/*this part must be last in the main except the sqlplus*/
	/*******************************************************************************************************************************************************/
	commit;
	

	/****************************
	BEGIN SQL*PLUS-specific code
	****************************/
	SPOOL OFF;
	quit
	/****************************
	END SQL*PLUS-specific code
	****************************/
]
